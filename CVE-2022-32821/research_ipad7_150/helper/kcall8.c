#include "offsets.h"
#include "tfp0_krw.h"
#include "kexecute.h"

uint64_t tfp0_kcall8(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6, uint64_t x7) {
    uint64_t kpage = tfp0_kalloc(0x1000);

    tfp0_kwrite64(kpage, kpage);
    tfp0_kwrite64(kpage + 0x98, kpage);
    tfp0_kwrite64(kpage + 0x7C0, kgad(KGADGET_POPULATE));
    tfp0_kwrite64(kpage + 0x10, kgad(KGADGET_MOV_X14_X3__BR_X4));
    tfp0_kwrite64(kpage + 0x18, kpage + 0x800);
    tfp0_kwrite64(kpage + 0x20, kgad(KGADGET_POPULATE));
    tfp0_kwrite64(kpage + 0x28, kgad(KGADGET_MOV_X7_X14__BR_X15));
    tfp0_kwrite64(kpage + 0x30, x7);
    tfp0_kwrite64(kpage + 0x38, kgad(KGADGET_MOV_X15_X1__BR_X2));
    tfp0_kwrite64(kpage + 0x810, kgad(KGADGET_MOV_X10_X1__BR_X3));
    tfp0_kwrite64(kpage + 0x818, kpage + 0x840);
    tfp0_kwrite64(kpage + 0x820, kgad(KGADGET_POPULATE));
    tfp0_kwrite64(kpage + 0x828, kgad(KGADGET_POPULATE));
    tfp0_kwrite64(kpage + 0x830, kgad(KGADGET_MOV_X11_X4__BR_X2));
    tfp0_kwrite64(kpage + 0x838, addr);
    tfp0_kwrite64(kpage + 0x850, kgad(KGADGET_MOV_X15_X2__BR_X3));
    tfp0_kwrite64(kpage + 0x858, kpage + 0x880);
    tfp0_kwrite64(kpage + 0x860, x6);
    tfp0_kwrite64(kpage + 0x868, kgad(KGADGET_MOV_X6_X9__BR_X11));
    tfp0_kwrite64(kpage + 0x870, kgad(KGADGET_MOV_X9_X1__BR_X10));
    tfp0_kwrite64(kpage + 0x878, 0);
    tfp0_kwrite64(kpage + 0x890, kgad(KGADGET_MOV_X5_X6__BR_X15));
    tfp0_kwrite64(kpage + 0x898, x0);
    tfp0_kwrite64(kpage + 0x8A0, x1);
    tfp0_kwrite64(kpage + 0x8A8, x2);
    tfp0_kwrite64(kpage + 0x8B0, x3);
    tfp0_kwrite64(kpage + 0x8B8, x4);
    x6 = x5;

    uint64_t STORED_RET = kpage + 0x100;
    kexecute(kgad(KGADGET_PROLOGUE), kpage, STORED_RET, 0, 0, 0, x5, x6);

    uint64_t kret =  tfp0_kread64(STORED_RET);
    tfp0_kfree(kpage, 0x1000);
    return kret;
}

uint64_t kvtophys(uint64_t va)
{
	/**
	 * Attempt to do the translation first in hardware using the AT (address
	 * translation) instruction. This will attempt to use the MMU to do the
	 * translation for us.
	 */
	// uint64_t pa = mmu_kvtop(va);
    uint64_t pa = tfp0_kcall8(ksym(KSYMBOL_MMU_KVTOP), va, 0, 0, 0, 0, 0, 0, 0);

	if (pa) {
		return pa;
	}

	/* If the MMU can't find the mapping, then manually walk the page tables. */
	// return pmap_vtophys(kernel_pmap, va);
    return tfp0_kcall8(ksym(KSYMBOL_PMAP_VTOPHYS), ksym(KSYMBOL_KERNEL_PMAP), va, 0, 0, 0, 0, 0, 0);
}

uint64_t phystokv(uint64_t pa) {
    return tfp0_kcall8(ksym(KSYMBOL_PHYSTOKV), pa, 0, 0, 0, 0, 0, 0, 0);
}

uint64_t physread64(uint64_t pa) {
    union {
        uint32_t u32[2];
        uint64_t u64;
    } u;

    u.u32[0] = (uint32_t)tfp0_kcall8(ksym(KSYMBOL_ml_phys_read_data), pa, 4, 0, 0, 0, 0, 0, 0);
    u.u32[1] = (uint32_t)tfp0_kcall8(ksym(KSYMBOL_ml_phys_read_data), pa+4, 4, 0, 0, 0, 0, 0, 0);
    return u.u64;
}
