#include "kextrw.h"
#include "find_IOSurface.h"
#include "find_port.h"
#include "print.h"

#include <stdlib.h>

// An IOSurfaceRootUserClient instance.
extern mach_port_t IOSurfaceRootUserClient;

// The ID of the IOSurface we're using.
// extern uint32_t IOSurface_id;
uint32_t IOSurface_id;

uint64_t userdict_from_IOSurface(void) {
	uint64_t surfRoot = port_to_kobject(IOSurfaceRootUserClient);
	INFO("surfRoot: 0x%llx\n", surfRoot);

	// p/x offsetof(IOSurfaceRootUserClient, IOSurfaceClientArray) = 0x118;
	uint64_t surfClients = kextrw_kread64(surfRoot + 0x118);
	INFO("surfClients: 0x%llx\n", surfClients);

	uint64_t surfClient = kextrw_kread64(surfClients + sizeof(uint64_t) * IOSurface_id);
	INFO("surfClient: 0x%llx\n", surfClient);

	// p/x offsetof(IOSurfaceClient, IOSurface) = 0x40;
	uint64_t surface = kextrw_kread64(surfClient + 0x40);
	INFO("surface: 0x%llx\n", surface);

	// p/x offsetof(IOSurface, UserspaceValueDictionary) = 0xe8
	uint64_t userspaceValueDicts = kextrw_kread64(surface + 0xe8);

	if(userspaceValueDicts != 0) return userspaceValueDicts;

	return 0;
}

//Thanks pattern-f, https://github.com/pattern-f/TQ-pre-jailbreak/blob/main/mylib/k_utils.c#L173
//found OSDictionary offsets from kernelcache.development.n71_151b3_6s
struct kOSDict *kernel_fetch_dict(uint64_t dict_addr)
{
    char obj[0x28];
    kextrw_kreadbuf(dict_addr, obj, sizeof(obj));
    uint32_t cap = *(uint32_t *)(obj + 0x18); // 0x18 = p/x offsetof(OSDictionary, capacity)
    struct kOSDict *dict;
    size_t alloc_size = sizeof(*dict) + cap * (sizeof(struct kDictEntry) + sizeof(char *) + 256);
    dict = (struct kOSDict *)malloc(alloc_size);
    dict->self_addr = dict_addr;
    dict->cap = cap;
    dict->count = *(uint32_t *)(obj + 0x14); // 0x14 = p/x offsetof(OSDictionary, count)
    dict->items_addr = kextrw_kread64(dict_addr + 0x20); // 0x20 = p/x offsetof(OSDictionary, dictionary)
    char *ptr = dict->data;
    dict->items = (struct kDictEntry *)ptr;
    ptr += sizeof(struct kDictEntry) * dict->cap;
    dict->names = (char **)ptr;
    ptr += sizeof(char *) * dict->cap;
    for (int i = 0; i < dict->cap; i++) {
        dict->names[i] = ptr;
        ptr += 256;
    }
    INFO("dict %#llx, items %#llx, count %u, capacity %u\n",
            dict->self_addr, dict->items_addr, dict->count, dict->cap);
	
    alloc_size = sizeof(struct kDictEntry) * dict->cap;
    kextrw_kreadbuf(dict->items_addr, dict->items, alloc_size);
    for (int i = 0; i < dict->count; i++) {
        char obj[0x18];
        kextrw_kreadbuf(dict->items[i].key, obj, sizeof(obj));
        // OSSymbol
        uint32_t len = *(uint32_t *)(obj + 0xc) >> 14;
        if (len >= 256) {
            len = 255;
        }
        uint64_t string = *(uint64_t *)(obj + 0x10);	//0x10 = p/x offsetof(OSString, string)
        kextrw_kreadbuf(string, dict->names[i], len);
        dict->names[i][len] = 0;
        // INFO("    -> %s\n", dict->names[i]);
    }
    return dict;
}