#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

#include "helper.h"
#include "iokit.h"
#include "exp.h"

const uint32_t IOSURFACE_UC_TYPE             =  0;
const uint32_t IOSURFACE_CREATE_SURFACE      =  0;
#define IOSURFACE_CREATE_OUTSIZE 0xdd0 /* for iOS 13.3 / macOS 10.15.2, 10.14.1 varies with version */

extern const mach_port_t kIOMasterPortDefault;
uint32_t IOSurface_id;
mach_port_t IOSurfaceRootUserClient;
struct _IOSurfaceFastCreateArgs {
    uint64_t address;
    uint32_t width;
    uint32_t height;
    uint32_t pixel_format;
    uint32_t bytes_per_element;
    uint32_t bytes_per_row;
    uint32_t alloc_size;
};
struct IOSurfaceLockResult {
    uint64_t addr1;
    uint64_t addr2;
    uint64_t addr3;
    uint32_t surface_id;
    uint8_t _pad2[0xdd0-0x18-0x4];
};

// The ID of the IOSurface we're using.
uint32_t IOSurface_id;

// Is the IOSurface subsystem initialized?
static bool IOSurface_initialized;



bool
IOSurface_init() {
    if (IOSurface_initialized) {
		return true;
	}

    uint64_t result = 0;
    kern_return_t ret;
    task_t self = mach_task_self();
    io_service_t service = MACH_PORT_NULL;
    io_connect_t client  = MACH_PORT_NULL;

    uint32_t dict[] =
    {
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,

        kOSSerializeSymbol | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, // "IOSurfaceAllocSize"
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x1000,
        0x0,
    };

    service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    INFO("service: %x\n", service);
    if(!MACH_PORT_VALID(service)) goto out;

    ret = IOServiceOpen(service, self, IOSURFACE_UC_TYPE, &client);
    INFO("client: %x, %s\n", client, mach_error_string(ret));
    if(ret != KERN_SUCCESS || !MACH_PORT_VALID(client)) goto out;

    union
    {
        char _padding[IOSURFACE_CREATE_OUTSIZE];
        struct
        {
            mach_vm_address_t addr1;
            mach_vm_address_t addr2;
            mach_vm_address_t addr3;
            uint32_t id;
        } data;
    } surface;
    size_t size = sizeof(surface);
    ret = IOConnectCallStructMethod(client, IOSURFACE_CREATE_SURFACE, dict, sizeof(dict), &surface, &size);

    IOSurface_id = surface.data.id;
    if (!IOSurface_id) {
        IOSurface_id = (uint32_t)surface.data.addr3;
    }
    INFO("Got IOSurface_id: 0x%x\n", IOSurface_id);
    IOSurface_initialized = true;
    return true;

    out:;
    IOServiceClose(client);
    IOObjectRelease(service);
    
    return false;
}
