#include "tfp0_krw.h"
#include "offsets.h"
#include <stdint.h>
#include <mach/mach.h> 
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <dlfcn.h>
#include <IOKit/IOKitLib.h>
#include <mach-o/loader.h>
#include <inttypes.h>
#include <CoreFoundation/CoreFoundation.h>

task_t tfp0 = MACH_PORT_NULL;
uint64_t gKernelBase = 0, gKernelSlide = 0;

#ifndef MIN
#    define MIN(a, b) ((a) < (b) ? (a) : (b))
#endif

kern_return_t
tfp0_init(void) {
	kern_return_t ret = task_for_pid(mach_task_self(), 0, &tfp0);
	mach_port_t host;
	pid_t pid;

    printf("tfp0 ret: 0x%x (%s)\n", ret, mach_error_string(ret));

	if(ret != KERN_SUCCESS) {
		host = mach_host_self();
		if(MACH_PORT_VALID(host)) {
			printf("host: 0x%" PRIx32 "\n", host);
			ret = host_get_special_port(host, HOST_LOCAL_NODE, 4, &tfp0);
			mach_port_deallocate(mach_task_self(), host);
		}
	}
	if(ret == KERN_SUCCESS && MACH_PORT_VALID(tfp0)) {
		if(pid_for_task(tfp0, &pid) == KERN_SUCCESS && pid == 0) {
			return ret;
		}
		mach_port_deallocate(mach_task_self(), tfp0);
	}
	return KERN_FAILURE;
}

void tfp0_deinit(void) {
    mach_port_deallocate(mach_task_self(), tfp0);
}

uint64_t get_kbase_via_kext(void) {
    struct {
		uint32_t pri_prot, pri_max_prot, pri_inheritance, pri_flags;
		uint64_t pri_offset;
		uint32_t pri_behavior, pri_user_wired_cnt, pri_user_tag, pri_pages_resident, pri_pages_shared_now_private, pri_pages_swapped_out, pri_pages_dirtied, pri_ref_cnt, pri_shadow_depth, pri_share_mode, pri_private_pages_resident, pri_shared_pages_resident, pri_obj_id, pri_depth;
		uint64_t pri_addr;
		uint64_t pri_sz;
	} pri;

    char kext_name[KMOD_MAX_NAME];
    CFStringRef kext_name_cf;
    CFNumberRef kext_addr_cf;
    CFArrayRef kext_names;
    CFDictionaryRef kexts_info;
    CFDictionaryRef kext_info;
    uint64_t kext_addr;

    for(pri.pri_addr = 0; proc_pidinfo(0, PROC_PIDREGIONINFO, pri.pri_addr, &pri, sizeof(pri)) == sizeof(pri); pri.pri_addr += pri.pri_sz) {
        if(pri.pri_prot == VM_PROT_READ && pri.pri_user_tag == VM_KERN_MEMORY_OSKEXT) {
            break;
        }
    }

    if(tfp0_kreadbuf(pri.pri_addr + LOADED_KEXT_SUMMARY_HDR_NAME_OFF, kext_name, sizeof(kext_name)) != KERN_SUCCESS) return 0;
    printf("kext_name: %s\n", kext_name);

    uint64_t kext_addr_slid = tfp0_kread64(pri.pri_addr + LOADED_KEXT_SUMMARY_HDR_ADDR_OFF);
    printf("kext_addr_slid: 0x%llx\n", kext_addr_slid);

    if((kext_name_cf = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault, kext_name, kCFStringEncodingUTF8, kCFAllocatorNull)) == NULL) return 0;

    if((kext_names = CFArrayCreate(kCFAllocatorDefault, (const void **)&kext_name_cf, 1, &kCFTypeArrayCallBacks)) == NULL) return 0;

    if((kexts_info = OSKextCopyLoadedKextInfo(kext_names, NULL)) == NULL) return 0;

    if(CFGetTypeID(kexts_info) != CFDictionaryGetTypeID())  return 0;

    if(CFDictionaryGetCount(kexts_info) != 1)   return 0;

    if((kext_info = CFDictionaryGetValue(kexts_info, kext_name_cf)) == NULL)   return 0;

    if(CFGetTypeID(kext_info) != CFDictionaryGetTypeID())   return 0;

    if((kext_addr_cf = CFDictionaryGetValue(kext_info, CFSTR(kOSBundleLoadAddressKey))) == NULL)  return 0;

    if(CFGetTypeID(kext_addr_cf) != CFNumberGetTypeID())    return 0;

    if(!(CFNumberGetValue(kext_addr_cf, kCFNumberSInt64Type, &kext_addr)))  return 0;

    if(!(kext_addr_slid > kext_addr))   return 0;

    uint64_t kbase = 0xfffffff007004000 + (kext_addr_slid - kext_addr);

    return kbase;
}

int tfp0_get_kernel_base(void)
{
    int64_t kbase = get_kbase_via_kext();
    if(kbase != 0) {
        gKernelBase = kbase;
        gKernelSlide = kbase - 0xfffffff007004000;
    }
    return 0;
}

kern_return_t
tfp0_kreadbuf(uint64_t kaddr, void *buf, size_t sz) {
    mach_vm_address_t p = (mach_vm_address_t)buf;
    mach_vm_size_t read_sz, out_sz = 0;

    while(sz != 0) {
        read_sz = MIN(sz, vm_kernel_page_size - (kaddr & vm_kernel_page_mask));
        if(mach_vm_read_overwrite(tfp0, kaddr, read_sz, p, &out_sz) != KERN_SUCCESS || out_sz != read_sz) {
            return KERN_FAILURE;
        }
        p += read_sz;
        sz -= read_sz;
        kaddr += read_sz;
    }
    return KERN_SUCCESS;
}

kern_return_t
tfp0_kwritebuf(uint64_t kaddr, const void *buf, size_t sz) {
    vm_machine_attribute_val_t mattr_val = MATTR_VAL_CACHE_FLUSH;
    mach_vm_address_t p = (mach_vm_address_t)buf;
    mach_msg_type_number_t write_sz;

    while(sz != 0) {
        write_sz = (mach_msg_type_number_t)MIN(sz, vm_kernel_page_size - (kaddr & vm_kernel_page_mask));
        if(mach_vm_write(tfp0, kaddr, p, write_sz) != KERN_SUCCESS || mach_vm_machine_attribute(tfp0, kaddr, write_sz, MATTR_CACHE, &mattr_val) != KERN_SUCCESS) {
            return KERN_FAILURE;
        }
        p += write_sz;
        sz -= write_sz;
        kaddr += write_sz;
    }
    return KERN_SUCCESS;
}

uint8_t tfp0_kread8(uint64_t where) {
    uint8_t out;
    tfp0_kreadbuf(where, &out, sizeof(uint8_t));
    return out;
}

uint16_t tfp0_kread16(uint64_t where) {
    uint16_t out;
    tfp0_kreadbuf(where, &out, sizeof(uint16_t));
    return out;
}

uint32_t tfp0_kread32(uint64_t where) {
    uint32_t out;
    tfp0_kreadbuf(where, &out, sizeof(uint32_t));
    return out;
}

uint64_t tfp0_kread64(uint64_t where) {
    uint64_t out;
    tfp0_kreadbuf(where, &out, sizeof(uint64_t));
    return out;
}


void tfp0_kwrite8(uint64_t where, uint8_t what) {
    uint8_t _what = what;
    tfp0_kwritebuf(where, &_what, sizeof(uint8_t));
}

void tfp0_kwrite16(uint64_t where, uint16_t what) {
    uint16_t _what = what;
    tfp0_kwritebuf(where, &_what, sizeof(uint16_t));
}

void tfp0_kwrite32(uint64_t where, uint32_t what) {
    uint32_t _what = what;
    tfp0_kwritebuf(where, &_what, sizeof(uint32_t));
}

void tfp0_kwrite64(uint64_t where, uint64_t what) {
    uint64_t _what = what;
    tfp0_kwritebuf(where, &_what, sizeof(uint64_t));
}

void tfp0_khexdump(uint64_t addr, size_t size) {
    void *data = malloc(size);
    tfp0_kreadbuf(addr, data, size);
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        if ((i % 16) == 0)
        {
            printf("[0x%016llx+0x%03zx] ", addr, i);
//            printf("[0x%016llx] ", i + addr);
        }
        
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
    free(data);
}
