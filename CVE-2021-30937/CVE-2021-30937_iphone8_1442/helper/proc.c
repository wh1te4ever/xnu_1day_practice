#include <stdint.h>
#include <mach/mach.h> 
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <dlfcn.h>
#include <inttypes.h>
#include <unistd.h>

#include "offsets.h"
#include "tfp0_krw.h"


uint64_t proc_of_pid(pid_t pid) {
    uint64_t proc = tfp0_kread64(ksym(KSYMBOL_KERNPROC));  

    while (1) {
        if(tfp0_kread32(proc + off_p_pid) == pid) {
            return proc;
        }
        proc = tfp0_kread64(proc + off_p_list_le_prev);
        if(!proc) {
            return -1;
        }
    }
    
    return 0;
}


uint64_t proc_task(uint64_t proc) {
    uint64_t task = tfp0_kread64(proc + off_p_task);
    return task;
}

uint64_t task_self_addr(void) {
    uint64_t proc = proc_of_pid(getpid());
    uint64_t task = proc_task(proc);
    return task;
}

// uint64_t task_self_addr() {
//     uint64_t proc = proc_of_pid(getpid());
//     uint64_t task = kread64(proc + off_p_task);
//     return task;
// }

// uint64_t proc_by_name(char* nm) {
//     uint64_t proc = kread64(ksym(KSYMBOL_KERNPROC));
    
//     while (1) {
//         uint64_t nameptr = proc + off_p_name;
//         char name[32];
//         kreadbuf(nameptr, &name, 32);
//         if(strcmp(name, nm) == 0) {
//             return proc;
//         }
//         proc = kread64(proc + off_p_list_le_prev);
//         if(!proc) {
//             return -1;
//         }
//     }
    
//     return 0;
// }

// uint64_t get_task_pmap(uint64_t task) {
//     uint64_t vm_map = kread64(task + off_task_map);
// 	if (vm_map) {
// 		uint64_t pmap = kread64(vm_map + off_vm_map_pmap);
//         if(pmap) return pmap;
//     }
//     return 0;
// }

// uint64_t proc_task(uint64_t proc) {
//     return kread64(proc + off_p_task);
// }