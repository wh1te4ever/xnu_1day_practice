#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <mach/mach.h>

#include "print.h"
#include "iokit.h"
#include "iosurface.h"

// The ID of the IOSurface we're using.
uint32_t IOSurface_id;

// Is the IOSurface subsystem initialized?
bool IOSurface_initialized;

// The IOSurfaceRoot service.
mach_port_t IOSurfaceRoot;

// An IOSurfaceRootUserClient instance.
mach_port_t IOSurfaceRootUserClient;

// Kernel Page Size.
mach_vm_size_t pagesize;


bool
IOSurface_init() {
    if (IOSurface_initialized) {
		return true;
	}

    IOSurfaceRoot = IOServiceGetMatchingService(
        kIOMasterPortDefault,
        IOServiceMatching("IOSurfaceRoot"));

    if (IOSurfaceRoot == MACH_PORT_NULL) {
        ERROR("Couldn't find IOSurfaceRoot\n");
        return false;
    }

    kern_return_t kr = IOServiceOpen(
        IOSurfaceRoot,
        mach_task_self(),
        0,
        &IOSurfaceRootUserClient);
    if(kr != KERN_SUCCESS) {
        ERROR("Couldn't open IOSurfaceRootUserClient, kr=0x%x (%s)\n", kr, mach_error_string(kr));
        return false;
    }

    vm_size_t pgsz = 0;
    kr = _host_page_size(mach_host_self(), &pgsz);
    pagesize = pgsz;
    INFO("page size: 0x%llx, kr=%s\n", pagesize, mach_error_string(kr));
    if(kr != KERN_SUCCESS) {
        ERROR("Failed to get kernel page size, kr=0x%x (%s)\n", kr, mach_error_string(kr));
        return false;
    }

    uint32_t dict_create[] =
    {
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,

        kOSSerializeSymbol | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, // "IOSurfaceAllocSize"
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x1000,
        0x0,
    };

    struct IOSurfaceLockResult lock_result;
    size_t lock_result_size = sizeof(lock_result);
    bzero(&lock_result, lock_result_size);

    kr = IOConnectCallStructMethod(
        IOSurfaceRootUserClient,
        0,   //IOSurfaceRootUserClient::s_create_surface
        dict_create, sizeof(dict_create),
        &lock_result, &lock_result_size);
    if (kr != KERN_SUCCESS)
    {
        ERROR("Failed to call create_surface, kr=0x%x (%s)\n", kr, mach_error_string(kr));
        return false;
    }

    IOSurface_id = lock_result.surface_id;
    IOSurface_initialized = true;
    INFO("IOSurface_init success, IOSurface_id=0x%x\n", IOSurface_id);
    return true;
}

/*
 * IOSurface_set_value
 *
 * Description:
 * 	A wrapper around IOSurfaceRootUserClient::set_value().
 */
kern_return_t
IOSurface_set_value(const struct IOSurfaceValueArgs *args, size_t args_size) {
	struct IOSurfaceValueResultArgs result;
	size_t result_size = sizeof(result);
	kern_return_t kr = IOConnectCallStructMethod(
			IOSurfaceRootUserClient,
			9, // set_value
			args, args_size,
			&result, &result_size);
	if (kr != KERN_SUCCESS) {
		ERROR("failed to %s value in %s: 0x%x", "set", "IOSurface", kr);
	}
	return kr;
}

/*
 * IOSurface_get_value
 *
 * Description:
 *     A wrapper around IOSurfaceRootUserClient::get_value().
 */
kern_return_t
IOSurface_get_value(const struct IOSurfaceValueArgs *in, size_t in_size,
        struct IOSurfaceValueArgs *out, size_t *out_size) {
    kern_return_t kr = IOConnectCallStructMethod(
            IOSurfaceRootUserClient,
            10, // get_value
            in, in_size,
            out, out_size);
    if (kr != KERN_SUCCESS) {
        ERROR("failed to %s value in %s: 0x%x", "get", "IOSurface", kr);
    }
    return kr;
}

/*
 * IOSurface_remove_value
 *
 * Description:
 * 	A wrapper around IOSurfaceRootUserClient::remove_value().
 */
kern_return_t
IOSurface_remove_value(const struct IOSurfaceValueArgs *args, size_t args_size) {
	struct IOSurfaceValueResultArgs result;
	size_t result_size = sizeof(result);
	kern_return_t kr = IOConnectCallMethod(
			IOSurfaceRootUserClient,
			11, // remove_value
			NULL, 0,
			args, args_size,
			NULL, NULL,
			&result, &result_size);
	if (kr != KERN_SUCCESS) {
		ERROR("failed to %s value in %s: 0x%x", "remove", "IOSurface", kr);
	}
	return kr;
}

void
IOSurface_deinit() {
	IOSurface_initialized = false;
	IOSurface_id = 0;
	IOServiceClose(IOSurfaceRootUserClient);
	IOObjectRelease(IOSurfaceRoot);
}

int IOSurface_empty_kalloc(uint32_t size, uint32_t kalloc_key) {
    uint32_t capacity = size / 16;
    
    if (capacity > 0x00ffffff) {
        printf("[-][IOSurface] Size too big for OSUnserializeBinary\n");
        return KERN_FAILURE;
    }
    
    size_t args_size = sizeof(struct IOSurfaceValueArgs) + 9 * 4;
    
    struct IOSurfaceValueArgs *args = calloc(1, args_size);
    args->surface_id = IOSurface_id;
    
    int i = 0;
    args->xml[i++] = kOSSerializeBinarySignature;                            //<kOSSerializeBinarySignature />
    args->xml[i++] = kOSSerializeArray | 2 | kOSSerializeEndCollection;      //<array capacity="2">
    args->xml[i++] = kOSSerializeDictionary | capacity;                      //<dict capacity="capacity">
    args->xml[i++] = kOSSerializeSymbol | 4;                                 //<sym len="4">
    args->xml[i++] = 0x00aabbcc;                                             //\xaa\xbb\xcc</sym>
    args->xml[i++] = kOSSerializeBoolean | kOSSerializeEndCollection;        //<false/></dict>
    args->xml[i++] = kOSSerializeSymbol | 5 | kOSSerializeEndCollection;     //<sym len="5">
    args->xml[i++] = kalloc_key;                                             //key</sym></array>
    args->xml[i++] = 0;

/*
    <kOSSerializeBinarySignature />
    <kOSSerializeArray>2</kOSSerializeArray>
    <kOSSerializeDictionary capacity=${capacity}>
        <kOSSerializeSymbol length=4>
            0x00aabbcc?
        </kOSSerializeSymbol>
        <kOSSerializeBoolean>false</kOSSerializeBoolean>
    </kOSSerializeDictionary>
    <kOSSerializeSymbol length=5>
        ${kalloc_key}
    </kOSSerializeSymbol>
    0 // Null-terminate
*/
    
    kern_return_t ret = IOSurface_set_value(args, args_size);
    free(args);
    return ret;
}

uint32_t transpose(uint32_t val) {
    uint32_t ret = 0;
    for (size_t i = 0; val > 0; i += 8) {
        ret += (val % 255) << i;
        val /= 255;
    }
    return ret + 0x01010101;
}