#import "krw.h"

#import <stdint.h>
#import <mach/mach.h> 
#import <errno.h>
#import <stdlib.h>
#import <stdio.h>
#import <dlfcn.h>
#import <inttypes.h>
#import <unistd.h>

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

task_t tfp0 = MACH_PORT_NULL;
extern void* libkernrw;
uint64_t kbase = 0;
uint64_t kslide = 0;

#ifndef MIN
#    define MIN(a, b) ((a) < (b) ? (a) : (b))
#endif


kern_return_t
init_tfp0(void) {
	kern_return_t ret = task_for_pid(mach_task_self(), 0, &tfp0);
	mach_port_t host;
	pid_t pid;

	if(ret != KERN_SUCCESS) {
		host = mach_host_self();
		if(MACH_PORT_VALID(host)) {
			printf("host: 0x%" PRIx32 "\n", host);
			ret = host_get_special_port(host, HOST_LOCAL_NODE, 4, &tfp0);
			mach_port_deallocate(mach_task_self(), host);
		}
	}
	if(ret == KERN_SUCCESS && MACH_PORT_VALID(tfp0)) {
		if(pid_for_task(tfp0, &pid) == KERN_SUCCESS && pid == 0) {
			return ret;
		}
		mach_port_deallocate(mach_task_self(), tfp0);
	}
	return KERN_FAILURE;
}


int get_kbase(uint64_t *addr)
{
    task_dyld_info_data_t info = {};
    uint32_t count = TASK_DYLD_INFO_COUNT;
    kern_return_t ret = task_info(tfp0, TASK_DYLD_INFO, (task_info_t)&info, &count);
    if(ret != KERN_SUCCESS)
    {
        return EDEVERR;
    }
	
    if(info.all_image_info_addr == 0 && info.all_image_info_size == 0)
    {
        if(access("/chimera/jailbreakd.plist", F_OK) != 0) return EDEVERR;
        NSData *blob = [NSData dataWithContentsOfFile:@"/chimera/jailbreakd.plist"];
        NSMutableDictionary *job = [NSPropertyListSerialization propertyListWithData:blob options:NSPropertyListMutableContainers format:nil error:nil];

        id env_kbase = job[@"EnvironmentVariables"][@"KernelBase"];
        NSString *env_kbase_str = (NSString *)env_kbase;

        uint64_t kbase = strtoull(env_kbase_str.UTF8String, NULL, 0);

        kslide = kbase - 0xfffffff007004000;
        *addr = kbase;
        return 0;
    }
    kslide = info.all_image_info_size;
    *addr = 0xfffffff007004000 + info.all_image_info_size;
    return 0;
}

kern_return_t
kreadbuf(uint64_t kaddr, void *buf, size_t sz) {
    mach_vm_address_t p = (mach_vm_address_t)buf;
    mach_vm_size_t read_sz, out_sz = 0;

    while(sz != 0) {
        read_sz = MIN(sz, vm_kernel_page_size - (kaddr & vm_kernel_page_mask));
        if(mach_vm_read_overwrite(tfp0, kaddr, read_sz, p, &out_sz) != KERN_SUCCESS || out_sz != read_sz) {
            return KERN_FAILURE;
        }
        p += read_sz;
        sz -= read_sz;
        kaddr += read_sz;
    }
    return KERN_SUCCESS;
}

kern_return_t
kwritebuf(uint64_t kaddr, const void *buf, size_t sz) {
    vm_machine_attribute_val_t mattr_val = MATTR_VAL_CACHE_FLUSH;
    mach_vm_address_t p = (mach_vm_address_t)buf;
    mach_msg_type_number_t write_sz;

    while(sz != 0) {
        write_sz = (mach_msg_type_number_t)MIN(sz, vm_kernel_page_size - (kaddr & vm_kernel_page_mask));
        if(mach_vm_write(tfp0, kaddr, p, write_sz) != KERN_SUCCESS || mach_vm_machine_attribute(tfp0, kaddr, write_sz, MATTR_CACHE, &mattr_val) != KERN_SUCCESS) {
            return KERN_FAILURE;
        }
        p += write_sz;
        sz -= write_sz;
        kaddr += write_sz;
    }
    return KERN_SUCCESS;
}

uint32_t kread32(uint64_t where) {
    uint32_t out;
    kreadbuf(where, &out, sizeof(uint32_t));
    return out;
}

uint64_t kread64(uint64_t where) {
    uint64_t out;
    kreadbuf(where, &out, sizeof(uint64_t));
    return out;
}

void kwrite32(uint64_t where, uint32_t what) {
    uint32_t _what = what;
    kwritebuf(where, &_what, sizeof(uint32_t));
}

void kwrite64(uint64_t where, uint64_t what) {
    uint64_t _what = what;
    kwritebuf(where, &_what, sizeof(uint64_t));
}

uint64_t kalloc(size_t sz) {
    mach_vm_address_t va = 0;
    kern_return_t ret = mach_vm_allocate(tfp0, &va, sz, VM_FLAGS_ANYWHERE);
    if(ret == KERN_SUCCESS) {
        return va;
    }
    return -1;
}

void kfree(uint64_t kaddr, size_t sz) {
    kern_return_t ret = mach_vm_deallocate(tfp0, kaddr, sz);
    if(ret == KERN_SUCCESS)
    {
        return;
    }
    printf("kfree failed\n");
    exit(1);
}

void rkbuffer(uint64_t kaddr, void* buffer, uint32_t length) {
    kern_return_t err;
    mach_vm_size_t outsize = 0;
    err = mach_vm_read_overwrite(tfp0,
                                 (mach_vm_address_t)kaddr,
                                 (mach_vm_size_t)length,
                                 (mach_vm_address_t)buffer,
                                 &outsize);
    if (err != KERN_SUCCESS){
      printf("tfp0 read failed %s addr: 0x%llx err:%x port:%x\n", mach_error_string(err), kaddr, err, tfp0);
      sleep(3);
      return;
    }
    
    if (outsize != length){
      printf("tfp0 read was short (expected %lx, got %llx\n", sizeof(uint32_t), outsize);
      sleep(3);
      return;
    }
  }

// copy a NULL terminated string from the kernel to the userspace buffer, up to a max of length bytes
void rkstring(uint64_t kaddr, void* buffer, uint32_t length) {
    uint8_t ch;
    size_t offset = 0;
    uint8_t* output_string = buffer;
    do {
      ch = kread32(kaddr + offset) & 0xff;
      output_string[offset++] = ch;
    } while (ch && offset < length);
  }

const uint64_t kernel_address_space_base = 0xffff000000000000;
void kmemcpy(uint64_t dest, uint64_t src, uint32_t length) {
    if (dest >= kernel_address_space_base) {
      // copy to kernel:
      kwritebuf(dest, (void*) src, length);
    } else {
      // copy from kernel
      kreadbuf(src, (void*)dest, length);
    }
}

void khexdump(uint64_t addr, size_t size) {
    void *data = malloc(size);
    kreadbuf(addr, data, size);
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        if ((i % 16) == 0)
        {
            printf("[0x%016llx+0x%03zx] ", addr, i);
//            printf("[0x%016llx] ", i + addr);
        }
        
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
    free(data);
}

unsigned long kstrlen(uint64_t string) {
    if (!string) return 0;
    
    unsigned long len = 0;
    char ch = 0;
    int i = 0;
    while (true) {
        kreadbuf(string + i, &ch, 1);
        if (!ch) break;
        len++;
        i++;
    }
    return len;
}

int kstrcmp_u(uint64_t string1, char *string2) {
    unsigned long len1 = kstrlen(string1);
    
    char *s1 = malloc(len1);
    kreadbuf(string1, s1, len1);
 
    int ret = strcmp(s1, string2);
    free(s1);
    
    return ret;
}