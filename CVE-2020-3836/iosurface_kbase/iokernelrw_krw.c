#include "iokernelrw_krw.h"

#include <iokernelrw.h>
#include <stdint.h>
#include <mach/mach.h> 
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#include "helper.h"

extern io_connect_t iokernelrw_client;

uint64_t kbase = 0;
uint64_t kslide = 0;

#ifndef MIN
#    define MIN(a, b) ((a) < (b) ? (a) : (b))
#endif

int get_kbase(uint64_t *addr)
{
    if(getuid() != 0) {
        ERROR("should be root to get_kbase\n");
        exit(1);
    }

    uint64_t kbase = get_kbase_via_kext();
    if(kbase != 0) {
        *addr = kbase;
        kslide = kbase - 0xffffff8000200000;
        return 0;
    }
    return ENOTSUP;
}

uint64_t find_kext_address(const char *identifier)
{
    uint64_t addr = 0;

    CFDictionaryRef loadedKextInfo = OSKextCopyLoadedKextInfo(NULL, NULL);
    CFIndex count = CFDictionaryGetCount(loadedKextInfo);

    void **keys;
    void **values;

    keys = (void **)malloc(sizeof(void *) * count);
    values = (void **)malloc(sizeof(void *) * count);

    CFDictionaryGetKeysAndValues(loadedKextInfo,
                                 (const void **)keys,
                                 (const void **)values);

    for (int i = 0; i < count; i++)
    {
        const char *name = CFStringGetCStringPtr(
                               CFDictionaryGetValue(values[i], CFSTR("CFBundleIdentifier")),
                               kCFStringEncodingMacRoman);
        if (strcmp(name, identifier) == 0)
        {
            CFNumberGetValue(CFDictionaryGetValue(values[i], CFSTR("OSBundleLoadAddress")),
                             kCFNumberSInt64Type,
                             &addr);
            break;
        }
    }

    return addr;
}

uint64_t get_kbase_via_kext(void) {
    struct {
		uint32_t pri_prot, pri_max_prot, pri_inheritance, pri_flags;
		uint64_t pri_offset;
		uint32_t pri_behavior, pri_user_wired_cnt, pri_user_tag, pri_pages_resident, pri_pages_shared_now_private, pri_pages_swapped_out, pri_pages_dirtied, pri_ref_cnt, pri_shadow_depth, pri_share_mode, pri_private_pages_resident, pri_shared_pages_resident, pri_obj_id, pri_depth;
		uint64_t pri_addr;
		uint64_t pri_sz;
	} pri;

    char kext_name[KMOD_MAX_NAME];
    CFStringRef kext_name_cf;
    CFNumberRef kext_addr_cf;
    CFArrayRef kext_names;
    CFDictionaryRef kexts_info;
    CFDictionaryRef kext_info;
    uint64_t kext_addr;

    for(pri.pri_addr = 0; proc_pidinfo(0, PROC_PIDREGIONINFO, pri.pri_addr, &pri, sizeof(pri)) == sizeof(pri); pri.pri_addr += pri.pri_sz) {
        if(pri.pri_prot == VM_PROT_READ && pri.pri_user_tag == VM_KERN_MEMORY_OSKEXT) {
            break;
        }
    }
    
    uint64_t kext_addr_slid = iokrw_kread64(pri.pri_addr + LOADED_KEXT_SUMMARY_HDR_ADDR_OFF);
    printf("kext_addr_slid: 0x%llx\n", kext_addr_slid);

    if(iokrw_kreadbuf(pri.pri_addr + LOADED_KEXT_SUMMARY_HDR_NAME_OFF, kext_name, sizeof(kext_name)) != KERN_SUCCESS) return 0;
    printf("kext_name: %s\n", kext_name);

    return 0xffffff8000200000 + kext_addr_slid - find_kext_address(kext_name);    
}

kern_return_t iokrw_kreadbuf(uint64_t kaddr, void *data, size_t size) {
    kern_return_t kr = iokernelrw_read(iokernelrw_client, kaddr, data, size);
    return kr;
}

kern_return_t
iokrw_kwritebuf(uint64_t kaddr, const void *data, size_t size) {
    kern_return_t kr = iokernelrw_write(iokernelrw_client, &data, kaddr, size);
    return kr;
}

uint32_t iokrw_kread32(uint64_t where) {
    uint32_t out;
    iokrw_kreadbuf(where, &out, sizeof(uint32_t));
    return out;
}

uint64_t iokrw_kread64(uint64_t where) {
    uint64_t out;
    iokrw_kreadbuf(where, &out, sizeof(uint64_t));
    return out;
}

void iokrw_kwrite32(uint64_t where, uint32_t what) {
    uint32_t _what = what;
    iokrw_kwritebuf(where, &_what, sizeof(uint32_t));
}

void iokrw_kwrite64(uint64_t where, uint64_t what) {
    uint64_t _what = what;
    iokrw_kwritebuf(where, &_what, sizeof(uint64_t));
}

void iokrw_khexdump(uint64_t addr, size_t size) {
    puts("=============================");
    void *data = malloc(size);
    iokrw_kreadbuf(addr, data, size);
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        if ((i % 16) == 0)
        {
            printf("[0x%016llx+0x%03zx] ", addr, i);
//            printf("[0x%016llx] ", i + addr);
        }
        
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
    free(data);
    puts("=============================");
}