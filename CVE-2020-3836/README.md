## Mission Completed
Obtain kernel's ipc_port address from userspace's mach port name<br>

## Environment
- macOS 10.15.2 (19C57)
- Installed Kernel from Kernel Debug Kit 10.15.2 build 19C46a
- Darwin Kernel Version 19.2.0: Wed Nov 13 22:22:44 PST 2019; root:xnu-6153.61.1~26/RELEASE_X86_64

# [Practice] Understanding CVE-2020-3836(cuck00)

## Understanding the Bug

This bug allows leaking the kernel space address of the ipc_port structure by providing a mach port name from user space. It exists even in very old versions like xnu-123.5 and has persisted for over 20 years.

IOKit drivers often use callback mechanisms, usually centered around mach ports. One of the features provided by `IOUserClient` is the **`OSAsyncReference64`** function. The type declaration is as follows:

[https://github.com/apple-oss-distributions/xnu/blob/xnu-6153.61.1/iokit/IOKit/OSMessageNotification.h#L92](https://github.com/apple-oss-distributions/xnu/blob/xnu-6153.61.1/iokit/IOKit/OSMessageNotification.h#L92)

```cpp
// --------------
enum {
	kOSAsyncRef64Count  = 8,
	kOSAsyncRef64Size   = kOSAsyncRef64Count * ((int) sizeof(io_user_reference_t))
};
typedef io_user_reference_t OSAsyncReference64[kOSAsyncRef64Count];
```

`io_user_reference_t` is a `uint64_t` type, but the value is taken from user space. Drivers that want to use this feature can either create the structure directly or call `IOUserClient::setAsyncReference64`. The implementation itself is not very important; what really matters is how the message sent back to userland is constructed, which is done by `IOUserClient::_sendAsyncResult64`.

Here, you can find the bug, with key parts marked as “XXX BELOW HERE …”. Let’s take a closer look.

[https://github.com/apple-oss-distributions/xnu/blob/xnu-6153.61.1/iokit/Kernel/IOUserClient.cpp#L2030](https://github.com/apple-oss-distributions/xnu/blob/xnu-6153.61.1/iokit/Kernel/IOUserClient.cpp#L2030)

```cpp
IOReturn
IOUserClient::_sendAsyncResult64(OSAsyncReference64 reference,
    IOReturn result, io_user_reference_t args[], UInt32 numArgs, IOOptionBits options)
{
	struct ReplyMsg {
		mach_msg_header_t msgHdr;
		union{
			struct{
				OSNotificationHeader     notifyHdr;
				IOAsyncCompletionContent asyncContent;
				uint32_t                 args[kMaxAsyncArgs];
			} msg32;
			struct{
				OSNotificationHeader64   notifyHdr;
				IOAsyncCompletionContent asyncContent;
				io_user_reference_t      args[kMaxAsyncArgs] __attribute__ ((packed));
			} msg64;
		} m;
	};
	ReplyMsg      replyMsg;
	mach_port_t   replyPort;
	kern_return_t kr;

	// If no reply port, do nothing.
	// **XXX BELOW HERE 1**
	**replyPort = (mach_port_t) (reference[0] & ~kIOUCAsync0Flags);** 
	if (replyPort == MACH_PORT_NULL) {
		return kIOReturnSuccess;
	}

	if (numArgs > kMaxAsyncArgs) {
		return kIOReturnMessageTooLarge;
	}

	bzero(&replyMsg, sizeof(replyMsg));
	replyMsg.msgHdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND /*remote*/,
	    0 /*local*/);
	replyMsg.msgHdr.msgh_remote_port = replyPort;
	replyMsg.msgHdr.msgh_local_port  = NULL;
	replyMsg.msgHdr.msgh_id          = kOSNotificationMessageID;
	if (kIOUCAsync64Flag & reference[0]) {
		replyMsg.msgHdr.msgh_size =
		    sizeof(replyMsg.msgHdr) + sizeof(replyMsg.m.msg64)
		    - (kMaxAsyncArgs - numArgs) * sizeof(io_user_reference_t);
		replyMsg.m.msg64.notifyHdr.size = sizeof(IOAsyncCompletionContent)
		    + numArgs * sizeof(io_user_reference_t);
		replyMsg.m.msg64.notifyHdr.type = kIOAsyncCompletionNotificationType;
		**// XXX BELOW HERE 2
		bcopy(reference, replyMsg.m.msg64.notifyHdr.reference, sizeof(OSAsyncReference64));**

		replyMsg.m.msg64.asyncContent.result = result;
		if (numArgs) {
			bcopy(args, replyMsg.m.msg64.args, numArgs * sizeof(io_user_reference_t));
		}
	} else {
		...
	}

	...
	return kr;
}
```

The `IOUserClient::_sendAsyncResult64` function takes `OSAsyncReference64` and sends it, along with other values, to userland as a mach message.
Here, the first element of `OSAsyncReference64` is a `mach_port_t`, i.e., the mach port to send the message to.

```cpp
replyPort = (mach_port_t) (reference[0] & ~kIOUCAsync0Flags);
```

This `mach_port_t` is just a raw pointer in the kernel, and since the structure containing the kernel pointer is sent directly to userland, a leak occurs.

```cpp
bcopy(reference, replyMsg.m.msg64.notifyHdr.reference, sizeof(OSAsyncReference64));
```

## How to Trigger

[Siguza’s blog post](https://blog.siguza.net/cuck00/) describes the following:

> After the usual IOSurface setup (creation of the userclient and surface), all you have to do is:
> 
> - Call `setNotify` (external method 17) with one of the async functions and pass it a mach port.
> - Call `incrementUseCount` followed by `decrementUseCount` (methods 14 and 15 respectively) - I have no idea what they’re really intended for, but if the count they operate on hits zero, a message is sent back to userland.
> - Receive a message on your mach port and enjoy your free kernel pointer.

I was curious how the code reached the `IOUserClient::_sendAsyncResult64` function, so I ran the PoC code. I confirmed that it is reachable via the `IOSurfaceRootUserClient::decrement_surface_use_count` function. I analyze it by tracing back from here.

- Backtrace when a breakpoint is set at the kernel’s `IOUserClient::_sendAsyncResult64` function where `mach_msg_send_from_kernel_proper` is called:

```nasm
(lldb) bt
* thread #2, stop reason = breakpoint 20.1
  * frame #0: 0xffffff800746bbeb kernel`IOUserClient::_sendAsyncResult64(reference=0xffffff801875f3d0, result=0, args=<unavailable>, numArgs=2, options=0) at IOUserClient.cpp:2108:8 [opt]
    frame #1: 0xffffff7f89344929 <- IOSurface`IOSurfaceRootUserClient::notify_surface+0x30
    frame #2: 0xffffff7f89340ce0 <- IOSurface`IOSurfaceRoot::notifySurface+0x3C
    frame #3: 0xffffff7f89343a19 IOSurface`IOSurfaceRootUserClient::decrement_surface_use_count+0x67
    frame #4: 0xffffff8007466fcb kernel`IOUserClient::externalMethod(this=<unavailable>, selector=<unavailable>, args=<unavailable>, dispatch=<unavailable>, target=<unavailable>, reference=<unavailable>) at IOUserClient.cpp:5888:10 [opt]
    frame #5: 0xffffff8007470083 kernel`::is_io_connect_method(connection=0xffffff8015f73610, selector=15, scalar_input=<unavailable>, scalar_inputCnt=<unavailable>, inband_input=<unavailable>, inband_inputCnt=0, ool_input=0, ool_input_size=0, inband_output="", inband_outputCnt=0xffffff80188b460c, scalar_output=0xffffff90a48b3d00, scalar_outputCnt=0xffffff90a48b3cfc, ool_output=0, ool_output_size=0xffffff80157551a8) at IOUserClient.cpp:4495:16 [opt]
    frame #6: 0xffffff8006e22c22 kernel`_Xio_connect_method(InHeadP=<unavailable>, OutHeadP=0xffffff80188b45e0) at device_server.c:8389:18 [opt]
    frame #7: 0xffffff8006d41998 kernel`ipc_kobject_server(request=0xffffff80157550e0, option=3) at ipc_kobject.c:389:4 [opt]
    frame #8: 0xffffff8006d18625 kernel`ipc_kmsg_send(kmsg=0xffffff80157550e0, option=3, send_timeout=0) at ipc_kmsg.c:1937:10 [opt]
    frame #9: 0xffffff8006d2f0d5 kernel`mach_msg_overwrite_trap(args=<unavailable>) at mach_msg.c:553:8 [opt]
    frame #10: 0xffffff8006e4b485 kernel`mach_call_munger64(state=0xffffff80141abaa0) at bsd_i386.c:618:24 [opt]
    frame #11: 0xffffff8006ce3226 kernel`hndl_mach_scall64 + 22
(lldb) 
```

The `IOSurface::decrement_use_count` function is a wrapper that can call `IOSurfaceRoot::notifySurface`,

```cpp
void __fastcall IOSurface::decrement_use_count(IOSurface *this)
{
  if ( OSDecrementAtomic((SInt32 *)(this->field_C0 + 20LL)) == 1 )
  {
    if ( this->field_25 )
      IOSurface::purge(this);
    IOSurfaceRoot::notifySurface((IORecursiveLock **)this->field_28, 0, this);
  }
}
```

To trigger it, the variable `v4` must return 1.
The place that sets `v4` is the `IOSurfaceClient::decrement_use_count` function,

```cpp
__int64 __fastcall IOSurfaceRootUserClient::decrement_surface_use_count(IOSurfaceRootUserClient *this, unsigned int a2)
{
  IOSurfaceClient *v2; // r15
  IOSurface *IOSurface; // r14
  bool v4; // r15

  IOLockLock((IOLock *)this->m_lock);
  if ( LODWORD(this->i_surfaceClientCapacity) > a2 && (v2 = this->m_IOSurfaceClientArrayPointer[a2]) != 0 )
  {
    IOSurface = v2->IOSurface;
    IOSurface->struct_19F28_vtable->__ZNK9IOSurface6retainEv(IOSurface);
    v4 = IOSurfaceClient::decrement_use_count(v2);
    IOLockUnlock((IOLock *)this->m_lock);
    if ( v4 )                                   // 0x1a198 = vtable
      IOSurface->struct_19F28_vtable->__ZN9IOSurface19decrement_use_countEv(IOSurface);
    IOSurface->struct_19F28_vtable->__ZN9IOSurface7releaseEv(IOSurface);
    return 0;
  }
  else
  {
    IOLockUnlock((IOLock *)this->m_lock);
    return 3758097090LL;
  }
}
```

In this case, you can guess that the `+0x24` offset is the `use_count` field,
and the `use_count` field must be 1 before decrementing.

**Therefore, before calling `decrementUseCount`, you need to make the `use_count` field 1 by first calling the `incrementUseCount` function.**

```cpp
bool __fastcall IOSurfaceClient::decrement_use_count(void *this)
{
  int v1; // eax

  v1 = *((_DWORD *)this + 0x24);
  if ( v1 )
    *((_DWORD *)this + 0x24) = v1 - 1;
  return v1 == 1;
}
```

The call numbers are as follows:

- 14: `IOSurfaceRootUserClient::increment_surface_use_count`
- 15:  `IOSurfaceRootUserClient::decrement_surface_use_count`

Below is the code for the `incrementUseCount` related function.

- IOSurfaceRootUserClient::increment_surface_use_count

```cpp
__int64 __fastcall IOSurfaceRootUserClient::increment_surface_use_count(IOSurfaceRootUserClient *this, unsigned int a2)
{
  IOSurfaceClient *v2; // r15
  IOSurface *IOSurface; // r14
  bool v4; // r15

  IOLockLock((IOLock *)this->m_lock);
  if ( LODWORD(this->i_surfaceClientCapacity) > a2 && (v2 = this->m_IOSurfaceClientArrayPointer[a2]) != 0 )
  {
    IOSurface = v2->IOSurface;
    IOSurface->struct_19F28_vtable->__ZNK9IOSurface6retainEv(IOSurface);
    v4 = IOSurfaceClient::increment_use_count(v2);
    IOLockUnlock((IOLock *)this->m_lock);
    if ( v4 )
      IOSurface->struct_19F28_vtable->__ZN9IOSurface19increment_use_countEv(IOSurface);
    IOSurface->struct_19F28_vtable->__ZN9IOSurface7releaseEv(IOSurface);
    return 0;
  }
  else
  {
    IOLockUnlock((IOLock *)this->m_lock);
    return 0xE00002C2LL;
  }
}
```

### IOSurfaceRoot::setSurfaceNotify

Before calling `incrementUseCount`, need to pass the user space mach port together.

The call number is 17.

```cpp
__int64 __fastcall IOSurfaceRoot::setSurfaceNotify(
        __int64 a1,
        mach_port_t *a2,
        mach_vm_address_t *a3,
        IOSurfaceRootUserClient *a4)
{
  __int64 **v6; // rax
  _QWORD *v7; // rax
  _QWORD *v8; // r12
  _QWORD *v9; // r13
  __int64 v10; // rax
  _QWORD *v11; // rax
  unsigned int v12; // ebx

  IORecursiveLockLock(*(IORecursiveLock **)(a1 + 256));
  v6 = *(__int64 ***)(a1 + 336);
  if ( v6 )
  {
    while ( v6[4] != (__int64 *)a3[1] || v6[11] != (__int64 *)a4 )
    {
      v6 = (__int64 **)*v6;
      if ( !v6 )
        goto LABEL_5;
    }
    v12 = -536870199;
  }
  else
  {
LABEL_5:
    v7 = IOMalloc(0x60u);
    if ( v7 )
    {
      v8 = v7;
      v9 = (_QWORD *)(a1 + 336);
      memset(v7, 0, 0x60u);
      IOUserClient::setAsyncReference64(v8 + 2, *a2, *a3, a3[1]);
      v8[11] = a4;
      v8[10] = a3[2];
      v10 = *(_QWORD *)(a1 + 336);
      if ( v10 )
      {
        if ( *(_QWORD **)(v10 + 8) != v9 )
          IOSurfaceRoot::setSurfaceNotify((const void *)(a1 + 336));// panic
        *v8 = v10;
        v11 = (_QWORD *)(v10 + 8);
      }
      else
      {
        *v8 = 0;
        v11 = (_QWORD *)(a1 + 344);
      }
      *v11 = v8;
      *v9 = v8;
      v8[1] = v9;
      v12 = 0;
    }
    else
    {
      v12 = -536870211;
    }
  }
  IORecursiveLockUnlock(*(IORecursiveLock **)(a1 + 256));
  return v12;
}
```

## Result

```nasm
seo@seos-iMac-Pro CVE-2020-3836 % ./leak
[*] page size: 0x1000, kr=(os/kern) successful
[*] IOSurface_init success, IOSurface_id=0x2
[*] port: 0x2703, (os/kern) successful
[*] leaked_port_addr: 0xffffff80173028b0
...

(lldb) p/x *(ipc_port_t)0xffffff80173028b0
(ipc_port) $36 = {
  ip_object = {
    io_bits = 0x80000000
    io_references = 0x00000002
    io_lock_data = (interlock = 0x0000000000000000)
  }
  ip_messages = {
    data = {
      port = {
        waitq = {
          waitq_type = 0x00000001
          waitq_fifo = 0x00000001
          waitq_prepost = 0x00000000
          waitq_irq = 0x00000000
          waitq_isvalid = 0x00000001
          waitq_turnstile = 0x00000000
          waitq_eventmask = 0x00000000
          waitq_interlock = (lock_data = 0x0000000000000000)
          waitq_set_id = 0x0000000000000000
          waitq_prepost_id = 0x0000000000000000
           = {
            waitq_queue = {
              next = NULL
              prev = NULL
            }
            waitq_prio_queue = (pq_root_packed = 0x0000000000000000)
             = {
              waitq_ts = NULL
              waitq_tspriv = 0x0000000000000000
            }
          }
        }
        messages = {
          ikmq_base = NULL
        }
        seqno = 0x00000001
        receiver_name = 0x00002703
        msgcount = 0x0000
        qlimit = 0x0005
        qcontext = 0x00000000
      }
      pset = {
        setq = {
          wqset_q = {
            waitq_type = 0x00000001
            waitq_fifo = 0x00000001
            waitq_prepost = 0x00000000
            waitq_irq = 0x00000000
            waitq_isvalid = 0x00000001
            waitq_turnstile = 0x00000000
            waitq_eventmask = 0x00000000
            waitq_interlock = (lock_data = 0x0000000000000000)
            waitq_set_id = 0x0000000000000000
            waitq_prepost_id = 0x0000000000000000
             = {
              waitq_queue = {
                next = NULL
                prev = NULL
              }
              waitq_prio_queue = (pq_root_packed = 0x0000000000000000)
               = {
                waitq_ts = NULL
                waitq_tspriv = 0x0000000000000000
              }
            }
          }
          wqset_id = 0x0000000000000000
           = (wqset_prepost_id = 0x0000270300000001, wqset_prepost_hook = 0x0000270300000001)
        }
      }
    }
     = {
      imq_klist = {
        slh_first = NULL
      }
      imq_inheritor_knote = NULL
      imq_inheritor_turnstile = NULL
      imq_inheritor_thread_ref = NULL
      imq_srp_owner_thread = NULL
    }
  }
  data = {
    receiver = 0xffffff801286fb40
    destination = 0xffffff801286fb40
    timestamp = 0x1286fb40
  }
  kdata = {
    kobject = 0x0000000000000000
    imp_task = NULL
    sync_inheritor_port = NULL
    sync_inheritor_knote = NULL
    sync_inheritor_ts = NULL
  }
  ip_nsrequest = NULL
  ip_pdrequest = NULL
  ip_requests = NULL
  kdata2 = {
    premsg = NULL
    send_turnstile = NULL
  }
  ip_context = 0x0000000000000000
  ip_sprequests = 0x00000000
  ip_spimportant = 0x00000000
  ip_impdonation = 0x00000000
  ip_tempowner = 0x00000000
  ip_guarded = 0x00000000
  ip_strict_guard = 0x00000000
  ip_specialreply = 0x00000000
  ip_sync_link_state = 0x00000000
  ip_sync_bootstrap_checkin = 0x00000000
  ip_immovable_receive = 0x00000000
  ip_no_grant = 0x00000000
  ip_immovable_send = 0x00000000
  ip_impcount = 0x00000000
  ip_mscount = 0x00000001
  ip_srights = 0x00000001
  ip_sorights = 0x00000000
}
```

## References and Sources
Exploit Code

- [https://github.com/Siguza/cuck00](https://github.com/Siguza/cuck00)

- [https://github.com/jakeajames/time_waste/blob/master/time_waste/exploit.c#L93](https://github.com/jakeajames/time_waste/blob/master/time_waste/exploit.c#L93)

- [https://github.com/staturnzz/chimera_patch/blob/main/src/time_saved.c#L36](https://github.com/staturnzz/chimera_patch/blob/main/src/time_saved.c#L36)

Writeup

- [https://rls1004.github.io/2020-12-10-cuck00/](https://rls1004.github.io/2020-12-10-cuck00/)

- [https://bugs.chromium.org/p/project-zero/issues/detail?id=1969](https://bugs.chromium.org/p/project-zero/issues/detail?id=1969)

- [https://blog.siguza.net/cuck00/](https://blog.siguza.net/cuck00/)