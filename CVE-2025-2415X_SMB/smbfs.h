/* Compression */
#define kClientCompressMaxEntries 64 /* max exclude/include for compression extensions */
#define kClientCompressMaxExtLen 16  /* max extension string length */

#define SMB_MAX_UNIQUE_ID	128 + MAXPATHLEN + (int32_t)sizeof(struct sockaddr_storage)  /* Share name, path, sockaddr */

/* Layout of the mount control block for an smb file system. */
struct smb_mount_args {
	int32_t		version;
	int32_t		dev;
	int64_t		altflags;
	int32_t		KernelLogLevel;
	uid_t		uid;
	gid_t 		gid;
	mode_t 		file_mode;
	mode_t 		dir_mode;
	uint32_t	path_len;
	int32_t		unique_id_len;
	char		path[MAXPATHLEN] __attribute((aligned(8))); /* The starting path they want used for the mount */
	char		url_fromname[MAXPATHLEN] __attribute((aligned(8))); /* The from name is the url used to mount the volume. */
	unsigned char	unique_id[SMB_MAX_UNIQUE_ID] __attribute((aligned(8))); /* A set of bytes that uniquely identifies this volume */
	char		volume_name[MAXPATHLEN] __attribute((aligned(8))); /* The starting path they want used for the mount */
	uint64_t	ioc_reserved __attribute((aligned(8))); /* Force correct size always */
	int32_t         ip_QoS;
	int32_t		max_resp_timeout;
	int32_t		dir_cache_async_cnt;
	int32_t		dir_cache_max;
	int32_t		dir_cache_min;
	int32_t		max_dirs_cached;
	int32_t		max_dir_entries_cached;
	int32_t		read_size[3];
	int32_t		read_count[3];
	int32_t		write_size[3];
	int32_t		write_count[3];
	int32_t		rw_max_check_time;
	int32_t		rw_gb_threshold;
	/* Snapshot time support */
	char		snapshot_time[32] __attribute((aligned(8)));
	time_t 		snapshot_local_time;
	
	/*
	 * Compression
	 */
	
	/* Client compression algorithm map passed into session via ioctl */
	uint32_t	compression_io_threshold; /* Min IO size to try to compress */
	uint32_t        compression_chunk_len;
	uint32_t        compression_max_fail_cnt;
	
	char		compression_exclude[kClientCompressMaxEntries][kClientCompressMaxExtLen];
	uint32_t	compression_exclude_cnt;
	char		compression_include[kClientCompressMaxEntries][kClientCompressMaxExtLen];
	uint32_t	compression_include_cnt;
};

#define	SMB_MAXSHARENAMELEN		240
struct smbioc_share {
	uint32_t	ioc_version;
	uint32_t	ioc_optionalSupport;
	uint16_t	ioc_fstype;
	char		ioc_share[SMB_MAXSHARENAMELEN + 1] __attribute((aligned(8)));
	uint64_t	ioc_reserved __attribute((aligned(8))); /* Force correct size always */
};

/* Negotiate Ioctl extra flags */
#define SMB_SHARING_SESSION      0x01	/* We are sharing this session */
#define SMB_FORCE_NEW_SESSION    0x02	/* Use a new session */
#define SMB_SMB1_ENABLED         0x04	/* SMB 1 Enabled */
#define SMB_SMB2_ENABLED         0x08	/* SMB 2 Enabled */
#define SMB_SIGNING_REQUIRED     0x10
#define SMB_SMB3_ENABLED         0x20	/* SMB 3 Enabled */
#define SMB_MATCH_DNS            0x40	/* Try to find mounted srvrs using dns */
#define SMB_SMB1_SIGNING_REQ     0x80	/* Signing required for SMB 1 */
#define SMB_SMB2_SIGNING_REQ    0x100	/* Signing required for SMB 2 */
#define SMB_SMB3_SIGNING_REQ    0x200   /* Signing required for SMB 3 */
#define SMB_HIFI_REQUESTED      0x400   /* HiFi mode is being requested */
#define SMB_MULTICHANNEL_ENABLE 0x800   /* Enable Multi-Channel SMB */
#define SMB_MC_PREFER_WIRED             0x00001000   /* Prefer wired NICs in multichannel */
#define SMB_DISABLE_311                 0x00002000   /* Disable SMB v3.1.1 */
#define SMB_ENABLE_AES_128_CCM          0x00004000   /* Enable SMB v3.1.1 AES_128_CCM encryption */
#define SMB_ENABLE_AES_128_GCM          0x00008000   /* Enable SMB v3.1.1 AES_128_GCM encryption */
#define SMB_ENABLE_AES_256_CCM          0x00010000   /* Enable SMB v3.1.1 AES_256_CCM encryption */
#define SMB_ENABLE_AES_256_GCM          0x00020000   /* Enable SMB v3.1.1 AES_256_GCM encryption */
#define SMB_FORCE_SESSION_ENCRYPT       0x00040000   /* Force session level encryption */
#define SMB_FORCE_SHARE_ENCRYPT         0x00080000   /* Force share level encryption  */
#define SMB_ENABLE_AES_128_CMAC         0x00100000   /* Enable SMB v3.1.1 AES_128_CMAC signing */
#define SMB_ENABLE_AES_128_GMAC         0x00200000   /* Enable SMB v3.1.1 AES_128_GMAC signing */
#define SMB_COMPRESSION_CHAINING_OFF    0x00400000   /* Chained compression enabled */
#define SMB_MC_CLIENT_RSS_FORCE_ON      0x00800000   /* MultiChannel force client side RSS on */

#define SMB_IOC_SPI_INIT_SIZE	8 * 1024 /* Inital buffer size for server provided init token */

/* Multichannel interfaces ignore list */
#define kClientIfIgnorelistMaxLen 32 /* max len of client interface ignorelist */

/*
 * Used to verify the userland and kernel are using the
 * correct structure. Only needs to be changed when the
 * structure in this routine are changed.
 */
#define SMB_IOC_STRUCT_VERSION		170

/*
 * Some names length limitations. Some of them aren't declared by specs,
 * but we need reasonable limits.
 */
#define SMB_MAXNetBIOSNAMELEN    15    /* NetBIOS limit */
#define SMB_MAX_DOMAIN_NAMELEN  255    /* Max Fully Qual Domain Name len */
#define SMB_MAX_DNS_SRVNAMELEN	255
#define SMB_MAXUSERNAMELEN	128
#define SMB_MAXPASSWORDLEN	128
#define SMB_MAX_NTLM_NAME	(SMB_MAX_DNS_SRVNAMELEN + 1 + SMB_MAXUSERNAMELEN)
/* Max Kerberos principal name length we support */
#define SMB_MAX_KERB_PN		1024
#define SMB_MAX_NATIVE_OS_STRING		256
#define SMB_MAX_NATIVE_LANMAN_STRING	256

/* Declare a pointer member of a ioctl structure. */
#define SMB_IOC_POINTER(TYPE, NAME) \
    union { \
	user_addr_t	ioc_kern_ ## NAME __attribute((aligned(8))); \
	TYPE		ioc_ ## NAME __attribute((aligned(8))); \
    }

struct smbioc_ossn {
    uint32_t    ioc_reconnect_wait_time;
    uid_t        ioc_owner;
    char        ioc_srvname[SMB_MAX_DNS_SRVNAMELEN+1] __attribute((aligned(8)));
    char        ioc_localname[SMB_MAXNetBIOSNAMELEN+1] __attribute((aligned(8)));
};

/* 
 * The SMBIOC_NEGOTIATE ioctl is a read/write ioctl. So we use smbioc_negotiate
 * structure to pass information from the user land to the kernel and vis-versa  
 */
struct smbioc_negotiate {
	uint32_t	ioc_version;
	uint32_t	ioc_extra_flags;
	uint32_t	ioc_ret_caps;
	uint32_t	ioc_ret_session_flags;
	int32_t		ioc_saddr_len;
	int32_t		ioc_laddr_len;
	uint32_t	ioc_ntstatus;
	uint32_t	ioc_errno;
    uuid_t      ioc_client_guid;    /* SMB 2/3 */
	SMB_IOC_POINTER(struct sockaddr *, saddr);
	SMB_IOC_POINTER(struct sockaddr *, laddr);
	uint32_t	ioc_userflags;		/* Authentication request flags */
	uint32_t	ioc_max_client_size; /* If share, then the size of client principal name */
	uint32_t	ioc_max_target_size; /* If share, then the size of server principal name */
	struct smbioc_ossn	ioc_ssn __attribute((aligned(8)));
	char ioc_user[SMB_MAXUSERNAMELEN + 1] __attribute((aligned(8)));
	uint32_t	ioc_negotiate_token_len __attribute((aligned(8)));   /* Server provided init token length */
	user_addr_t	ioc_negotiate_token __attribute((aligned(8))); /* Server provided init token */
	int32_t     ioc_max_resp_timeout;
    char        ioc_dns_name[255] __attribute((aligned(8)));
    struct sockaddr_storage ioc_shared_saddr;   /* Shared server's address */
	uint64_t	ioc_reserved __attribute((aligned(8))); /* Force correct size always */
    uint32_t    ioc_mc_max_channel;
    uint32_t    ioc_mc_srvr_rss_channel;
    uint32_t    ioc_mc_clnt_rss_channel;
    uint32_t    ioc_mc_client_if_ignorelist[kClientIfIgnorelistMaxLen] __attribute((aligned(8)));
    uint32_t    ioc_mc_client_if_ignorelist_len;

    uint8_t     ioc_session_uuid[16];

    uint32_t    ioc_compression_algorithms_map;
};


/*
 * Device IOCTLs
 */
#define	SMBIOC_NEGOTIATE		_IOWR('n', 109, struct smbioc_negotiate)
#define	SMBIOC_TCON				_IOWR('n', 111, struct smbioc_share)





typedef uint64_t SMBFID;
struct smb2ioc_ioctl {
	uint32_t	ioc_version;
	uint32_t	ioc_ctl_code;
	SMBFID		ioc_fid;
	uint32_t	ioc_snd_input_len;
	uint32_t	ioc_snd_output_len;
	uint32_t	ioc_rcv_input_len;
	uint32_t	ioc_rcv_output_len;
	SMB_IOC_POINTER(void *, snd_input);
	SMB_IOC_POINTER(void *, snd_output);
	SMB_IOC_POINTER(void *, rcv_input);
	SMB_IOC_POINTER(void *, rcv_output);
    /* return values */
	uint32_t	ioc_ret_ntstatus;
	uint32_t	ioc_ret_flags;
	uint32_t    ioc_ret_input_len;
	uint32_t    ioc_ret_output_len;
};

/*
 * Pushing the limit here on the structure size. We are about 1K under the
 * max size support for a ioctl call.
 */
struct smbioc_setup {
	uint32_t	ioc_version;
	uint32_t	ioc_userflags;	/* userable settable session_flags see SMBV_USER_LAND_MASK */
	uint32_t	ioc_gss_client_nt;   /* Name type of client principal */
	uint32_t	ioc_gss_client_size; /* Size of GSS principal name */
	user_addr_t	ioc_gss_client_name; /* principal name */
	uint32_t	ioc_gss_target_nt; /* Name type of target princial */
	uint32_t	ioc_gss_target_size;/* Size of GSS target name */
	user_addr_t	ioc_gss_target_name;/* Target name */
	char		ioc_user[SMB_MAXUSERNAMELEN + 1] __attribute((aligned(8)));
	char		ioc_password[SMB_MAXPASSWORDLEN + 1] __attribute((aligned(8)));
	char		ioc_domain[SMB_MAX_DOMAIN_NAMELEN + 1] __attribute((aligned(8)));
    char        ioc_dns_name[255] __attribute((aligned(8)));
	uint64_t	ioc_reserved __attribute((aligned(8))); /* Force correct size always */
};

/* Shouldn't this be handle by gss */
enum smb_min_auth {
	SMB_MINAUTH = 0,			/* minimum auth level for connection */
	SMB_MINAUTH_LM = 1,			/* No plaintext passwords */
	SMB_MINAUTH_NTLM = 2,		/* don't send LM reply? */
	SMB_MINAUTH_NTLMV2 = 3,		/* don't fall back to NTLMv1 */
	SMB_MINAUTH_KERBEROS = 4	/* don't do NTLMv1 or NTLMv2 */
};

struct smb_prefs {
    CFStringRef         LocalNetBIOSName;
    CFArrayRef          WINSAddresses;
    int32_t             NetBIOSResolverTimeout;
    CFStringEncoding    WinCodePage;
    uint32_t            tryBothPorts;
    uint16_t            tcp_port;
    int32_t             KernelLogLevel;
    enum smb_min_auth   minAuthAllowed;
    int64_t             altflags;
    CFStringRef         NetBIOSDNSName;
    int32_t             protocol_version_map;
    uint32_t            lanman_on;
    uint32_t            signing_required;
    int32_t             signing_algorithm_map;
    int32_t             signing_req_versions;
    int32_t             max_resp_timeout;
    int32_t             ip_QoS;

    int32_t             dir_cache_async_cnt;
    int32_t             dir_cache_max;
    int32_t             dir_cache_min;
    int32_t             max_dirs_cached;
    int32_t             max_dir_entries_cached;

    uint32_t            no_DNS_match;
    uint32_t            try_netBIOS_before_DNS;

    int32_t             read_size[3];
    int32_t             read_count[3];
    int32_t             write_size[3];
    int32_t             write_count[3];
    
    int32_t             rw_max_check_time;
    int32_t             rw_gb_threshold;

    uint32_t            mc_max_channels;
    uint32_t            mc_srvr_rss_channels;
    uint32_t            mc_clnt_rss_channels;
    uint32_t            mc_client_if_ignorelist[kClientIfIgnorelistMaxLen];
    uint32_t            mc_client_if_ignorelist_len;
    
    int32_t             encrypt_algorithm_map;
    uint32_t            force_sess_encrypt;
    uint32_t            force_share_encrypt;

    int32_t             compression_algorithms_map;
    int32_t             compression_io_threshold;
    int32_t             compression_chunk_len;
    int32_t             compression_max_fail_cnt;
    char *              compression_exclude[kClientCompressMaxEntries];
    uint32_t            compression_exclude_cnt;
    char *              compression_include[kClientCompressMaxEntries];
    uint32_t            compression_include_cnt;
};

/*
 * nb environment
 */
struct nb_ctx {
	struct sockaddr_in	nb_ns;			/* ip addr of name server */
	struct sockaddr_in	nb_sender;		/* address of the system that responded */
};

typedef uint32_t NTSTATUS;

typedef int32_t refcount_t;

/*
 * SMB work context. Used to store all values which are necessary
 * to establish connection to an SMB server.
 */
struct smb_ctx {
	pthread_mutex_t ctx_mutex;
	CFURLRef		ct_url;
	uint32_t		ct_flags;	/* SMBCF_ */
	int				ct_fd;		/* handle of connection */
	uint16_t		ct_cancel;
	CFStringRef		serverNameRef; /* Display Server name obtain from URL or Bonjour Service Name */
	char *			serverName;		/* Server name obtain from the URL */
	struct nb_ctx		ct_nb;
	struct smbioc_ossn	ct_ssn;
	struct smbioc_setup ct_setup;
	struct smbioc_share	ct_sh;
	struct sockaddr	*ct_saddr;
	char *			ct_origshare;
	CFStringRef		mountPath;
	uint32_t		ct_session_uid;
	uint32_t		ct_session_caps;		/* Obtained from the negotiate message */
	uint32_t		ct_session_smb2_caps;
	uint32_t		ct_session_flags;	/* Obtained from the negotiate message */
    uint64_t		ct_session_misc_flags;
	uint32_t		ct_session_hflags;
	uint32_t		ct_session_hflags2;
	uint32_t		ct_session_shared;	/* Obtained from the negotiate message, currently only tells if the session is shared */
	uint64_t		ct_session_txmax;				
	uint64_t		ct_session_rxmax;
    uint64_t		ct_session_wxmax;
	int				forceNewSession;
	int				inCallback;
	int				serverIsDomainController;
	CFDictionaryRef mechDict;
	struct smb_prefs prefs;
    char *          model_info;     /* SMB 2/3 Server model string, only MAC to MAC */
};

struct smb_server_handle
{
    volatile refcount_t refcount;
    struct smb_ctx * context;
};

typedef struct smb_server_handle * SMBHANDLE;


/*! Create an authenticated session connection, don't tree connect. */
#define kSMBOptionSessionOnly			0x00010000

#define STATUS_SUCCESS 0x00000000
#define NT_SUCCESS(status) ((status & 0xC0000000) == STATUS_SUCCESS)